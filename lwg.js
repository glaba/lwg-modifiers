var emotes = /*emotesstart*/
[
	{
		"name": "Kappa",
		"img": "kappa.png",
		"free": true,
		"text": "Kappa",
		"type": "emotes"
	},
	
	{
		"name": "Apple",
		"img": "apple.png",
		"free": true,
		"text": "Apple",
		"type": "emotes"
	},
	
	{
		"name": "GG",
		"img": "gg.png",
		"free": true,
		"text": "GG",
		"type": "emotes"
	},
	
	{
		"name": "Nr. 1",
		"img": "nr1.png",
		"playerLvl": 2,
		"text": "#1",
		"type": "emotes",
		"dbPos": 1,
		"artNr": "e0001"
	},
	
	{
		"name": "OP",
		"img": "op.png",
		"playerLvl": 6,
		"text": "OP",
		"type": "emotes",
		"dbPos": 2,
		"artNr": "e0002"
	},
	
	{
		"name": "Jbs pls fix",
		"img": "jbsplsfix.png",
		"price": 0.79,
		"text": "JbsPlsFix",
		"type": "emotes",
		"dbPos": 3,
		"artNr": "e0003"
	},
	
	{
		"name": "Doge",
		"img": "doge.png",
		"gold": 800,
		"text": "Doge",
		"type": "emotes",
		"dbPos": 4,
		"artNr": "e0004"
	},
	
	{
		"name": "Nyan Cat",
		"img": "nyancat.png",
		"gold": 800,
		"text": "Nyancat",
		"type": "emotes",
		"dbPos": 5,
		"artNr": "e0005"
	},
	
	{
		"name": "WTF?",
		"img": "wtf.png",
		"gold": 1000,
		"text": "WTF",
		"type": "emotes",
		"dbPos": 6,
		"artNr": "e0006"
	},
	
	{
		"name": "You Dont Say",
		"img": "youdontsay.png",
		"price": 0.79,
		"text": "YouDontSay",
		"type": "emotes",
		"dbPos": 8,
		"artNr": "e0008"
	},
	
	{
		"name": "Fuuuuuuu",
		"img": "fuu.png",
		"gold": 1500,
		"text": "FU",
		"type": "emotes",
		"dbPos": 9,
		"artNr": "e0009"
	},
	
	{
		"name": "Pie",
		"img": "pie.png",
		"free": true,
		"text": "pielons",
		"type": "emotes"
	},
	
	{
		"name": "Soldier",
		"img": "soldier.png",
		"free": true,
		"text": "Soldier",
		"type": "emotes"
	},
	
	{
		"name": "Skeleton",
		"img": "skeleton.png",
		"playerLvl": 9,
		"text": "Skeleton",
		"type": "emotes",
		"dbPos": 10,
		"artNr": "e0010"
	},
	
	{
		"name": "Priest",
		"img": "priest.gif",
		"price": 0.79,
		"text": "Priest",
		"type": "emotes",
		"dbPos": 11,
		"artNr": "e0011"
	},
	
	{
		"name": "Wolf",
		"img": "wolf.png",
		"free": true,
		"text": "Wolf",
		"type": "emotes"
	},
	
	{
		"name": "ItanoCircus",
		"img": "itano.png",
		"text": "ItanoCircus",
		"dbPos": 12,
		"price": 0.79,
		"artNr": "e0012",
		"type": "emotes"
	},
	
	{
		"name": "Dirty Itano Money",
		"img": "dirtyitanomoney.png",
		"text": "DirtyItanoMoney",
		"price": 1.09,
		"type": "emotes",
		"dbPos": 13,
		"artNr": "e0013"
	},
	
	{
		"name": "Worker",
		"img": "worker.gif",
		"text": "Worker",
		"playerLvl": 13,
		"artNr": "e0014",
		"type": "emotes",
		"dbPos": 14
	},
	
	{
		"name": "Ballista",
		"img": "ballista.png",
		"text": "Ballista",
		"gold": 1500,
		"artNr": "e0015",
		"type": "emotes",
		"dbPos": 15
	},
	
	{
		"name": "Archer",
		"img": "archer.gif",
		"text": "Archer",
		"gold": 1000,
		"artNr": "e0016",
		"type": "emotes",
		"dbPos": 16
	},
	
	{
		"name": "Rifleman",
		"img": "rifleman.gif",
		"text": "Rifleman",
		"gold": 1500,
		"artNr": "e0017",
		"type": "emotes",
		"dbPos": 17
	},
	
	{
		"name": "Catapult",
		"img": "catapult.png",
		"text": "Catapult",
		"price": 0.79,
		"artNr": "e0018",
		"type": "emotes",
		"dbPos": 18
	},
	
	{
		"name": "Mage",
		"img": "mage.gif",
		"text": "Mage",
		"price": 0.89,
		"artNr": "e0019",
		"type": "emotes",
		"dbPos": 19
	},
	
	{
		"name": "Airship",
		"img": "airship.gif",
		"text": "Airship",
		"playerLvl": 17,
		"artNr": "e0020",
		"type": "emotes",
		"dbPos": 20
	},
	
	{
		"name": "Dragon",
		"img": "dragon.gif",
		"text": "Dragon",
		"playerLvl": 20,
		"artNr": "e0021",
		"type": "emotes",
		"dbPos": 21
	},
	
	{
		"name": "Werewolf",
		"img": "werewolf.gif",
		"text": "Werewolf",
		"gold": 2000,
		"artNr": "e0022",
		"type": "emotes",
		"dbPos": 22
	},
	
	{
		"name": "5th Division",
		"img": "div5.png",
		"text": "Div5",
		"div": 1,
		"type": "emotes",
		"dbPos": 23,
		"artNr": "e0023"
	},
	
	{
		"name": "4th Division",
		"img": "div4.png",
		"text": "Div4",
		"div": 2,
		"type": "emotes",
		"dbPos": 24,
		"artNr": "e0024"
	},
	
	{
		"name": "3rd Division",
		"img": "div3.png",
		"text": "Div3",
		"div": 3,
		"type": "emotes",
		"dbPos": 25,
		"artNr": "e0025"
	},
	
	{
		"name": "2nd Division",
		"img": "div2.png",
		"text": "Div2",
		"div": 4,
		"type": "emotes",
		"dbPos": 26,
		"artNr": "e0026"
	},
	
	{
		"name": "1st Division",
		"img": "div1.png",
		"text": "Div1",
		"div": 5,
		"type": "emotes",
		"dbPos": 27,
		"artNr": "e0027"
	},
	
	{
		"name": "Gamma Division",
		"img": "divgamma.png",
		"text": "DivGamma",
		"div": 6,
		"type": "emotes",
		"dbPos": 30,
		"artNr": "e0030"
	},
	
	{
		"name": "Beta Division",
		"img": "divbeta.png",
		"text": "DivBeta",
		"div": 7,
		"type": "emotes",
		"dbPos": 29,
		"artNr": "e0029"
	},
	
	{
		"name": "Alpha Division",
		"img": "divalpha.png",
		"text": "DivAlpha",
		"div": 8,
		"type": "emotes",
		"dbPos": 28,
		"artNr": "e0028"
	},
	
	{
		"name": "O RLY ?",
		"img": "orly.jpg",
		"text": "Orly",
		"price": 0.79,
		"type": "emotes",
		"dbPos": 31,
		"artNr": "e0031"
	},
	
	{
		"name": "#REKT",
		"img": "rekt.png",
		"text": "#REKT",
		"price": 0.79,
		"type": "emotes",
		"dbPos": 32,
		"artNr": "e0032"
	},
	
	{
		"name": "Star",
		"img": "premium.png",
		"text": "Star",
		"type": "emotes",
		"special": "requires_premium",
		"requirementText": "Requires premium account",
		"requirementTitle": "Get a premium account to unlock this emote",
		"dbPos": 33,
		"artNr": "e0033"
	},
	
	{
		"name": "Not Bad",
		"img": "not-bad.png",
		"text": "notbad",
		"playerLvl": 8,
		"type": "emotes",
		"dbPos": 34,
		"artNr": "e0034"
	},
	
	{
		"name": "XZibit",
		"img": "xzibit.png",
		"text": "xzibit",
		"gold": 800,
		"type": "emotes",
		"dbPos": 35,
		"artNr": "e0035"
	},
	
	{
		"name": "Castle",
		"img": "castle.png",
		"text": "Castle",
		"gold": 1500,
		"type": "emotes",
		"dbPos": 36,
		"artNr": "e0036"
	},
	
	{
		"name": "Barracks",
		"img": "rax.png",
		"text": "Barracks",
		"gold": 1100,
		"type": "emotes",
		"dbPos": 37,
		"artNr": "e0037"
	},
	
	{
		"name": "Tower",
		"img": "tower.png",
		"text": "Tower",
		"gold": 1000,
		"type": "emotes",
		"dbPos": 38,
		"artNr": "e0038"
	},
	
	{
		"name": "House",
		"img": "house.png",
		"text": "House",
		"gold": 900,
		"type": "emotes",
		"dbPos": 39,
		"artNr": "e0039"
	},
	
	{
		"name": "Goldmine",
		"img": "mine.png",
		"text": "Goldmine",
		"gold": 1100,
		"type": "emotes",
		"dbPos": 40,
		"artNr": "e0040"
	},
	
	{
		"name": "Magesguild",
		"img": "guild.png",
		"text": "Guild",
		"gold": 1400,
		"type": "emotes",
		"dbPos": 41,
		"artNr": "e0041"
	},
	
	{
		"name": "Workshop",
		"img": "workshop.png",
		"text": "Workshop",
		"gold": 1400,
		"type": "emotes",
		"dbPos": 42,
		"artNr": "e0042"
	},
	
	{
		"name": "Forge",
		"img": "forge.png",
		"text": "Forge",
		"gold": 1200,
		"type": "emotes",
		"dbPos": 43,
		"artNr": "e0043"
	},
	
	{
		"name": "Fortress",
		"img": "fort.png",
		"text": "Fortress",
		"gold": 1600,
		"type": "emotes",
		"dbPos": 44,
		"artNr": "e0044"
	},
	
	{
		"name": "Dragonslair",
		"img": "dragonslair.png",
		"text": "Lair",
		"gold": 1400,
		"type": "emotes",
		"dbPos": 45,
		"artNr": "e0045"
	},
	
	{
		"name": "Wolvesden",
		"img": "wolfden.png",
		"text": "Wolvesden",
		"gold": 1100,
		"type": "emotes",
		"dbPos": 46,
		"artNr": "e0046"
	},
	
	{
		"name": "Animal Testing Lab",
		"img": "lab.png",
		"text": "Animaltestinglab",
		"gold": 1200,
		"type": "emotes",
		"dbPos": 47,
		"artNr": "e0047"
	},
	
	{
		"name": "Advanced Workshop",
		"img": "adv-workshop.png",
		"text": "Advancedworkshop",
		"gold": 1400,
		"type": "emotes",
		"dbPos": 48,
		"artNr": "e0048"
	},
	
	{
		"name": "Werewolves Den",
		"img": "wwden.png",
		"text": "Werewolvesden",
		"gold": 1800,
		"type": "emotes",
		"dbPos": 49,
		"artNr": "e0049"
	},
	
	{
		"name": "Church",
		"img": "church.png",
		"text": "Church",
		"gold": 1400,
		"type": "emotes",
		"dbPos": 50,
		"artNr": "e0050"
	},
	
	{
		"name": "Basketball",
		"img": "basketball.png",
		"gold": 1500,
		"text": "Basketball",
		"type": "emotes",
		"dbPos": 51,
		"artNr": "e0051"
	},
	
	{
		"name": "Frog",
		"img": "frog.png",
		"playerLvl": 26,
		"text": "Frog",
		"type": "emotes",
		"dbPos": 52,
		"artNr": "e0052"
	},
	
	{
		"name": "Machinegun",
		"img": "machinegun.png",
		"special": "requires_premium",
		"requirementText": "Requires premium account",
		"requirementTitle": "Get a premium account to unlock this emote",
		"text": "Machinegun",
		"type": "emotes",
		"dbPos": 53,
		"artNr": "e0053"
	},
	
	{
		"name": "Cookie",
		"img": "cookie.png",
		"special": "requires_premium",
		"requirementText": "Requires premium account",
		"requirementTitle": "Get a premium account to unlock this emote",
		"text": "Cookie",
		"type": "emotes",
		"dbPos": 54,
		"artNr": "e0054"
	}

	// {
	// 	"name": "pumpkin",
	// 	"img": "pumpkin.png",
	// 	"free": true,
	// 	"text": "pumpkin",
	// 	"type": "emotes"
	// },
	
	// {
	// 	"name": "spookyhead",
	// 	"img": "pumpkin_soldier.png",
	// 	"free": true,
	// 	"text": "spookyhead",
	// 	"type": "emotes"
	// },
	
	// {
	// 	"name": "skeleton",
	// 	"img": "skeleton.png",
	// 	"free": true,
	// 	"text": "skeleton",
	// 	"type": "emotes"
	// }
	
]/*emotesend*/;

var skins = /*skinsstart*/
[
	
	{
		"name": "Redhead Worker",
		"img": "workerS1",
		"unit_id_string": "worker",
		"dbPos": 1,
		"gold": 2000,
		"artNr": "s0001",
		"type": "skins"
	},
	
	{
		"name": "Blonde Worker",
		"img": "workerS2",
		"unit_id_string": "worker",
		"dbPos": 2,
		"gold": 2000,
		"artNr": "s0002",
		"type": "skins"
	},
	
	{
		"name": "Soldier 2",
		"img": "soldierS1",
		"unit_id_string": "soldier",
		"dbPos": 3,
		"price": 1.39,
		"artNr": "s0003",
		"type": "skins"
	},
	
	{
		"name": "Viking Archer",
		"img": "archerS1",
		"unit_id_string": "archer",
		"dbPos": 4,
		"playerLvl": 14,
		"artNr": "s0004",
		"type": "skins"
	},
	
	{
		"name": "Soldier 3",
		"img": "soldierS2",
		"unit_id_string": "soldier",
		"dbPos": 5,
		"price": 1.39,
		"artNr": "s0005",
		"type": "skins"
	},
	
	{
		"name": "British Mage",
		"img": "mageS1",
		"unit_id_string": "mage",
		"dbPos": 6,
		"price": 1.19,
		"artNr": "s0006",
		"type": "skins"
	},
	
	{
		"name": "Christmas Worker",
		"img": "worker_christmas",
		"unit_id_string": "worker",
		// "dbPos": 7,
		"free": true,
		"artNr": "s0007",
		"type": "skins"
	}
	
]/*skinsend*/;

var dances = /*dancesstart*/
[
	
	{
		"name": "Worker 01",
		"unit_id_string": "worker",
		"dbPos": 1,
		"artNr": "d0001",
		"animName": "dance1",
		"price": 0.99,
		"type": "dances",
		"chat_str": "/dance",
		"img": "worker"
	},
	
	{
		"name": "Soldier 01",
		"unit_id_string": "soldier",
		"dbPos": 2,
		"gold": 1500,
		"artNr": "d0002",
		"animName": "dance1",
		"type": "dances",
		"chat_str": "/dance",
		"img": "soldier"
	},
	
	{
		"name": "Soldier 02",
		"unit_id_string": "soldier",
		"dbPos": 3,
		"price": 0.99,
		"artNr": "d0003",
		"animName": "dance2",
		"type": "dances",
		"chat_str": "/dance2",
		"img": "soldier"
	}
	
]/*dancesend*/;

var achivements = /*achivementsstart*/
[
	
	{
		"name": "The First Step",
		"a_type": "ladderwins",
		"type": "achivements",
		"text": "Win 1 ladder game",
		"count": 1,
		"dbPos": 1,
		"reward": 10,
		"img": "ladderwins1.png"
	},
	
	{
		"name": "Ranked Up!",
		"a_type": "ladderwins",
		"type": "achivements",
		"text": "Win 5 ladder games",
		"count": 5,
		"dbPos": 2,
		"reward": 20,
		"img": "ladderwins5.png"
	},
	
	{
		"name": "Ladder Hiker",
		"a_type": "ladderwins",
		"type": "achivements",
		"text": "Win 10 ladder games",
		"count": 10,
		"dbPos": 3,
		"reward": 35,
		"img": "ladderwins10.png"
	},
	
	{
		"name": "Matchmaking Battler",
		"a_type": "ladderwins",
		"type": "achivements",
		"text": "Win 20 ladder games",
		"count": 20,
		"dbPos": 4,
		"reward": 70,
		"img": "ladderwins20.png"
	},
	
	{
		"name": "The Steep Climb",
		"a_type": "ladderwins",
		"type": "achivements",
		"text": "Win 50 ladder games",
		"count": 50,
		"dbPos": 5,
		"reward": 150,
		"img": "ladderwins50.png"
	},
	
	{
		"name": "Contender",
		"a_type": "ladderwins",
		"type": "achivements",
		"text": "Win 100 ladder games",
		"count": 100,
		"dbPos": 6,
		"reward": 250,
		"img": "ladderwins100.png"
	},
	
	{
		"name": "Matchmaking Maestro",
		"a_type": "ladderwins",
		"type": "achivements",
		"text": "Win 200 ladder games",
		"count": 200,
		"dbPos": 7,
		"reward": 450,
		"img": "ladderwins200.png"
	},
	
	{
		"name": "Ladder Hero",
		"a_type": "ladderwins",
		"type": "achivements",
		"text": "Win 500 ladder games",
		"count": 500,
		"dbPos": 8,
		"reward": 1000,
		"img": "ladderwins500.png"
	},
	
	{
		"name": "Chief Of Ladder",
		"a_type": "ladderwins",
		"type": "achivements",
		"text": "Win 1000 ladder games",
		"count": 1000,
		"dbPos": 9,
		"reward": 1700,
		"img": "ladderwins1000.png"
	},
	
	{
		"name": "Ladder King",
		"a_type": "ladderwins",
		"type": "achivements",
		"text": "Win 2000 ladder games",
		"count": 2000,
		"dbPos": 10,
		"reward": 3000,
		"img": "ladderwins2000.png"
	},
	
	{
		"name": "Ladder Boss",
		"a_type": "ladderwins",
		"type": "achivements",
		"text": "Win 5000 ladder games",
		"count": 5000,
		"dbPos": 11,
		"reward": 5000,
		"img": "ladderwins5000.png"
	},
	
	{
		"name": "Ladder God",
		"a_type": "ladderwins",
		"type": "achivements",
		"text": "Win 10000 ladder games",
		"count": 10000,
		"dbPos": 12,
		"reward": 10000,
		"img": "ladderwins10000.png"
	},
	
	// laddergames
	
	{
		"name": "Ladder Player",
		"a_type": "laddergames",
		"type": "achivements",
		"text": "Play 5 ladder games",
		"count": 5,
		"dbPos": 13,
		"reward": 25,
		"img": "laddergames5.png"
	},
	
	{
		"name": "Ladder Rookie",
		"a_type": "laddergames",
		"type": "achivements",
		"text": "Play 10 ladder games",
		"count": 10,
		"dbPos": 14,
		"reward": 40,
		"img": "laddergames10.png"
	},
	
	{
		"name": "Better Ladder Player",
		"a_type": "laddergames",
		"type": "achivements",
		"text": "Play 20 ladder games",
		"count": 20,
		"dbPos": 15,
		"reward": 70,
		"img": "laddergames20.png"
	},
	
	{
		"name": "Experienced Matchmaker",
		"a_type": "laddergames",
		"type": "achivements",
		"text": "Play 50 ladder games",
		"count": 50,
		"dbPos": 16,
		"reward": 150,
		"img": "laddergames50.png"
	},
	
	{
		"name": "Ladder Champ",
		"a_type": "laddergames",
		"type": "achivements",
		"text": "Play 100 ladder games",
		"count": 100,
		"dbPos": 17,
		"reward": 250,
		"img": "laddergames100.png"
	},
	
	{
		"name": "Durable Fighter",
		"a_type": "laddergames",
		"type": "achivements",
		"text": "Play 200 ladder games",
		"count": 200,
		"dbPos": 18,
		"reward": 450,
		"img": "laddergames200.png"
	},
	
	{
		"name": "Competitive Spirit",
		"a_type": "laddergames",
		"type": "achivements",
		"text": "Play 500 ladder games",
		"count": 500,
		"dbPos": 19,
		"reward": 1000,
		"img": "laddergames500.png"
	},
	
	{
		"name": "One Grand",
		"a_type": "laddergames",
		"type": "achivements",
		"text": "Play 1000 ladder games",
		"count": 1000,
		"dbPos": 20,
		"reward": 1750,
		"img": "laddergames1000.png"
	},
	
	{
		"name": "Unstoppable",
		"a_type": "laddergames",
		"type": "achivements",
		"text": "Play 2000 ladder games",
		"count": 2000,
		"dbPos": 21,
		"reward": 3000,
		"img": "laddergames2000.png"
	},
	
	{
		"name": "Matchmaking Specialist",
		"a_type": "laddergames",
		"type": "achivements",
		"text": "Play 5000 ladder games",
		"count": 5000,
		"dbPos": 22,
		"reward": 5000,
		"img": "laddergames5000.png"
	},
	
	{
		"name": "Ladder Warrior",
		"a_type": "laddergames",
		"type": "achivements",
		"text": "Play 10000 ladder games",
		"count": 10000,
		"dbPos": 23,
		"reward": 10000,
		"img": "laddergames10000.png"
	},
	
	// games
	
	{
		"name": "Beginner",
		"a_type": "games",
		"type": "achivements",
		"text": "Play 5 multiplayer games",
		"count": 5,
		"dbPos": 24,
		"reward": 25,
		"img": "games5.png"
	},
	
	{
		"name": "One Step Further",
		"a_type": "games",
		"type": "achivements",
		"text": "Play 10 multiplayer games",
		"count": 10,
		"dbPos": 25,
		"reward": 40,
		"img": "games10.png"
	},
	
	{
		"name": "Fighter",
		"a_type": "games",
		"type": "achivements",
		"text": "Play 20 multiplayer games",
		"count": 20,
		"dbPos": 26,
		"reward": 70,
		"img": "games20.png"
	},
	
	{
		"name": "Soldier",
		"a_type": "games",
		"type": "achivements",
		"text": "Play 50 multiplayer games",
		"count": 50,
		"dbPos": 27,
		"reward": 150,
		"img": "games50.png"
	},
	
	{
		"name": "Experienced Player",
		"a_type": "games",
		"type": "achivements",
		"text": "Play 100 multiplayer games",
		"count": 100,
		"dbPos": 28,
		"reward": 250,
		"img": "games100.png"
	},
	
	{
		"name": "Littlewargame Expert",
		"a_type": "games",
		"type": "achivements",
		"text": "Play 200 multiplayer games",
		"count": 200,
		"dbPos": 29,
		"reward": 450,
		"img": "games200.png"
	},
	
	{
		"name": "Littlewargame Specialist",
		"a_type": "games",
		"type": "achivements",
		"text": "Play 500 multiplayer games",
		"count": 500,
		"dbPos": 30,
		"reward": 1000,
		"img": "games500.png"
	},
	
	{
		"name": "Master Of Littlewargame",
		"a_type": "games",
		"type": "achivements",
		"text": "Play 1000 multiplayer games",
		"count": 1000,
		"dbPos": 31,
		"reward": 1750,
		"img": "games1000.png"
	},
	
	{
		"name": "Living Legend",
		"a_type": "games",
		"type": "achivements",
		"text": "Play 2000 multiplayer games",
		"count": 2000,
		"dbPos": 32,
		"reward": 3000,
		"img": "games2000.png"
	},
	
	{
		"name": "Based God",
		"a_type": "games",
		"type": "achivements",
		"text": "Play 5000 multiplayer games",
		"count": 5000,
		"dbPos": 33,
		"reward": 5000,
		"img": "games5000.png"
	},
	
	{
		"name": "It's Over 9000!!!",
		"a_type": "games",
		"type": "achivements",
		"text": "Play over 9000 multiplayer games",
		"count": 9001,
		"dbPos": 34,
		"reward": 10000,
		"img": "games9001.png"
	},
	
	{
		"name": "Holiday Spirit",
		"a_type": "games",
		"type": "achivements",
		"text": "Play a game during the christmas event",
		"expires": 1580564544072, // New year's day
		"count": 1,
		"dbPos": 35,
		"img": "christmas.png"
	}
	
]/*achivementsend*/;

var goldPacks = /*goldstart*/
[
	
	{
		"name": "Gold Pack 1000",
		"artNr": "g0001",
		"type": "gold",
		"price": 0.99,
		"reward": 1000
	},
	
	{
		"name": "Gold Pack 2000",
		"artNr": "g0002",
		"type": "gold",
		"price": 1.89,
		"reward": 2000
	},
	
	{
		"name": "Gold Pack 5000",
		"artNr": "g0003",
		"type": "gold",
		"price": 3.99,
		"reward": 5000
	},
	
	{
		"name": "Gold Pack 10000",
		"artNr": "g0004",
		"type": "gold",
		"price": 7.49,
		"reward": 10000
	}
	
]/*goldend*/;

var specials = /*specialsstart*/
[
	
	{
		"name": "Premium Account",
		"artNr": "x0001",
		"type": "special",
		"type_2": "premium",
		"dbPos": 1,
		"gold": 3500,
		"img": "premium.png"
	},
	
	{
		"name": "Treasure Chest",
		"artNr": "x0002",
		"type": "special",
		"type_2": "treasure",
		"dbPos": 2,
		"gold": 1000,
		"img": "chest.png"
	}
	
]/*specialsend*/;


if(typeof exports !== 'undefined')
{
	exports.emotes = emotes;
	exports.skins = skins;
	exports.dances = dances;
	exports.achivements = achivements;
	exports.goldPacks = goldPacks;
	exports.specials = specials;
}
var _emotes2 = /*emotesstart*/
[
	
	{
		"name": "Teddy",
		"img": "teddy.png",
		"text": "Teddy",
		"type": "emotes",
		"hidd": true,
		"dbPos": 55,
		"artNr": "e0055"
	},
	
	{
		"name": "Minigun",
		"img": "minigun.png",
		"text": "Minigun",
		"type": "emotes",
		"hidd": true,
		"dbPos": 56,
		"artNr": "e0056"
	},
	
	{
		"name": "Cheese",
		"img": "cheese.png",
		"text": "Cheese",
		"type": "emotes",
		"hidd": true,
		"dbPos": 57,
		"artNr": "e0057"
	},
	
	{
		"name": "Violin",
		"img": "violin.png",
		"text": "Violin",
		"type": "emotes",
		"hidd": true,
		"dbPos": 58,
		"artNr": "e0058"
	}
	
]/*emotesend*/;

if(typeof exports !== 'undefined')
{
	exports.emotes = _emotes2;
}
// canvas
var canvas = document.getElementById('canvas');
var c = canvas.getContext("2d");
var originalC = c;

// dummy canvas
var canvas2 = document.createElement('canvas');
var c2 = canvas2.getContext("2d");

var WIDTH = window.innerWidth;
var HEIGHT = window.innerHeight;
var SCROLL_RANGE = 10;					// in which distance to the border the cursor starts scrolling
var SCALE_FACTOR = getCookieValue(document.cookie, "scale_factor");
if(!SCALE_FACTOR)
	SCALE_FACTOR = 3;
SCALE_FACTOR = Math.min(SCALE_FACTOR, 10);
SCALE_FACTOR = Math.max(SCALE_FACTOR, 2);
var FIELD_SIZE = 16 * SCALE_FACTOR;
var INTERFACE_HEIGHT = 176;
var MINIMAP_WIDTH = 192;
var MINIMAP_HEIGHT = 192;
var Y_OFFSET = 1 / 8;
var CLICK_TOLERANCE = 0.25;				// click tolerance when selecting a unit, in fields
var TICKS_DELAY = 6;					// delay in multiplayer game. Too low delay can lead to slow running game if connection is bad; is dynamically changed while playing
var MAX_DELAY = 20;
var MIN_DELAY = 2;
var PLAYING_PLAYER = null;
var DEAD_MAP_SPACE = 36;

//var SERVER_ADRESS = "ws://jbs.hercules.uberspace.de:64978";
//var SERVER_ADRESS = "wss://108.61.78.37:443";
var SERVER_ADRESS = "wss://us1.littlewargame.com:8083";
// var SERVER_ADRESS = "wss://us1-dev.littlewargame.com:8083";

var IS_LOGIC = false;
var MIN_MAP_SIZE = 24;
var COMMAND_BUTTON_SIZE = 72;
var INTERFACE_UNIT_IMG_SIZE = 100; // px
var GAME_VERSION = 4.2;

// Global Variables
var timestamp = Date.now();
var timeDiff = 0;
var gameTimeDiff = 0;
var timeOfLastUpdate = 0;
var show_fps = false;
var timestampArchives = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
var show_unit_details = false;
var fps = 0;
var ticksCounter = 0;
var percentageOfCurrentTickPassed = 0;
var game_paused = false;
var newTime = 0;
var tickDiff = 0;
var lastFramesTick = 0;
var fileInput = "";
var replayFile = "";
var countCustomAIFunctions = 0;
var replaySpeedIndex = 1;
var currentMapImg = null;
var tickTimes = [0, 0, 0, 0, 0];
var iAmMod = false;
var iAmMod2 = false;
var iAmAdmin = false;
var premium_until = false;
var clan = null;
var createdMulti = false;
var mapData = null;
var league = -1;
var lastSentTick = -1;
var ignores = [];
var exp = 0;
var sentActivationCode = false;
var storedAchivements = [];
var xpNfo = "";
var npf = "This anonymous survey gives you some free gold.";
var lcg = {};
var lcg_interval = null;
var globalSoundModifier = 1;
var path2Print = null;
var printPathUntil = 0;
var addFriendButton = false;
var srvState = "";
var tileImgs = {};

// network variables
var network_game = false;
var ladder_game = false;
var incomingOrders = {};
var outgoingOrders = {};
var playerLefts = {};
var ressourcesToLoad = 1;
var timeOfLastPingSent = 0;

// strings
var goldDescription = "Gold can be used to buy and unlock new features like emoticons or custom skins. You can buy it or get it from achievements or levelling up.";

var keyNames = [];

keyNames[9] = "TAB";

keyNames[16] = "SHIFT";
keyNames[17] = "STRG";
keyNames[18] = "ALT";

keyNames[19] = "PAUSE";
keyNames[20] = "CAPSLOCK";
keyNames[32] = "SPACE";

keyNames[37] = "LEFT";
keyNames[38] = "UP";
keyNames[39] = "RIGHT";
keyNames[40] = "DOWN";

keyNames[46] = "DEL";

keyNames[48] = "0";
keyNames[49] = "1";
keyNames[50] = "2";
keyNames[51] = "3";
keyNames[52] = "4";
keyNames[53] = "5";
keyNames[54] = "6";
keyNames[55] = "7";
keyNames[56] = "8";
keyNames[57] = "9";

keyNames[8] = "BACKSPACE";
keyNames[13] = "ENTER";
keyNames[27] = "ESC";

keyNames[65] = "A";
keyNames[66] = "B";
keyNames[67] = "C";
keyNames[68] = "D";
keyNames[69] = "E";
keyNames[70] = "F";
keyNames[71] = "G";
keyNames[72] = "H";
keyNames[73] = "I";
keyNames[74] = "J";
keyNames[75] = "K";
keyNames[76] = "L";
keyNames[77] = "M";
keyNames[78] = "N";
keyNames[79] = "O";
keyNames[80] = "P";
keyNames[81] = "Q";
keyNames[82] = "R";
keyNames[83] = "S";
keyNames[84] = "T";
keyNames[85] = "U";
keyNames[86] = "V";
keyNames[87] = "W";
keyNames[88] = "X";
keyNames[89] = "Y";
keyNames[90] = "Z";

keyNames[112] = "F1";
keyNames[113] = "F2";
keyNames[114] = "F3";
keyNames[115] = "F4";
keyNames[116] = "F5";
keyNames[117] = "F6";
keyNames[118] = "F7";
keyNames[119] = "F8";
keyNames[120] = "F9";
keyNames[121] = "F10";

keyNames[192] = "`";

keyNames[window.chrome ? 220 : 160] = "^"; // FF


function getKeyName(key)
{
	return keyNames[key] ? keyNames[key] : "";
}

function getKeyFromStr(str)
{
	for(var i = 0; i < keyNames.length; i++)
		if(keyNames[i] == str)
			return i;
	
	return 0;
}

function getCookieValue(cookie, index)
{
	if(!cookie)
		return "";
	
	var return_value = "";
	
	var c_start = cookie.indexOf(" " + index + "=");
	
	if(c_start == -1)
		c_start = cookie.indexOf(index + "=");
	 
	if(c_start == -1)
		return "";
	 
	else
	{
		c_start = cookie.indexOf("=", c_start) + 1;
		var c_end = cookie.indexOf(";", c_start);
		if(c_end == -1)
			c_end = cookie.length;
		
		return_value = unescape(cookie.substring(c_start, c_end));
	}
	
	return return_value;
}

var KEY = Object.freeze({
	UP: 38,
	DOWN: 40,
	LEFT: 37,
	RIGHT: 39,
	A: 65,
	B: 66,
	C: 67,
	D: 68,
	E: 69,
	F: 70,
	G: 71,
	H: 72,
	I: 73,
	J: 74,
	K: 75,
	L: 76,
	M: 77,
	N: 78,
	O: 79,
	P: 80,
	Q: 81,
	R: 82,
	S: 83,
	T: 84,
	U: 85,
	V: 86,
	W: 87,
	X: 88,
	Y: 89,
	Z: 90,
	SHIFT: 16,
	STRG: 17,
	ALT: 18,
	NUM1: 49,
	NUM2: 50,
	NUM3: 51,
	NUM4: 52,
	NUM5: 53,
	NUM6: 54,
	NUM7: 55,
	NUM8: 56,
	NUM9: 57,
	NUM0: 48,
	CIRCUMFLEX: window.chrome ? 220 : 160,
	ENTER: 13,
	BACKSPACE: 8,
	DELETE: 46,
	PAUSE: 19,
	F1: 112,
	F2: 113,
	F3: 114,
	F4: 115,
	F5: 116,
	F6: 117,
	F7: 118,
	F8: 119,
	F9: 120,
	F10: 121,
	ESC: 27,
	TAB: 9,
	PLUS: 107,
	MINUS: 109,
	SPACE: 32,
	CAPSLOCK: 20,
	AE: 192
});

function resetHotkeys()
{
	setObsKeysDefault();
	setDefaultCtrlGrpKeys();
	setDefaultCamKeys();
	setOtherKeysDefault();
	
	// commands
	for(var i = 0; i < basicCommands.length; i++)
		basicCommands[i].hotkey = basicCommands[i].originalHotkey;
	
	// ingame stuff
	if(game)
		for(var i = 0; i < game.commands.length; i++)
			game.commands[i].hotkey = game.commands[i].originalHotkey;
	
	initHotkeyWindow();
	
	writeCookie();
}

// other hotkeys
var otherKeys = null;
function setOtherKeysDefault()
{
	otherKeys = [
		KEY.O,
		KEY.L,
		KEY.K
	];
}
setOtherKeysDefault();

var otherKeyNames = [
	"Zoom in",
	"Zoom out",
	"Map Ping"
];

var otherKeyStr = getCookieValue(document.cookie, "otherkeys").split("#");
for(var i = 0; i < otherKeyStr.length; i++)
	if(otherKeyStr[i].length > 0)
		otherKeys[i] = otherKeyStr[i];


// obs hotkeys
var obsKeys = null;
function setObsKeysDefault()
{
	obsKeys = [
		KEY.NUM0,
		KEY.Q,
		KEY.W,
		KEY.E,
		KEY.R,
		KEY.T,
		KEY.Z,
		KEY.U
	];
}
setObsKeysDefault();

var obsAbilityNames = [
	"Set vision all",
	"Units",
	"Buildings",
	"Upgrades",
	"Production",
	"Income",
	"APM",
	"Units lost"
];

var obsKeyStr = getCookieValue(document.cookie, "obskeys").split("#");
for(var i = 0; i < obsKeyStr.length; i++)
	if(obsKeyStr[i].length > 0)
		obsKeys[i] = obsKeyStr[i];


// control group keys array; array index = code of key, value = control group nr
var ctrlGroupKeys = null;
function setDefaultCtrlGrpKeys()
{
	ctrlGroupKeys = new Array(250);
	for(var i = 1; i <= 9; i++)
		ctrlGroupKeys[KEY["NUM" + i]] = i;
	ctrlGroupKeys[KEY.CIRCUMFLEX] = 10;
}
setDefaultCtrlGrpKeys();

function getKeyForCtrlGrp(nr)
{
	for(var i = 0; i < ctrlGroupKeys.length; i++)
		if(ctrlGroupKeys[i] == nr)
			return i;
	return 0;
}

// set custom ctrl grp hotkeys from cookie
var hotkeyStr = getCookieValue(document.cookie, "ctrlgrp").split("#");
for(var i = 0; i < hotkeyStr.length; i++)
{
	var arr = hotkeyStr[i].split(":");
	
	if(arr[1] && arr[1] < ctrlGroupKeys.length)
	{
		// free old key
		var nr = getKeyForCtrlGrp(arr[0]);
		if(nr)
			ctrlGroupKeys[nr] = 0;
		
		ctrlGroupKeys[arr[1]] = arr[0];
	}
}

// camera hotkeys array; array index = code of key, value = camera pos
var cameraHotkeys = null;
function setDefaultCamKeys()
{
	cameraHotkeys = new Array(250);
	for(var i = 1; i <= 6; i++)
		cameraHotkeys[KEY["F" + i]] = i;
}
setDefaultCamKeys();

function getKeyForCamHotkey(nr)
{
	for(var i = 0; i < cameraHotkeys.length; i++)
		if(cameraHotkeys[i] == nr)
			return i;
	return 0;
}

// set location hotkeys from cookie
hotkeyStr = getCookieValue(document.cookie, "camkey").split("#");
for(var i = 0; i < hotkeyStr.length; i++)
{
	var arr = hotkeyStr[i].split(":");
	
	if(arr[1] && arr[1] < cameraHotkeys.length)
	{
		// free old key
		var nr = getKeyForCamHotkey(arr[0]);
		if(nr)
			cameraHotkeys[nr] = 0;
		
		cameraHotkeys[arr[1]] = arr[0];
	}
}


// League Names
var leagueNames = [
	"5th Division",
	"4th Division",
	"3rd Division",
	"2nd Division",
	"1st Division",
	"Gamma Division",
	"Beta Division",
	"Alpha Division"
];



var imgs = {
	
	dust1: {x: 155, y: 0, w: 7, h: 7},
	dust2: {x: 155, y: 7, w: 7, h: 7},
	
	particle: {x: 155, y: 14, w: 1, h: 1},
	hammer: {x: 278, y: 0, w: 22, h: 22},
	research: {x: 145, y: 44, w: 17, h: 17},
	attentionmark: {x: 32, y: 0, w: 19, h: 18},
	attentionmarkYellow: {x: 51, y: 0, w: 19, h: 18},
	underAttack: {x: 201, y: 102, w: 18, h: 20},
	stop: {x: 3, y: 141, w: 26, h: 30},
	holdposition: {x: 109, y: 92, w: 32, h: 32},
	attack: {x: 2, y: 3, w: 27, h: 27},
	cancel: {x: 139, y: 0, w: 16, h: 16},
	flamestrike: {x: 101, y: 69, w: 32, h: 23},
	heal: {x: 73, y: 80, w: 18, h: 19},
	button: {x: 70, y: 0, w: 69, h: 69},
	button2: {x: 0, y: 69, w: 69, h: 69},
	soot: {x: 141, y: 80, w: 60, h: 60},
	attackUpg: {x: 31, y: 146, w: 24, h: 24},
	armorUpg: {x: 55, y: 146, w: 24, h: 24},
	interfaceLeft: {x: 0, y: 202, w: 260, h: 29},
	interfaceRight: {x: 0, y: 172, w: 260, h: 29},
	interfaceMapBorder: {x: 0, y: 321, w: 108, h: 109},
	interfaceButtonDiv: {x: 0, y: 232, w: 205, h: 88},
	interfaceUnitInfo: {x: 0, y: 431, w: 293, h: 76},
	dragonAttUpg: {x: 103, y: 146, w: 24, h: 24},
	dragonDefUpg: {x: 128, y: 146, w: 24, h: 24},
	towerUpg: {x: 269, y: 35, w: 32, h: 32},
	unload: {x: 268, y: 108, w: 32, h: 32},
	load: {x: 268, y: 71, w: 32, h: 32},
	repair: {x: 139, y: 16, w: 23, h: 23},
	groundAttack: {x: 229, y: 32, w: 32, h: 32},
	smash: {x: 184, y: 153, w: 16, h: 16},
	speedUpg: {x: 79, y: 146, w: 24, h: 24},
	beastSpeedUpg: {x: 155, y: 146, w: 24, h: 24},
	mechAttUpg: {x: 207, y: 146, w: 24, h: 24},
	mechDefUpg: {x: 232, y: 146, w: 24, h: 24},
	mechSpeedUpg: {x: 257, y: 146, w: 24, h: 24},
	flakUpg: {x: 238, y: 121, w: 24, h: 24},
	lightGround: {x: 187, y: 62, w: 29, h: 26},
	soot2: {x: 221, y: 70, w: 34, h: 32},
	shockwave: {x: 209, y: 234, w: 24, h: 24},
	gold: {x: 261, y: 172, w: 20, h: 19},
	supply: {x: 284, y: 172, w: 11, h: 19},
	beastRangeUpg: {x: 210, y: 260, w: 23, h: 21},
	rangeUpg: {x: 210, y: 284, w: 23, h: 21},
	mechRangeUpg: {x: 237, y: 235, w: 25, h: 22},
	invisibility: {x: 73, y: 123, w: 19, h: 21},
	telescope: {x: 237, y: 259, w: 17, h: 21},
	eye: {x: 266, y: 195, w: 11, h: 9},
	slowfield: {x: 282, y: 195, w: 18, h: 12},
	leaf: {x: 280, y: 208, w: 20, h: 20},
	cake: {x: 279, y: 233, w: 21, h: 22},
	book: {x: 259, y: 259, w: 17, h: 21},
	tree: {x: 280, y: 258, w: 20, h: 22},
	back: {x: 236, y: 283, w: 19, h: 22},
	bow: {x: 258, y: 283, w: 20, h: 20},
	spell_1: {x: 282, y: 284, w: 16, h: 20},
	spell_2: {x: 110, y: 382, w: 22, h: 22},
	gun: {x: 135, y: 382, w: 21, h: 24},
	teleport: {x: 159, y: 382, w: 23, h: 22},
	whitePixel: {x: 74, y: 112, w: 1, h: 1},
	
	fire1: {x: 69, y: 73, w: 3, h: 3},
	fire2: {x: 73, y: 72, w: 4, h: 4},
	fire3: {x: 78, y: 71, w: 5, h: 5},
	fire4: {x: 84, y: 70, w: 7, h: 7},
	fire5: {x: 91, y: 69, w: 9, h: 9},
	
	heal1: {x: 74, y: 103, w: 1, h: 1},
	heal2: {x: 76, y: 103, w: 1, h: 1},
	heal3: {x: 78, y: 103, w: 1, h: 1},
	heal4: {x: 80, y: 103, w: 3, h: 3},
	
	mageAttack1: {x: 133, y: 70, w: 2, h: 2},
	mageAttack2: {x: 137, y: 70, w: 2, h: 2},
	mageAttack3: {x: 141, y: 70, w: 4, h: 4},
	mageAttack4: {x: 146, y: 70, w: 4, h: 4},
	
	flyingRock1: {x: 0, y: 31, w: 9, h: 8},
	flyingRock2: {x: 9, y: 31, w: 9, h: 9},
	flyingRock3: {x: 18, y: 31, w: 8, h: 8},
	flyingRock4: {x: 26, y: 31, w: 8, h: 9},
	flyingRock5: {x: 34, y: 31, w: 8, h: 8},
	flyingRock6: {x: 42, y: 31, w: 9, h: 9},
	flyingRock7: {x: 51, y: 31, w: 9, h: 8},
	flyingRock8: {x: 60, y: 31, w: 9, h: 9}
	
};

var arrowImg = {
	s: [
		{x: 74, y: 1065, w: 10, h: 12},
		{x: 74, y: 1089, w: 10, h: 19}
	],
	
	w: [
		{x: 87, y: 1063, w: 25, h: 15},
		{x: 86, y: 1092, w: 26, h: 9}
	],
	
	e: [
		{x: 116, y: 1063, w: 25, h: 15},
		{x: 116, y: 1092, w: 26, h: 9}
	],
	
	n: [
		{x: 145, y: 1055, w: 8, h: 26},
		{x: 145, y: 1086, w: 8, h: 20}
	],
	
	sw: [
		{x: 159, y: 1065, w: 25, h: 10},
		{x: 160, y: 1086, w: 21, h: 20}
	],
	
	se: [
		{x: 190, y: 1065, w: 25, h: 10},
		{x: 194, y: 1086, w: 21, h: 20}
	],
	
	nw: [
		{x: 218, y: 1061, w: 16, h: 21},
		{x: 217, y: 1091, w: 21, h: 20}
	],
	
	ne: [
		{x: 240, y: 2061, w: 16, h: 21},
		{x: 239, y: 1091, w: 21, h: 20}
	]
};

var lists = {
	types: {},
	imgs: {none: null},
	upgrades: {none: null},
	unitTypes: {none: null},
	buildingTypes: {none: null},
	buildingsUpgrades: {},
	modifiers: {},
	commands: {}
};
function Player(name, controller, number, team, aiRandomizer, custom_ai_index, no_ai_update, clan, skins_)
{
	this.name = name;
	this.controller = controller; // Human, remote, cpu, none
	this.gold = game ? game.globalVars.startGold : START_GOLD;
	this.number = number;
	this.supply = 0; // current supply
	this.lastAttackMessage = 0; // for ai
	this.team = game ? (game.teams[team] ? game.teams[team] : game.teams[0]) : null;
	this.originalTeam = this.team; // gotta be stored, cuz when the game ends, the team of a player changes to 0 (so he gets full vision), but then when the replay is saved, the team needs to be his original team in the replay file
	this.custom_ai_index = -1;
	this.aiUpdate = !no_ai_update ? true : false;
	this.clan = clan; // clan name
	this.isRevealed = false;
	this.isAlive = true;
	
	// global game variables (supply, tech requirements, ...)
	this.maxSupply = 0;
	this.buildings = {}; // format: {id_string: count}
	this.buildingsUC = {}; // (under construction) format: {id_string: count}
	this.pseudoBuildings = {}; // format: {id_string: count}
	this.upgrades = {}; // format: {id_string: level}
	this.units = {}; // format: {id_string: count}
	this.production = {}; // format: {id_string: {count: count, from: startTick, to: finishTick}};
	this.upgradeMods = {}; // all modified fields from upgrades (format: {fieldName: mod} (for example {dmg: 2} for +2 dmg))
	
	// statistics
	this.unitKills = 0;
	this.unitDeaths = 0;
	this.buildingKills = 0;
	this.buildingDeaths = 0;
	this.apm = 0;
	this.minedGold = 0;
	this.minedGoldAtTicks = [0];
	this.currentMinedGold = 0;
	this.unspentGold = 0;
	this.goldLost = 0;
	
	this.lostUnitTypes = {};
	
	// randomize AI; if randomizer number was passd use that to choose the strategy
	if(this.controller == CONTROLLER.COMPUTER);
	{
		this.randomAI = aiRandomizer ? Math.floor(aiRandomizer + number) % 4 : Math.floor(Math.random() * 3);
		this.custom_ai_index = custom_ai_index;
	}
	
	// skins n dances
	try{ skins_ = JSON.parse(skins_); }catch(e){}
	if(skins_)
		_.each(skins_, function(val, key){
			for(var i = 0; i < skins.length; i++)
				if(val == skins[i].artNr)
					skins_[key] = unit_imgs[skins[i].img] ? unit_imgs[skins[i].img] : null;
		});
	this.skins = skins_;
};

Player.prototype.getColor = function()
{
	var arr = playerTextColors[this.number] ? playerTextColors[this.number] : playerTextColors[0];
	return "rgb(" + arr[0] + ", " + arr[1] + ", " + arr[2] + ")";
};

Player.prototype.mineGold = function(amount)
{
	this.minedGold += amount;
	this.minedGoldAtTicks[0] += amount;
};

Player.prototype.killProduction = function(type, finishTick)
{
	if(!this.production[type.id_string])
		return;
	
	if(this.production[type.id_string].to.length <= 1)
	{
		delete this.production[type.id_string];
		return;
	}
	
	for(var i = 0; i < this.production[type.id_string].to.length; i++)
		if(this.production[type.id_string].to[i] == finishTick)
		{
			this.production[type.id_string].to.splice(i, 1);
			
			if(this.production[type.id_string].from)
				this.production[type.id_string].from.splice(i, 1);
			
			return;
		}
};

Player.prototype.startProduction = function(type, finishTick)
{
	if(!this.production[type.id_string])
		this.production[type.id_string] = finishTick.type ? {to: [finishTick]} : {from: [ticksCounter], to: [finishTick]};
	
	else
	{
		if(finishTick.type)
			this.production[type.id_string].to.push(finishTick);
		
		else
		{
			this.production[type.id_string].from.push(ticksCounter);
			this.production[type.id_string].to.push(finishTick);
		}
	}
};

Player.prototype.unitDies = function(u)
{
	this.goldLost += u.type.cost;
	
	if(!u.type.isUnit)
		return;
	
	this.lostUnitTypes[u.type.id_string] = this.lostUnitTypes[u.type.id_string] ? this.lostUnitTypes[u.type.id_string] + 1 : 1;
	
	if(this.units[u.type.id_string] && this.units[u.type.id_string] > 1)
		this.units[u.type.id_string]--;
	
	else
		delete this.units[u.type.id_string];
};

Player.prototype.unitSpawns = function(u)
{
	this.units[u.type.id_string] = this.units[u.type.id_string] ? this.units[u.type.id_string] + 1 : 1;
};

// returns the requirement text for a certain command and certain selected units; returns false, if there is no text (= the command can be ordered)
Player.prototype.getCommandRequirementText = function(command, units, target, learn)
{
	var requirement_text = "";
	
	if(learn)
	{
		var canLearn = false;
		
		for(var i = 0; i < units.length; i++)
		{
			var requiredLevel = command.requiredLevels ? command.requiredLevels[units[i].abilityLevels[command.id]] : -1;
			
			if(units[i].level >= requiredLevel && units[i].level > units[i].countLearnedAbilities)
				canLearn = true;
		}
		
		if(!canLearn)
			requirement_text += " Higher level required.";
		
		return requirement_text == "" ? false : requirement_text;
	}
	
	// check for lvl
	var lvl = 0;
	for(var i = 0; i < units.length; i++)
		lvl += units[i].abilityLevels[command.id];
	
	if(lvl == 0)
		requirement_text += " This ability needs to be learned first.";
	
	// check for mana
	if(units)
	{
		var hasMana = false;
		for(var i = 0; i < units.length; i++)
			if(units[i].mana >= command.getValue("manaCost", units[i]))
				hasMana = true;
		
		if(!hasMana)
			requirement_text += " Not enough mana.";
	}
	
	// check for gold
	if(command.goldCost && units && units[0].owner.gold < command.goldCost)
		requirement_text += " Not enough gold.";
	
	// check if not disabled
	if(command.type != COMMAND.MOVETO && command.type != COMMAND.MOVE && command.type != COMMAND.CANCEL && command.type != COMMAND.AMOVE && command.type != COMMAND.DANCE)
	{
		var canOrder = false;
		for(var i = 0; i < units.length; i++)
			if(units[i].type.commands[command.id_string] && !units[i].disabledCommands[command.id_string])
				canOrder = true;
		
		if(!canOrder)
			requirement_text += " This ability is disabled.";
	}
	
	// limit
	if(command.unitType)
	{
		var limit = command.unitType.getValue("limit", this);
		if(limit)
		{
			var count = 0;
			
			if(this.buildings[command.unitType.id_string])
				count += this.buildings[command.unitType.id_string];
			
			if(this.buildingsUC[command.unitType.id_string])
				count += this.buildingsUC[command.unitType.id_string];
			
			if(this.pseudoBuildings[command.unitType.id_string])
				count += this.pseudoBuildings[command.unitType.id_string];
			
			if(this.units[command.unitType.id_string])
				count += this.units[command.unitType.id_string];
			
			if(this.production[command.unitType.id_string])
				count += this.production[command.unitType.id_string];
			
			if(count >= limit)
				requirement_text += " You can only have " + count + ".";
		}
	}
	
	// check for max lvl
	if(command.upgrade && this.getUpgradeLevel(command.upgrade) + this.upgradeCountInResearch(command.upgrade) >= command.upgrade.maxLevel)
		requirement_text += " Max level reached.";
	
	// if no parallel research allowed and already researching, ...
	if(command.upgrade && command.upgrade.noParallelResearch && this.upgradeCountInResearch(command.upgrade) > 0)
		requirement_text += " Researching at the moment.";
	
	// check for unique unit make
	if(command.type == COMMAND.MAKEUNIT && command.unitType && command.unitType.uniqueAndHeroic && (this.units[command.unitType.id_string] > 0 || this.production[command.unitType.id_string]))
		requirement_text += " You can only have one.";
	
	if(command.requirementType)
		for(var i = 0; i < command.requirementType.length; i++)
		{
			var t = command.requirementType[i];
			if((t && t.isBuilding && (this.buildings[t.id_string] ? this.buildings[t.id_string] : 0) < command.requirementLevel[i]) || (t.isUpgrade && (this.upgrades[t.id_string] ? this.upgrades[t.id_string] : 0) < command.requirementLevel[i]))
				requirement_text += " " + command.requirementText[i] + ".";
		}
	
	if(target && target.type)
		for(var k = 0; k < command.targetRequiremementsArray.length; k++)
		{
			var met = false;
			var text = "";
			
			for(var i = 0; i < command.targetRequiremementsArray[k].length; i++)
			{
				if(command.targetRequiremementsArray[k][i].func(target))
					met = true;
				else
					text += command.targetRequiremementsArray[k][i].text + " or ";
			}
			
			if(!met)
				requirement_text += text.slice(0, text.length - 4) + " ";
		}
	
	return requirement_text == "" ? false : requirement_text;
};

Player.prototype.getCostOfNextInstanceForBuilding = function(type)
{
	if(!type.costIncrease)
		return type.cost;
	
	var cost = type.cost;
	if(type.costIncreaseGroup)
		for(var i = 0; i < type.costIncreaseGroup.length; i++)
		{
			cost += (this.buildings[type.costIncreaseGroup[i].id_string] ? this.buildings[type.costIncreaseGroup[i].id_string] : 0) * type.costIncrease;
			cost += (this.buildingsUC[type.costIncreaseGroup[i].id_string] ? this.buildingsUC[type.costIncreaseGroup[i].id_string] : 0) * type.costIncrease;
			cost += (this.pseudoBuildings[type.costIncreaseGroup[i].id_string] ? this.pseudoBuildings[type.costIncreaseGroup[i].id_string] : 0) * type.costIncrease;
		}
	
	return cost;
};

// returns a modifier for a given unit field, based on which upgrades this player has researched
Player.prototype.getValueModifier = function(value, type, alsoUnderConstruction)
{
	var mod = (this.upgradeMods[type.id_string] && this.upgradeMods[type.id_string][value]) ? this.upgradeMods[type.id_string][value] : 0;
	
	if(alsoUnderConstruction)
		for(var i = 0; i < game.upgrades.length; i++)
		{
			var u = game.upgrades[i];
			var count = this.upgradeCountInResearch(u);
			
			for(var k = 0; k < u.effectsTypes.length; k++)
			{
				if(u.effectsFields[k] == value && u.effectsTypes[k] == type)
					mod += u.effectsModifications[k] * count;
				
				if(u.effectsModsMultiplier && k in u.effectsModsMultiplier)
					for(var j = 0; j < count; j++)
						mod += type[value] * (u.effectsModsMultiplier[k] - 1);
			}
		}
	
	return mod;
};

Player.prototype.getUpgradeLevel = function(upg)
{
	return this.upgrades[upg.id_string] ? this.upgrades[upg.id_string] : 0;
};

// used to get the color in which the unit selection circles are drawn
Player.prototype.getAllyColor = function(alpha)
{
	var alpha_ = alpha ? alpha : 0.9;
	
	// if the playing player is spectator, return the player color itself instead of the ally color
	if(PLAYING_PLAYER.controller == CONTROLLER.SPECTATOR && playerColors[this.number - 1])
	{
		var arr = playerColors[this.number - 1][4];
		return "rgba(" + arr[0] + ", " + arr[1] + ", " + arr[2] + ", " + alpha_ + ")";
	}
	
	// white, if this is the playing player
	if(this == PLAYING_PLAYER)
		return "rgba(" + game.theme.line_red + ", " + game.theme.line_green + ", " + game.theme.line_blue + ", " + alpha_ + ")";
	
	// if neutral (mine), yellow
	if(this.controller == CONTROLLER.NONE)
		return "rgba(255, 255, 0, " + alpha_ + ")";
	
	// red, if its an enemy player
	if(this.isEnemyOfPlayer(PLAYING_PLAYER))
		return "rgba(224, 0, 0, " + alpha_ + ")";
	
	// blue, if allied player
	return "rgba(100, 160, 255, " + alpha_ + ")";
};

Player.prototype.isEnemyOfPlayer = function(player)
{
	return this.team.number != 0 && player.team.number != 0 && this.team != player.team;
};

Player.prototype.toString = function()
{
	return this.name;
};

Player.prototype.upgradeCountInResearch = function(upgrade)
{
	var c = 0;
	
	for(var i = 0; i < game.buildings.length; i++)
	{
		var b = game.buildings[i];
		if(b.owner == this)
			for(var k = 0; k < BUILDING_QUEUE_LEN; k++)
				if(b.queue && b.queue[k] == upgrade)
					c++;
	}
	
	return c;
};
// parent class for all map objects (units, buildings, doodads / tiles)
function MapObject()
{
	this.lastBlinkStart = 0; // last time this unit started blinking (when clicked on it); ms gametime
	this.isActive = true; // is false, when the unit is in a gold mine for example
	this.isAlive = true;
	this.targetUnit = null;
	this.hitCycle = 0; // when attacking, this gets ++ on every tick, to check when the actual attack happens and to check for cooldown
	this.tickOfDeath = 0; // when did the unit die, used for playing dead animation
	this.nextTickToCheckForNextEnemyUnit = 0; // we save this, because we dont wanna check every tick, but only every 5 ticks or so
	this.provisionalTargetUnit = null;
	this.kills = 0;
	this.isDetectedUntil = -1;
	this.level = 1;
	this.countLearnedAbilities = 0;
	this.queueFinish = 0; // how many ticks left, until the current producing unit is finished
	this.queueStarted = false;
	this.currentBuildTime = 0;
	this.isThrowedUntil = -1;
};

MapObject.prototype.initAutocast = function()
{
	var arr = [];
	
	_.each(this.type.commands, function(cmd){
		if(cmd.hasAutocast && cmd.autocastDefault)
			arr.push(cmd.id);
	});
	
	return arr;
};

MapObject.prototype.getValue = function(value)
{
	return this.type[value] + this.owner.getValueModifier(value, this.type) + (this.modifierMods[value] ? this.modifierMods[value] : 0);
};

MapObject.prototype.includesField = function(x, y)
{
	return x >= this.x && y >= this.y && x <= this.x + this.type.sizeX - 1 && y <= this.y + this.type.sizeX - 1;
};

// return true if building / tile is inside a drawn box on the screen (coords relative to screen position, so we have to add camera coords)
MapObject.prototype.isInBox = function(x1, y1, x2, y2)
{
	return this.drawPos.px + this.type.sizeX / 2 >= x1 && this.drawPos.py + this.type.sizeY / 2 >= y1 && this.drawPos.px - this.type.sizeX / 2 <= x2 && this.drawPos.py - this.type.sizeY / 2 <= y2;
};

// return true if building / tile is inside a drawn box on the screen (coords relative to screen position, so we have to add camera coords)
MapObject.prototype.isInBoxVisible = function(x1, y1, x2, y2)
{
	return this.isInBox(x1, y1, x2, y2);
};

// remove the unit from the game. Most of the time, when it dies, but also when it enters a building
MapObject.prototype.remove = function()
{
	this.isActive = false;
	
	game.units.erease(this);
	game.buildings.erease(this);
	game.selectedUnits.erease(this);
	
	if(game.selectedUnits.length == 0)
		keyManager.resetCommand();
	
	// delete from waypoints and target unitz
	var units = game.units.concat(game.buildings);
	for(var i = 0; i < units.length; i++)
	{
		if(units[i].waypoint)
			for(var k = 0; k < units[i].waypoint.length; k++)
				if(units[i].waypoint[k] == this)
				{
					units[i].waypoint.splice(k, 1);
					k--;
				}
		
		// delete from units targetUnits
		if(units[i].targetUnit == this)
			units[i].targetUnit = null;
	}
	
	if(this.type.uniqueAndHeroic)
		game.units4.push(this);
	
	// kill all graphic effects on this unit
	for(var k = 0; k < this.effectsToDraw.length; k++)
		this.effectsToDraw[k].tickOfDeath = ticksCounter + 40;
};

MapObject.prototype.initHPAndMana = function()
{
	var maxHP = this.getValue("hp");
	var startHP = this.getValue("startHp");
	this.hp = startHP ? startHP : maxHP;
	if(this.hp > maxHP)
		this.hp = maxHP;
	
	var maxMana = this.getValue("mana");
	var startMana = this.getValue("startMana");
	this.mana = startMana ? startMana : 0;
	if(this.mana > maxMana)
		this.mana = maxMana;
}

// start blinking the unit circle (when rightclicked)
MapObject.prototype.blink = function()
{
	this.lastBlinkStart = timestamp;
};

MapObject.prototype.canLoad = function()
{
	return this.type.cargoSpace > 0;
};

MapObject.prototype.hasInQueue = function(type)
{
	if(!this.queue)
		return false;
	
	for(var i = 0; i < this.queue.length; i++)
		if(this.queue[i] == type)
			return true;
	
	return false;
};

MapObject.prototype.setAutocast = function(order, on)
{
	if(on)
	{
		if(!this.autocast.contains(order))
			this.autocast.push(order);
	}
	
	else
		this.autocast.erease(order);
};

MapObject.prototype.hasModifierWithId = function(id)
{
	for(var i = 0; i < this.modifiers.length; i++)
		if(this.modifierMods[i].modId == id)
			return true;
	
	return false;
};

MapObject.prototype.applyModifier = function(mod, originUnit)
{
	var modId = parseInt(Math.random() * 99999999);
	
	this.modifiers.push({
		modifier: mod,
		originUnit: originUnit,
		removeAt: (mod.duration && mod.duration > 0) ? (ticksCounter + mod.getValue("duration", this.owner)) : -1,
		modId: modId,
		active: mod.hasActivationCondition ? false : true
	});
	
	if(mod.effects)
		for(var i = 0; i < mod.effects.length; i++)
			startEffect(mod.effects[i], {
				from: this,
				attachToUnit: true,
				modId: modId,
				scale: (mod.auraRange && mod.auraRange[i]) ? (mod.auraRange[i] + 1) : 0,
				auraColorRed: mod.auraColorRed,
				auraColorGreen: mod.auraColorGreen,
				auraColorBlue: mod.auraColorBlue,
				auraColorAlpha: mod.auraColorAlpha,
				mode: mod.particleMode,
				density: mod.density
			});
	
	if(mod.sound)
		startEffect("sound", {
			from: this,
			sound: mod.sound,
			attachToUnit: true,
			volume: mod.volume,
			soundDuration: 980,
			modId: modId
		});
	
	this.checkUpgrades();
};

MapObject.prototype.removeModifier = function(index)
{
	var mod = this.modifiers.splice(index, 1)[0];
	
	// kill expired effects
	for(var k = 0; k < this.effectsToDraw.length; k++)
		if(this.effectsToDraw[k].tickOfDeath <= ticksCounter)
		{
			this.effectsToDraw.splice(k, 1);
			k--;
		}
	
	for(var k = 0; k < this.effectsToDraw.length; k++)
		if(this.effectsToDraw[k].modId == mod.modId)
			this.effectsToDraw[k].tickOfDeath = ticksCounter + 40;
	
	this.checkUpgrades();
};

MapObject.prototype.checkUpgrades = function()
{
	this.modifierMods = {};
	this.disabledCommands = {};
	var customImg = null;
	
	var dataFields = this.type.getDataFields();
	
	for(var i = 0; i < this.modifiers.length; i++)
	{
		if(!this.modifiers[i].active)
			continue;

		var mod = this.modifiers[i].modifier;

		if(mod.disabledCommands)
			for(var k = 0; k < mod.disabledCommands.length; k++)
				this.disabledCommands[mod.disabledCommands[k].id_string] = mod.disabledCommands[k].id_string;
		
		if(mod.unitImg && mod.changeUnitImg && this.type.isUnit)
			customImg = mod.unitImg;
	};
	
	if(customImg)
		this.img = customImg;
	else
		this.refreshImg();
};

// blocks / unblocks all the containing fields of this building / tile. Usually used before and after searching a path to (the center of) this building. For this, is has to not block the pathfinding.
// Also used on creation or when killed
MapObject.prototype.switchBlocking = function(on, dontRefreshNBs)
{
	if(this.type.isUnit || !this.x || !this.y)
		return;
	
	// block / unblock fields
	for(var x = this.x; x < this.x + this.type.sizeX; x++)
		for(var y = this.y; y < this.y + this.type.sizeY; y++)
			game.blockArray[x][y] = !on;
	
	if(dontRefreshNBs)
		return;
	
	// refresh neightbours of blocked / unblocked fields
	for(var x = this.x - 1; x < this.x + this.type.sizeX + 1; x++)
		for(var y = this.y - 1; y < this.y + this.type.sizeY + 1; y++)
			game.refreshNBSOfField(game.fields[x][y]);
	
	// refresh neightbours of blocked / unblocked fields 2x2
	for(var x = Math.max(this.x - 2, 1); x < Math.min(this.x + this.type.sizeX + 2, game.x); x++)
		for(var y = Math.max(this.y - 2, 1); y < Math.min(this.y + this.type.sizeY + 2, game.y); y++)
			game.refreshNBSOfField2x2(game.fields2x2[x][y]);
};

MapObject.prototype.switchBlockingForTeam = function(on, team)
{
	if(this.type.isUnit || !this.x || !this.y)
		return;
	
	// block / unblock fields
	for(var x = this.x; x < this.x + this.type.sizeX; x++)
		for(var y = this.y; y < this.y + this.type.sizeY; y++)
			team.blockArray[x][y] = !on;
};

MapObject.prototype.switchBlockingTotal = function(on)
{
	this.switchBlocking(on);
	
	// switch on blocking for all the teams
	for(var i = 0; i < game.teams.length; i++)
		this.switchBlockingForTeam(on, game.teams[i]);
};

MapObject.prototype.getXP4NextLevel = function()
{
	if(!this.type.experienceLevels || this.type.experienceLevels.length <= 0)
		return 0;
	
	for(var i = 0; i < this.type.experienceLevels.length; i++)
		if(this.exp < this.type.experienceLevels[i])
			return this.type.experienceLevels[i];
	
	return this.type.experienceLevels[this.type.experienceLevels.length - 1];
};

MapObject.prototype.getPercOfCurrentLevel = function()
{
	if(!this.type.experienceLevels || this.type.experienceLevels.length <= 0)
		return 0;
	
	for(var i = 0; i < this.type.experienceLevels.length; i++)
		if(this.exp < this.type.experienceLevels[i])
		{
			var oldExp = this.type.experienceLevels[i - 1] ? this.type.experienceLevels[i - 1] : 0;
			return (this.exp - oldExp) / (this.type.experienceLevels[i] - oldExp);
		}
	
	return 1;
};

MapObject.prototype.drawExpbar = function(x, y, w, h, linwWidth)
{
	var lineWidth_ = linwWidth ? linwWidth : 2;
	
	c.fillStyle = "white";
	c.fillRect(x - lineWidth_, y - lineWidth_, w + lineWidth_ * 2, h + lineWidth_ * 2);
	
	c.fillStyle = "rgba(125, 125, 125, 1)";
	
	c.fillRect(x, y, w * this.getPercOfCurrentLevel(), h);
};

MapObject.prototype.drawHealthbar = function(x, y, w, h, linwWidth)
{
	var hpPercentage = this.hp / this.getValue("hp");
	
	var lineWidth_ = linwWidth ? linwWidth : 2;
	
	c.fillStyle = "white";
	c.fillRect(x - lineWidth_, y - lineWidth_, w + lineWidth_ * 2, h + lineWidth_ * 2);
	
	if(hpPercentage <= 0.25)
		c.fillStyle = "rgba(255, 0, 0, 1)";
	
	else if(hpPercentage <= 0.5)
		c.fillStyle = "rgba(255, 125, 0, 1)";
	
	else
		c.fillStyle = "rgba(0, 150, 0, 1)";
	
	c.fillRect(x, y, w * hpPercentage, h);
};

MapObject.prototype.drawManabar = function(x, y, w, h, linwWidth)
{
	var lineWidth_ = linwWidth ? linwWidth : 2;
	
	c.fillStyle = "white";
	c.fillRect(x - lineWidth_, y - lineWidth_, w + lineWidth_ * 2, h + lineWidth_ * 2);
	
	c.fillStyle = "rgba(200, 0, 200, 1)";
	
	c.fillRect(x, y, w * (this.mana / this.getValue("mana")), h);
};

MapObject.prototype.drawLifetimebar = function(x, y, w, h, linwWidth)
{
	var lineWidth_ = linwWidth ? linwWidth : 2;
	
	c.fillStyle = "white";
	c.fillRect(x - lineWidth_, y - lineWidth_, w + lineWidth_ * 2, h + lineWidth_ * 2);
	
	c.fillStyle = "rgba(100, 100, 100, 1)";
	
	c.fillRect(x, y, w * (this.lifetime / this.type.lifetime), h);
};

MapObject.prototype.drawLoadbar = function(x, y, w, h, linwWidth)
{
	var lineWidth_ = linwWidth ? linwWidth : 2;
	
	c.fillStyle = "white";
	c.fillRect(x - lineWidth_, y - lineWidth_, w + lineWidth_ * 2, h + lineWidth_ * 2);
	
	c.fillStyle = "rgba(35, 35, 35, 1)";
	
	var cargoSpace = this.getValue("cargoSpace");
	for(var i = 0; i < cargoSpace; i++)
		c.fillRect(x + (i / cargoSpace) * w + lineWidth_ / 2, y, (1 / cargoSpace) * w - lineWidth_, h);
	
	c.fillStyle = "rgba(190, 190, 190, 1)";
	
	var cargo = 0;
	for(var i = 0; i < this.cargo.length; i++)
	{
		c.fillRect(x + (cargo / cargoSpace) * w + lineWidth_ / 2, y, (this.cargo[i].type.cargoUse / cargoSpace) * w - lineWidth_, h);
		cargo += this.cargo[i].type.cargoUse;
	}
	
	c.stroke();
};

MapObject.prototype.drawEye = function()
{
	c.globalAlpha *= 0.8 * ((Math.sin(ticksCounter) + 1) / 2 * 0.4 + 0.8);
	
	x = this.drawPos.px * FIELD_SIZE - imgs.eye.img.w * SCALE_FACTOR / 2 - game.cameraX;
	y = (this.drawPos.py - this.type.healthbarOffset - 0.4) * FIELD_SIZE - game.cameraY - imgs.eye.img.h * ((SCALE_FACTOR + 1.0) / 2.0);
	
	c.drawImage(miscSheet[0], imgs.eye.img.x, imgs.eye.img.y, imgs.eye.img.w, imgs.eye.img.h, x, y, imgs.eye.img.w * SCALE_FACTOR, imgs.eye.img.h * SCALE_FACTOR);
};

// gets the tab prio of this object; higher prio's unit's commands get displayed when several units selected
MapObject.prototype.getTabPriority = function()
{
	return this.type.tabPriority + (this.isUnderConstruction ? -1 : 0);
};

MapObject.prototype.drawProgressBar = function(x, y, w, h, linwWidth)
{
	var lineWidth_ = linwWidth ? linwWidth : 2;
	
	var percentage = this.queueStarted ? ((this.currentBuildTime - (this.queueFinish - ticksCounter)) / this.currentBuildTime) : 0;
	
	drawBar(x, y, w, h, Math.min(percentage, 1), "rgba(0, 160, 230, 1)", lineWidth_);
};

MapObject.prototype.toString = function()
{
	return this.type.name + " @" + this.pos.px + ":" + this.pos.py;
};
// Class repreesenting a (movable) unit
Unit.prototype = new MapObject();
function Unit(data)
{
	this.modifiers = [];
	this.modifierMods = {};
	this.disabledCommands = {};
	
	// basic attributes
	this.pos = new Field(data.x, data.y, true);
	this.type = data.type;
	this.owner = data.owner;
	
	this.id = game.global_id++;
	
	// everything regarding the current order
	this.order = lists.types.stop;
	this.path = null; // the current path (array of fields)
	this.target = null; // the current target; can be a field or a unit
	this.carriedGoldAmount = 0;
	this.goldMine = null; // the goldmine currently mining from
	this.lastAttackingTick = -999; // the last tick, when this unit was attacking
	this.tickOfLastWeaponFired = -999; // the last tick, when this unit was exactly doing damage
	this.targetLockingUnit = null; // when a unit starts attacking, it locks on a unit (and will continue the current attack cycle, even if this unit moves out of range)
	this.vision = this.type.vision;
	this.cargo = [];
	
	// order queue
	this.queueOrder = [];
	this.queueTarget = [];
	
	// pushing / blocking
	this.blocking = false; // can be pushed by friendly units (false when hold position for example)
	this.lastTicksPosition = this.pos.getCopy(); // we need this for example to interpolate between last ticks and this ticks position when drawing (for more smooth looking movement)
	this.drawPos = this.pos.getCopy(); // interpolation between last ticks position and this ticks position
	
	this.setYDrawingOffset();
	game.addObject(this);

	// adding for clipboard undo
	if(game_state == GAME.EDITOR && data.noHistory!=true)
		editor.clipboard.history.addObject(this);
	
	this.hitOffsetPos = null; // when this unit is hit, draw pos is slightly offsettet, to demonstate the "power" of the hit
	this.hitOffsetTill = 0; // how long to draw the hit modified pos
	this.lastTickCircleEffect = 0; // last tick, when the circle blinking effect was started
	this.oscillationOffset = Math.floor(Math.random() * 100);
	
	this.bodyPower = 1;
	this.drawingHeight = 0;
	this.yDrawingOffset = this.pos.py;
	this.lastMiningTick = -999;
	this.tickOfLastLoadIn = -1;
	
	// making units stuff
	this.queue = []; // references to the unit types that are in production
	this.autocast = this.initAutocast(); // ids of abilities that are on autocast
	
	this.animationOffset = Math.floor(Math.random() * 100); // random offset for animation, so not all unit have the same animation state at the same time
	
	this.revealedToTeamUntil = new Array(MAX_PLAYERS);
	
	this.flameDeath = false;
	
	if(ticksCounter > 0 && game.lastReadySound + 20 < ticksCounter && this.owner == PLAYING_PLAYER)
	{
		soundManager.playSound(this.type.readySound, this.drawPos, this.type.readySoundVolume);
		game.lastReadySound = ticksCounter;
		game.lastYesSound = ticksCounter;
	}
	
	this.throwStart = -1;
	this.throwFrom = null;
	this.throwTo = null;
	
	if(this.type.lifetime)
		this.lifetime = this.type.lifetime;
	
	this.abilityLevels = [];
	this.lastTickAbilityUsed = [];
	for(var i = 0; i < game.commands.length; i++)
	{
		this.lastTickAbilityUsed[i] = -9999;
		this.abilityLevels[i] = (game.commands[i] && game.commands[i].requiredLevels && game.commands[i].requiredLevels.length > 0) ? 0 : 1;
	}
	
	// add to units for this player
	if(this.owner)
		this.owner.unitSpawns(this);
	
	this.level = (this.type.experienceLevels && this.type.experienceLevels.length > 0) ? 1 : 0;
	this.exp = 0;
	
	this.refreshImg();
	
	this.direction = Math.floor(Math.random() * this.img._angles); // direction the unit is looking in
	
	this.effectsToDraw = []; // if this unit has modifiers for example, that make effect, the effects are attached here
	
	this.initHPAndMana();
};

Unit.prototype.refreshImg = function()
{
	this.img = (this.owner.skins && this.owner.skins[this.type.id_string]) ? this.owner.skins[this.type.id_string] : this.type.img;
};

Unit.prototype.hasPath = function()
{
	return this.path != null;
};

Unit.prototype.distanceTo = function(otherUnit)
{
	if(!otherUnit)
		return 999999;
	
	return otherUnit.type.isBuilding ? otherUnit.distanceTo(this) : this.pos.distanceTo2(otherUnit.pos) - this.type.radius - otherUnit.type.radius;
};

// return true if unit is inside a drawn box; gameplay coordinates
Unit.prototype.isInBox = function(x1, y1, x2, y2)
{
	return this.drawPos.px + this.type.radius >= x1 && this.drawPos.py + this.type.radius >= y1 && this.drawPos.px - this.type.radius <= x2 && this.drawPos.py - this.type.radius <= y2;
};

// return true if unit is inside a drawn box; gameplay coordinates
Unit.prototype.isInBoxVisible = function(x1, y1, x2, y2)
{
	return this.drawPos.px + this.type.radius >= x1 && this.drawPos.py + this.type.radius >= y1 && this.drawPos.px - this.type.radius <= x2 && this.drawPos.py - this.type.radius <= y2 + this.type.height;
};

Unit.prototype.getYDrawingOffset = function()
{
	return this.yDrawingOffset;
};

Unit.prototype.setYDrawingOffset = function()
{
	this.yDrawingOffset = this.pos.py + this.type.radius - (this.isAlive ? 0 : 3) + (this.type.flying ? 2 : 0);
};

// interpolate between last ticks and this ticks position
Unit.prototype.updateDrawPosition = function()
{
	this.drawPos = this.lastTicksPosition.addNormalizedVector(this.pos, percentageOfCurrentTickPassed * this.pos.distanceTo2(this.lastTicksPosition));
	
	if(this.type.flying)
	{
		this.drawingHeight = this.drawingHeight + Math.max(Math.min((game.getHMValue3(this.drawPos) * CLIFF_HEIGHT - this.drawingHeight), gameTimeDiff * 2), -gameTimeDiff * 2);
		this.drawPos = this.drawPos.add3(0, -this.drawingHeight);
	}
	else
		this.drawPos = this.drawPos.add3(0, -game.getHMValue3(this.drawPos) * CLIFF_HEIGHT);
	
	if(this.hitOffsetTill > timestamp && this.hitOffsetPos)
	{
		var t = 200 - (this.hitOffsetTill - timestamp);
		var mod = t < 50 ? t / 50 : ((150 - (t - 50)) / 150);
		
		this.drawPos = this.drawPos.addNormalizedVector(this.hitOffsetPos, -0.04 * mod);
	}
};

// draw; expects screen bounds (ingame coords)
Unit.prototype.draw = function()
{
	// if ourside if visible bounds or not visible (fogwise), return, because we dont need to draw anything
	if(!PLAYING_PLAYER.team.canSeeUnit(this) || this.getValue("noShow"))
		return
	
	var frame;
	var frameWidth;
	var scale = this.getValue("imageScale") * SCALE_FACTOR;
	var img = this.img.idle;
	
	if(this.isThrowedUntil > ticksCounter && this.isAlive)
	{
		var percDone = (ticksCounter + percentageOfCurrentTickPassed - this.throwStart) / (this.isThrowedUntil - this.throwStart);
		var dist = this.throwFrom.distanceTo2(this.throwTo);
		var isDeadForHowLong = ticksCounter - this.throwStart;
		img = this.img.die ? this.img.die : this.img.idle;
		
		if(percDone < 0.5)
		{
			this.drawPos = this.throwFrom.addNormalizedVector(this.throwTo, dist * percDone * 1.5);
			this.pos = this.drawPos; 
			this.drawPos = this.drawPos.add3(0, -game.getHMValue2(this.drawPos.x, this.drawPos.y) * CLIFF_HEIGHT - (-Math.pow(percDone * 4 - 1, 2) + 1) * 0.20 * dist);
		}
		
		else if(percDone < 0.75)
		{
			this.drawPos = this.throwFrom.addNormalizedVector(this.throwTo, 0.75 * dist + dist * (percDone - 0.5) * 0.66);
			this.pos = this.drawPos;
			this.drawPos = this.drawPos.add3(0, -game.getHMValue2(this.drawPos.x, this.drawPos.y) * CLIFF_HEIGHT - (-Math.pow(percDone * 8 - 5, 2) + 1) * 0.06 * dist);
		}
		
		else
		{
			this.drawPos = this.throwFrom.addNormalizedVector(this.throwTo, 0.915 * dist + dist * (percDone - 0.75) * 0.33);
			this.pos = this.drawPos;
			this.drawPos = this.drawPos.add3(0, -game.getHMValue2(this.drawPos.x, this.drawPos.y) * CLIFF_HEIGHT);
		}
		
		// create smoke effect when hit the ground
		if(((percDone > 0.45 && percDone < 0.55) || (percDone > 0.7 && percDone < 0.8)) && tickDiff > 0)
			new Dust({from: this.drawPos});
		
		frameWidth = img.frameWidth;
		frame = (this.isThrowedUntil - ticksCounter <= 10) ? Math.floor((this.isThrowedUntil - ticksCounter) / 10 * (img.w / frameWidth)) : Math.floor(Math.min(percDone * 2, 0.99) * (img.w / frameWidth));
		
		var tileHeight = img.h / this.img._angles;
		
		// get drawing position
		var x = this.drawPos.px * FIELD_SIZE - frameWidth * scale / 2 - game.cameraX;
		var y = this.drawPos.py * FIELD_SIZE - (tileHeight - this.getValue("drawOffsetY")) * scale - game.cameraY;
		
		c.drawImage(this.img.file[this.owner.number], frame * frameWidth + img.x, this.direction * tileHeight + img.y, frameWidth, tileHeight, x, y, frameWidth * scale, tileHeight * scale);
		
		return;
	}
	
	// if unit is dying, play death animation
	if(!this.isAlive)
	{
		var percDone = (ticksCounter + percentageOfCurrentTickPassed - this.throwStart) / (this.isThrowedUntil - this.throwStart);
		var dist = this.throwFrom.distanceTo2(this.throwTo);
		var isDeadForHowLong = (ticksCounter + percentageOfCurrentTickPassed) - this.throwStart;
		img = this.img.die ? this.img.die : this.img.idle;
		
		if(this.type.removeAfterDeadAnimation && isDeadForHowLong > 100)
		{
			game.objectsToDraw.erease(this);
			return;
		}
		
		if(percDone < 0.5)
		{
			this.drawPos = this.throwFrom.addNormalizedVector(this.throwTo, dist * percDone * 1.5);
			this.drawPos = this.drawPos.add3(0, -game.getHMValue2(this.drawPos.x, this.drawPos.y) * CLIFF_HEIGHT - (-Math.pow(percDone * 4 - 1, 2) + 1) * 0.20 * dist);
		}
		
		else if(percDone < 0.75)
		{
			this.drawPos = this.throwFrom.addNormalizedVector(this.throwTo, 0.75 * dist + dist * (percDone - 0.5) * 0.66);
			this.drawPos = this.drawPos.add3(0, -game.getHMValue2(this.drawPos.x, this.drawPos.y) * CLIFF_HEIGHT - (-Math.pow(percDone * 8 - 5, 2) + 1) * 0.06 * dist);
		}
		
		else if(percDone < 1)
		{
			this.drawPos = this.throwFrom.addNormalizedVector(this.throwTo, 0.915 * dist + dist * (percDone - 0.75) * 0.33);
			this.drawPos = this.drawPos.add3(0, -game.getHMValue2(this.drawPos.x, this.drawPos.y) * CLIFF_HEIGHT);
		}
		
		else
			this.drawPos = this.throwTo.add3(0, -game.getHMValue2(this.throwTo.x, this.throwTo.y) * CLIFF_HEIGHT);
		
		this.pos = this.drawPos;
		
		// create smoke effect when hit the ground
		if(((percDone > 0.45 && percDone < 0.55) || (percDone > 0.7 && percDone < 0.8)) && tickDiff > 0)
			new Dust({from: this.drawPos});
		
		frameWidth = img.frameWidth;
		frame = Math.floor(Math.min(isDeadForHowLong * this.type.deathAnimationSpeed, img.w / frameWidth - 1));
		
		var tileHeight = img.h / this.img._angles;
		
		// get drawing position
		var x = this.drawPos.px * FIELD_SIZE - frameWidth * scale / 2 - game.cameraX;
		var y = this.drawPos.py * FIELD_SIZE - (tileHeight - this.getValue("drawOffsetY")) * scale - game.cameraY;
		
		// if dead animation is done playing and this unit type has to be removed after dead animation done playing
		if(this.type.removeAfterDeadAnimation && Math.floor(isDeadForHowLong * this.type.deathAnimationSpeed) == img.w / frameWidth && tickDiff)
		{
			// create some random smoke effects
			if(this.type.size > 2)
				for(var i = 0; i < 10; i++)
					new Dust({
						from: this.drawPos.add2(Math.random() * Math.PI * 2, Math.random() * this.type.size / 2),
						scale: (Math.random() * 1.33 + 0.5) * this.drawPos
					});
			
			// create side smoke effects (big dust clouds that go sideways)
			for(var i = 0; i < Math.PI * 2; i += Math.random() * 1.5)
				new Dust({
					from: this.drawPos,
					scale: (Math.random() * 1.66 + 0.5) * this.size,
					ageScale: 0.66 * this.size,
					vz: 0.01,
					xFunction: function(age){
						return ((-1) / (age + 0.3) + 3) * this.x_ * this.size_;
					},
					yFunction: function(age){
						return ((-1) / (age + 0.3) + 3) * this.y_ * this.size_;
					},
					x_: Math.cos(i),
					y_: Math.sin(i),
					size_: this.size / 3
				});
			
			// play hit ground sound
			soundManager.playSound(this.type.slamSound ? this.type.slamSound : SOUND.FALL, this.pos);
		}
		
		// fading out
		if(this.type.removeAfterDeadAnimation)
			c.globalAlpha = Math.min(Math.max(1 + (img.w / frameWidth - isDeadForHowLong * this.type.deathAnimationSpeed) / 16, 0), 1);
			
		else
			c.globalAlpha = isDeadForHowLong > 35 ? Math.max(55 - isDeadForHowLong, 0) / 20 : 1;
		
		c.drawImage(this.img.file[this.owner.number], frame * frameWidth + img.x, this.direction * tileHeight + img.y, frameWidth, tileHeight, x, y, frameWidth * scale, tileHeight * scale);
		
		if(this.flameDeath)
		{
			if(c.globalAlpha > 0.5)
			{
				// create random flames
				for(var i = 0; i < tickDiff; i++)
					if(Math.random() < 0.07)
						new Sprite({
							from: this.drawPos.add3(0, -0.3).add2(Math.random() * Math.PI * 2, 0.1),
							img: imgs["fire" + (Math.floor(Math.random() * 4) + 1)],
							scaleFunction: function(age){ return 1.25 + age * 0.8; },
							alphaFunction: function(age){ return 0.5; }
						});
				
				// create random zmoke
				for(var i = 0; i < tickDiff; i++)
					if(Math.random() < 0.1)
						new Dust({from: this.drawPos, scale: 1 + Math.random(), ageScale: 2 + Math.random()});
			}
		}
		
		c.globalAlpha = 1;
		
		// eventually remove unit from the game
		if(isDeadForHowLong > 100)
			game.objectsToDraw.erease(this);
		
		return;
	}
	
	var angle = 999;
	var isAttacking = (this.lastAttackingTick + 6 >= ticksCounter || (this.order && this.order.type == COMMAND.REPAIR) || this.lastMiningTick + 1 >= ticksCounter) || (this.order && this.order.animationName);
	
	if(this.order && this.order.type == COMMAND.DANCE)
	{
		img = this.img[this.order.dance_img] ? this.img[this.order.dance_img] : this.img.idle;
		frameWidth = img.frameWidth;
		frame = Math.floor(ticksCounter / 3) % (img.w / frameWidth);
	}
	
	else if(this.forcedAnimation && this.img[this.forcedAnimation] && this.forcedAnimationStop >= ticksCounter && this.forcedAnimationStart >= 0)
	{
		img = this.img[this.forcedAnimation];
		frameWidth = img.frameWidth;
		angle = 0;
		frame = Math.min(Math.max(Math.floor((ticksCounter - this.forcedAnimationStart) / (this.forcedAnimationStop - this.forcedAnimationStart) * (img.w / frameWidth)), 0), img.w / frameWidth - 1);
	}
	
	// if walk
	else if((!this.lastTicksPosition.equals(this.pos) || (this.type.flying && !isAttacking)) && !(this.type.flying && isAttacking))
	{
		img = (this.carriedGoldAmount && this.img.walkGold) ? this.img.walkGold : (this.img.walk ? this.img.walk : this.img.idle);
		frameWidth = img.frameWidth;
		
		if(!this.lastTicksPosition.equals(this.pos))
			angle = this.lastTicksPosition.getAngleTo(this.pos);
		
		frame = Math.floor(((ticksCounter + this.animationOffset + this.oscillationOffset) / this.type.animSpeed + (this.hitOffsetTill > timestamp ? 1 : 0)) % (img.w / frameWidth));
		
		// dust effect
		if(tickDiff > 0 && Math.random() < this.type.dustCreationChance)
			new Dust({from: this.drawPos.add3(0, 0.2)});
	}
	
	// if attack
	else if(isAttacking)
	{
		img = (this.order && this.order.animationName && this.img[this.order.animationName]) ? this.img[this.order.animationName] : (this.img.attack ? this.img.attack : this.img.idle);
		
		if(this.targetUnit || this.target)
			angle = this.pos.getAngleTo(this.targetUnit ? this.targetUnit.pos : this.target);
		
		frameWidth = img.frameWidth;
		
		var weaponDelay = (this.order && this.order.castingDelay) ? this.order.getValue("castingDelay", this) : this.type.weaponDelay;
		var cooldown = (this.order && this.order.cooldown) ? this.order.cooldown : this.type.weaponCooldown;
		
		if(this.type.flying)
			frame = Math.floor(((ticksCounter + this.oscillationOffset) / this.type.animSpeed) % (img.w / frameWidth));
		
		else if(ticksCounter - this.tickOfLastWeaponFired <= cooldown + 1) // if weapon has been fired recently and is cooldowning now
			frame = Math.floor(((ticksCounter - this.tickOfLastWeaponFired + weaponDelay) % cooldown) / cooldown * (img.w / frameWidth));
		
		else
			frame = Math.floor((this.hitCycle % cooldown) / cooldown * (img.w / frameWidth));
	}
	
	// if idle
	else
	{
		frameWidth = img.frameWidth;
		frame = this.type.idleFrames ? this.type.idleFrames[Math.min(Math.floor(ticksCounter / 4 + this.pos.py * 123241) % this.type.idleFrames.length, parseInt(img.w / frameWidth))] : (Math.max((Math.floor((ticksCounter + this.animationOffset) / 5) % (img.w / frameWidth + 20)) - 20, 0));
	}
	
	if(angle != 999) // if a new angle has been calculated, calculate the new direction from it
	{
		angle += angle < -Math.PI ? Math.PI * 2 : 0;
		angle -= angle > Math.PI ? Math.PI * 2 : 0;
		
		if(this.img._angles == 8)
		{
			if(angle >= Math.PI * 3 / 8 && angle <= Math.PI * 5 / 8)
				this.direction = 0;
			else if(angle <= -Math.PI * 3 / 8 && angle >= -Math.PI * 5 / 8)
				this.direction = 3;
			else if(angle >= Math.PI * 7 / 8 || angle <= -Math.PI * 7 / 8)
				this.direction = 1;
			else if((angle <= Math.PI * 1 / 8 && angle >= 0) || (angle >= -Math.PI * 1 / 8 && angle <= 0))
				this.direction = 2;
			else if(angle <= Math.PI * 7 / 8 && angle >= Math.PI * 5 / 8)
				this.direction = 4;
			else if(angle <= Math.PI * 3 / 8 && angle >= Math.PI * 1 / 8)
				this.direction = 5;
			else if(angle >= -Math.PI * 7 / 8 && angle <= -Math.PI * 5 / 8)
				this.direction = 6;
			else
				this.direction = 7;
		}
		
		else if(this.img._angles == 1)
			this.direction = 0;
		
		else
		{
			if(angle >= Math.PI / 4 && angle <= Math.PI * 3 / 4)
				this.direction = 0;
			else if(angle <= -Math.PI / 4 && angle >= -Math.PI * 3 / 4)
				this.direction = 3;
			else if(angle >= Math.PI * 3 / 4 || angle <= -Math.PI * 3 / 4)
				this.direction = 1;
			else
				this.direction = 2;
		}
	}
	
	var tileHeight = (this.order && this.order.type == COMMAND.DANCE) ? img.h : (img.h / this.img._angles);
	
	// get drawing position
	var x = this.drawPos.px * FIELD_SIZE - frameWidth / 2 * scale - game.cameraX;
	var y = this.drawPos.py * FIELD_SIZE - (tileHeight - this.getValue("drawOffsetY")) * scale - game.cameraY;
	
	// if flying, calculate oscillation frquency height
	if(this.type.flying && this.img.walk)
	{
		var countFrames = this.img.walk.w / this.img.walk.frameWidth;
		y += Math.sin(((((ticksCounter + this.oscillationOffset + percentageOfCurrentTickPassed + 3.8 * this.type.animSpeed) / this.type.animSpeed) % countFrames) / countFrames) * Math.PI * 2) * FIELD_SIZE * this.type.oscillationAmplitude;
	}
	
	// invis alpha
	if(this.getValue("isInvisible"))
		c.globalAlpha = (this.isDetectedUntil >= ticksCounter || !this.owner.isEnemyOfPlayer(PLAYING_PLAYER)) ? 0.5 : 0.07;
	else
		c.globalAlpha = 1;
	
	if(this.order && this.order.type == COMMAND.DANCE)
		this.direction = 0;
	
	// unit image itself
	c.drawImage(this.img.file[this.owner.number], frame * frameWidth + img.x, this.direction * tileHeight + img.y, frameWidth, tileHeight, x, y, frameWidth * scale, tileHeight * scale);
	
	if(this.getValue("hasDetection"))
		this.drawEye();
	
	c.globalAlpha = 1;
		
	// debugs
	/*
	if(show_unit_details && !network_game)
	{
		c.fillStyle = "rgba(0, 0, 0, 1)";
		c.fillText(this.order.name, this.drawPos.px * FIELD_SIZE - game.cameraX - FIELD_SIZE / 3, (this.drawPos.py - this.type.healthbarOffset) * FIELD_SIZE - game.cameraY - 12);
	
		// show detailed path to next target
		if(this.path)
		{
			c.strokeStyle = "yellow";
			c.beginPath();
			c.moveTo(this.drawPos.px * FIELD_SIZE - game.cameraX, this.drawPos.py * FIELD_SIZE - game.cameraY);
			c.lineTo(this.path.px * FIELD_SIZE - game.cameraX, this.path.py * FIELD_SIZE - game.cameraY);
			c.stroke();
		}
	}
	*/
};
Building.prototype = new MapObject();

// Class for Building, expects a json object with several paramters
function Building(data)
{
	_.extend(this, data);
	
	// mines always belong to player 0 (neutral)
	if(this.type.alwaysNeutral)
		this.owner = game.players[0];
	
	this.isUnderConstruction = this.buildFirst ? true : false;
	this.buildTicksLeft = 0; // when under construction, when does it finish
	this.seenBy = new Array(MAX_PLAYERS + 1); // contains a value, determing in which state this building has been seen by player [index] the last time he saw it
	this.seenByAsBuildingType = new Array(MAX_PLAYERS + 1); // buildings can transform, so here the building type is stored in which this building has been seen by player [index]
	
	this.workload = [0];
	this.workload_total = 0;
	this.countWorkingWorkers = 0;
	this.lastCountWorkingWorkers = 0;
	
	this.vision = this.buildFirst ? 3 : this.type.vision;
	
	// neutral buildings are always seen by all players
	if(this.owner.controller == CONTROLLER.NONE && !this.isDummy)
	{
		for(var i = 0; i < this.seenBy.length; i++)
			this.seenBy[i] = BUILDING_STATE.NORMAL;
		
		// switch on blocking for all the teams
		for(var i = 0; i < game.teams.length; i++)
			this.switchBlockingForTeam(true, game.teams[i]);
	}
	
	// team 0 always sees everything
	if(game_state == GAME.EDITOR)
		this.seenBy[0] = BUILDING_STATE.NORMAL;
	
	// making units stuff
	this.queue = []; // references to the unit types that are in production
	this.autocast = this.initAutocast(); // ids of abilities that are on autocast
	
	this.abilityLevels = new Array(game.commands.length);
	this.lastTickAbilityUsed = new Array(game.commands.length);
	for(var i = 0; i < game.commands.length; i++)
	{
		this.lastTickAbilityUsed[i] = -9999;
		this.abilityLevels[i] = (game.commands[i] && game.commands[i].requiredLevels && game.commands[i].requiredLevels.length > 0) ? 0 : 1;
	}
	
	this.pos = new Field(this.x - 1 + this.type.size / 2, this.y - 1 + this.type.size / 2, true); // the position of a building (or doodad) = center
	this.drawPos = this.pos.add3(0, -game.getHMValue2(this.x, this.y) * CLIFF_HEIGHT); // all map object need a draw pos. Its not gameplay relevant, but only used for drawing. For units this is interpolated between this and last ticks real pos, so the movement is smooth. For buildings and doodads ist just static
	
	// in case of gold mine, store gold value
	if(this.type.startGold)
		this.gold = this.type.startGold;
	
	// dummys are used, when you place a building and the transparent building is drawn while the worker moves to the location
	if(!this.isDummy)
	{
		this.switchBlocking(true, this.dontRefreshNBs); // mark the fields in the grid as blocked
		this.id = game.global_id++; // ids are used to identify the building in network games
		
		if(this.type.lifetime)
			this.lifetime = this.type.lifetime;
	}
	
	this.yDrawingOffset = this.pos.py + this.type.size / 2;
	game.addObject(this);

	// editor clipboard for undo
	if(game_state == GAME.EDITOR && data.noHistory != true)
			editor.clipboard.history.addObject(this);
	
	// if building is beeing constructed (when made in game and not on map load)
	if(this.buildFirst)
	{
		this.buildTicksLeft = this.type.buildTime;
		this.hp *= BUILDING_START_HP_PERCENTAGE;
		
		if(PLAYING_PLAYER.team.canSeeUnit(this))
		{
			this.massSmoke();
			soundManager.playSound(SOUND.BUILD, this.pos, 0.5);
		}
		
		this.owner.startProduction(this.type, this);
	}
	
	this.borderLeft = this.drawPos.px - this.type.size / 2;
	this.borderRight = this.drawPos.px + this.type.size / 2;
	this.borderTop = this.drawPos.py - this.type.size / 2;
	this.borderBottom = this.drawPos.py + this.type.size / 2;
	
	this.lastRepairedTick = -1; // if this building is under construction, this is set to the current tick, when the constucting worker (whos technically repairing it), gets updated; all other repairing workers will use repair stats then in stead of construction stats
	
	this.targetsQueue = [];
	this.modifiers = [];
	this.modifierMods = {};
	this.disabledCommands = {};
	
	this.effectsToDraw = []; // if this unit has modifiers for example, that make effect, the effects are attached here
	
	this.initHPAndMana();
};

Building.prototype.refreshImg = function()
{
	this.img = this.type.img;
};

Building.prototype.massSmoke = function()
{
	for(var i = 0; i < 12; i++)
		new Dust({from: this.drawPos.add2(Math.random() * Math.PI * 2, this.type.size / 1.5)});
};

// return true if building / tile is inside a drawn box on the screen
Building.prototype.isInBox = function(x1, y1, x2, y2)
{
	return this.borderRight >= x1 && this.borderBottom >= y1 && this.borderLeft <= x2 && this.borderTop <= y2;
};

Building.prototype.getWorkload = function()
{
	return Math.min(Math.ceil((this.workload_total / 400) * 100), 100);
};

// determinates the z index when drawing; when building is dying atm, return a lower z index, so the building does not overlap with the explosion effect
Building.prototype.getYDrawingOffset = function()
{
	return this.yDrawingOffset;
};

Building.prototype.draw = function()
{
	// if ourside of visible bounds, return, because we dont need to draw anything
	if((!this.seenBy[PLAYING_PLAYER.team.number] && !this.isDummy) || this.getValue("noShow"))
		return
	
	c.globalAlpha = this.isDummy ? 0.4 : 1;
	
	var state = this.seenBy[PLAYING_PLAYER.team.number];
	var canSeeNow = PLAYING_PLAYER.team.canSeeUnit(this, true);
	var img = this.seenByAsBuildingType[PLAYING_PLAYER.team.number] ? this.seenByAsBuildingType[PLAYING_PLAYER.team.number].img : this.type.img;
	var scale = this.getValue("imageScale") * SCALE_FACTOR;
	var x = 0;
	var y = 0;
	var w = 0;
	var h = 0;
	
	if(state == BUILDING_STATE.UNDER_CONSTRUCTION && img.constructionImg)
	{
		var frame = img.constructionImg.frame ? Math.min(img.constructionImg.frame[ticksCounter % img.constructionImg.frame.length], parseInt(img.constructionImg.w / img.constructionImg.frameWidth) - 1) : 0;
		x = img.constructionImg.x + frame * img.constructionImg.frameWidth;
		y = img.constructionImg.y;
		w = img.constructionImg.frameWidth;
		h = img.constructionImg.h;
	}
	
	else if(state == BUILDING_STATE.DEAD)
		return;
	
	else if(state == BUILDING_STATE.BUSY && img.busyImgs)
	{
		var frame = (canSeeNow && img.busyImgs.frames) ? Math.min(img.busyImgs.frames[ticksCounter % img.busyImgs.frames.length], parseInt(img.busyImgs.w / img.busyImgs.frameWidth) - 1) : 0;
		x = img.busyImgs.x + frame * img.busyImgs.frameWidth;
		y = img.busyImgs.y;
		w = img.busyImgs.frameWidth;
		h = img.busyImgs.h;
	}
	
	else if(state == BUILDING_STATE.BUSY_DAMAGED && img.busyDamagedImgs)
	{
		var frame = (canSeeNow && img.busyDamagedImgs.frames) ? Math.min(img.busyDamagedImgs.frames[ticksCounter % img.busyDamagedImgs.frames.length], parseInt(img.busyDamagedImgs.w / img.busyDamagedImgs.frameWidth) - 1) : 0;
		x = img.busyDamagedImgs.x + frame * img.busyDamagedImgs.frameWidth;
		y = img.busyDamagedImgs.y;
		w = img.busyDamagedImgs.frameWidth;
		h = img.busyDamagedImgs.h;
	}
	
	else if(state == BUILDING_STATE.UPGRADING && img.upgradeImg)
	{
		var frame = img.upgradeImg.frames ? Math.min(img.upgradeImg.frames[ticksCounter % img.upgradeImg.frames.length], parseInt(img.upgradeImg.w / img.upgradeImg.frameWidth) - 1) : 0;
		x = img.upgradeImg.x + frame * img.upgradeImg.frameWidth;
		y = img.upgradeImg.y;
		w = img.upgradeImg.frameWidth;
		h = img.upgradeImg.h;
	}
	
	else if(state == BUILDING_STATE.UPGRADING_DAMAGED && img.upgradeImgDamaged)
	{
		var frame = img.upgradeImgDamaged.frames ? Math.min(img.upgradeImgDamaged.frames[ticksCounter % img.upgradeImgDamaged.frames.length], parseInt(img.upgradeImgDamaged.w / img.upgradeImgDamaged.frameWidth) - 1) : 0;
		x = img.upgradeImgDamaged.x + frame * img.upgradeImgDamaged.frameWidth;
		y = img.upgradeImgDamaged.y;
		w = img.upgradeImgDamaged.frameWidth;
		h = img.upgradeImgDamaged.h;
	}
	
	else if(state == BUILDING_STATE.DAMAGED && img.damagedImg)
	{
		var frame = img.damagedImg.frames ? Math.min(img.damagedImg.frames[ticksCounter % img.damagedImg.frames.length], parseInt(img.damagedImg.w / img.damagedImg.frameWidth) - 1) : 0;
		x = img.damagedImg.x + frame * img.damagedImg.frameWidth;
		y = img.damagedImg.y;
		w = img.damagedImg.frameWidth;
		h = img.damagedImg.h;
	}
	
	// if mine and empty
	else if(state == BUILDING_STATE.EMPTY && img.imgEmpty)
	{
		var frame = img.imgEmpty.frames ? Math.min(img.imgEmpty.frames[ticksCounter % img.imgEmpty.frames.length], parseInt(img.imgEmpty.w / img.imgEmpty.frameWidth) - 1) : 0;
		x = img.imgEmpty.x + frame * img.imgEmpty.frameWidth;
		y = img.imgEmpty.y;
		w = img.imgEmpty.frameWidth;
		h = img.imgEmpty.h;
	}
	
	else // normal
	{
		var frame = img.img.frames ? Math.min(img.img.frames[ticksCounter % img.img.frames.length], parseInt(img.img.w / img.img.frameWidth) - 1) : 0;
		x = img.img.x + frame * img.img.frameWidth;
		y = img.img.y;
		w = img.img.frameWidth;
		h = img.img.h;
	}
	
	if((state == BUILDING_STATE.BUSY || state == BUILDING_STATE.BUSY_DAMAGED) && canSeeNow && this.type.busySmokeEffectLocationX && tickDiff > 0 && ticksCounter % 10 == 0)
		new Dust({from: this.drawPos.add3(this.type.busySmokeEffectLocationX, this.type.busySmokeEffectLocationY), scale: 2, ageScale: 2, height: this.type.busySmokeEffectLocationZ});
	
	var target_x = this.drawPos.px * FIELD_SIZE - w * scale / 2 - game.cameraX;
	var target_y = (this.drawPos.py + this.type.size / 2) * FIELD_SIZE - h * scale - game.cameraY;
	
	// invis alpha
	if(this.getValue("isInvisible"))
		c.globalAlpha = (this.isDetectedUntil >= ticksCounter || !this.owner.isEnemyOfPlayer(PLAYING_PLAYER)) ? 0.5 : 0.07;
	
	c.drawImage(img.file[this.owner.number], x, y, w, h, target_x, target_y, w * scale, h * scale);
	
	if(!this.isDummy && this.getValue("hasDetection") && !this.isUnderConstruction)
		this.drawEye();
	
	c.globalAlpha = 1;
	
	if(this.isDummy)
		return;
	
	// create dust effects randomly if under construction
	if((this.lastRepairedTick + 1 >= ticksCounter || state == BUILDING_STATE.UPGRADING || state == BUILDING_STATE.UPGRADING_DAMAGED) && canSeeNow)
		for(var i = 0; i < tickDiff; i++)
			if(Math.random() < 0.15)
				new Dust({from: this.drawPos.add2(Math.random() * Math.PI * 2, Math.random() * this.type.size / 1.7).add3(0, 3), scale: Math.random() + 1.5, height: 3});
};
var searchColors = new Array(11);
var gold = 0;
// searchColors = new Array(18);

// Player Colors (the search colors will get replaced with those)
var playerColors = [
	
	[ // (player 1, red)
		[35, 1, 1],
		[66, 1, 1],
		[67, 11, 8],
		[113, 38, 27],
		[138, 50, 37],
		[161, 60, 46],
		[174, 72, 72],
		[90, 24, 24],
		[123, 45, 45],
		[188, 101, 101],
		[125, 65, 65],
		[185, 25, 25]
	],

	[ // (player 2, blue)
		[1, 5, 35],
		[1, 7, 66],
		[9, 15, 145],
		[38, 45, 194],
		[54, 61, 212],
		[86, 93, 238],
		[72, 84, 174],
		[24, 24, 90],
		[45, 45, 123],
		[101, 101, 188],
		[65, 65, 125],
		[25, 25, 150]
	],

	[ // (player 3, green)
		[1, 35, 1],
		[3, 66, 1],
		[19, 77, 10],
		[36, 116, 23],
		[51, 143, 36],
		[69, 169, 53],
		[86, 174, 72],
		[24, 90, 24],
		[45, 123, 45],
		[101, 188, 101],
		[65, 135, 65],
		[0, 200, 0]
	],

	[ // (player 4, white)
		[30, 30, 30],
		[50, 50, 50],
		[92, 92, 92],
		[187, 187, 187],
		[217, 217, 217],
		[239, 239, 239],
		[225, 225, 225],
		[80, 80, 80],
		[150, 150, 150],
		[200, 200, 200],
		[205, 205, 205],
		[255, 255, 255]
	],

	[ // (player 5, black)
		[1, 1, 1],
		[5, 5, 5],
		[19, 19, 19],
		[36, 36, 36],
		[51, 51, 51],
		[69, 69, 69],
		[86, 86, 86],
		[24, 24, 24],
		[45, 45, 45],
		[101, 101, 101],
		[65, 65, 65],
		[0, 0, 0]
	],

	[ // (player 6, yellow)
		[35, 35, 1],
		[66, 66, 1],
		[77, 77, 10],
		[116, 116, 23],
		[143, 143, 36],
		[169, 169, 53],
		[174, 174, 72],
		[90, 90, 24],
		[123, 123, 45],
		[188, 188, 101],
		[135, 135, 65],
		[200, 200, 0]
	]
];

var playerTextColors = [
	[204, 204, 204],
	[255, 100, 100],
	[153, 153, 255],
	[153, 255, 153],
	[255, 255, 255],
	[100, 100, 100],
	[255, 255, 100]
];



var unit_imgs = {
	
	soldier: {
		file: loadImage("imgs/units/soldier.png"),
		_angles: 8,
		idle: {x: 0, y: 0, w: 64, h: 256, frameWidth: 32},
		walk: {x: 64, y: 0, w: 256, h: 256, frameWidth: 32},
		die: {x: 672, y: 0, w: 256, h: 256, frameWidth: 32},
		attack: {x: 320, y: 0, w: 352, h: 256, frameWidth: 32},
		dance1: {x: 0, y: 256, w: 992, h: 32, frameWidth: 32},
		dance2: {x: 0, y: 285, w: 256, h: 32, frameWidth: 32},
		name: "soldier"
	},
	
	soldierS1: {
		file: loadImage("imgs/units/soldierS1.png"),
		_angles: 8,
		idle: {x: 0, y: 0, w: 64, h: 256, frameWidth: 32},
		walk: {x: 64, y: 0, w: 256, h: 256, frameWidth: 32},
		die: {x: 672, y: 0, w: 256, h: 256, frameWidth: 32},
		attack: {x: 320, y: 0, w: 352, h: 256, frameWidth: 32},
		dance1: {x: 0, y: 256, w: 992, h: 32, frameWidth: 32},
		dance2: {x: 0, y: 285, w: 256, h: 32, frameWidth: 32},
		name: "soldierS1",
		isSkin: true
	},
	
	soldierS2: {
		file: loadImage("imgs/units/soldierS2.png"),
		_angles: 8,
		idle: {x: 0, y: 0, w: 64, h: 256, frameWidth: 32},
		walk: {x: 64, y: 0, w: 256, h: 256, frameWidth: 32},
		die: {x: 672, y: 0, w: 256, h: 256, frameWidth: 32},
		attack: {x: 320, y: 0, w: 352, h: 256, frameWidth: 32},
		dance1: {x: 0, y: 256, w: 992, h: 32, frameWidth: 32},
		dance2: {x: 0, y: 285, w: 256, h: 32, frameWidth: 32},
		name: "soldierS2",
		isSkin: true
	},
	
	skeleton: {
		file: loadImage("imgs/units/skeletton.png"),
		_angles: 4,
		idle: {x: 0, y: 0, w: 72, h: 80, frameWidth: 18},
		walk: {x: 75, y: 0, w: 144, h: 80, frameWidth: 18},
		die: {x: 0, y: 87, w: 144, h: 80, frameWidth: 18},
		attack: {x: 148, y: 87, w: 160, h: 80, frameWidth: 20},
		special1: {x: 219, y: 0, w: 90, h: 80, frameWidth: 18},
		name: "skeleton"
	},
	
	archer: {
		file: loadImage("imgs/units/archer.png"),
		_angles: 8,
		idle: {x: 0, y: 0, w: 64, h: 256, frameWidth: 32},
		walk: {x: 64, y: 0, w: 256, h: 256, frameWidth: 32},
		die: {x: 704, y: 0, w: 256, h: 256, frameWidth: 32},
		attack: {x: 320, y: 0, w: 384, h: 256, frameWidth: 32},
		name: "archer"
	},
	
	archerS1: {
		file: loadImage("imgs/units/archerS1.png"),
		_angles: 8,
		idle: {x: 0, y: 0, w: 64, h: 256, frameWidth: 32},
		walk: {x: 64, y: 0, w: 256, h: 256, frameWidth: 32},
		die: {x: 704, y: 0, w: 256, h: 256, frameWidth: 32},
		attack: {x: 320, y: 0, w: 384, h: 256, frameWidth: 32},
		name: "archerS1",
		isSkin: true
	},
	
	rifleman: {
		file: loadImage("imgs/units/rifleman_old.png"),
		_angles: 4,
		idle: {x: 0, y: 0, w: 44, h: 80, frameWidth: 22},
		walk: {x: 51, y: 0, w: 176, h: 80, frameWidth: 22},
		die: {x: 0, y: 87, w: 176, h: 80, frameWidth: 22},
		attack: {x: 187, y: 87, w: 132, h: 80, frameWidth: 22},
		name: "rifleman"
	},
	
	worker: {
		file: loadImage("imgs/units/worker.png"),
		_angles: 8,
		idle: {x: 0, y: 0, w: 64, h: 256, frameWidth: 32},
		walk: {x: 64, y: 0, w: 256, h: 256, frameWidth: 32},
		walkGold: {x: 320, y: 0, w: 256, h: 256, frameWidth: 32},
		die: {x: 768, y: 0, w: 256, h: 256, frameWidth: 32},
		attack: {x: 576, y: 0, w: 192, h: 256, frameWidth: 32},
		dance1: {x: 0, y: 256, w: 864, h: 32, frameWidth: 18},
		name: "worker"
	},
	
	worker_christmas: {
		file: loadImage("imgs/units/worker_christmas.png"),
		_angles: 8,
		idle: {x: 0, y: 0, w: 64, h: 256, frameWidth: 32},
		walk: {x: 64, y: 0, w: 256, h: 256, frameWidth: 32},
		walkGold: {x: 320, y: 0, w: 256, h: 256, frameWidth: 32},
		die: {x: 768, y: 0, w: 256, h: 256, frameWidth: 32},
		attack: {x: 576, y: 0, w: 192, h: 256, frameWidth: 32},
		dance1: {x: 0, y: 256, w: 864, h: 32, frameWidth: 18},
		name: "worker christmas"
	},
	
	workerS1: {
		file: loadImage("imgs/units/workerS1.png"),
		_angles: 8,
		idle: {x: 0, y: 0, w: 64, h: 256, frameWidth: 32},
		walk: {x: 64, y: 0, w: 256, h: 256, frameWidth: 32},
		walkGold: {x: 320, y: 0, w: 256, h: 256, frameWidth: 32},
		die: {x: 768, y: 0, w: 256, h: 256, frameWidth: 32},
		attack: {x: 576, y: 0, w: 192, h: 256, frameWidth: 32},
		dance1: {x: 0, y: 256, w: 864, h: 32, frameWidth: 18},
		name: "workerS1",
		isSkin: true
	},
	
	workerS2: {
		file: loadImage("imgs/units/workerS2.png"),
		_angles: 8,
		idle: {x: 0, y: 0, w: 64, h: 256, frameWidth: 32},
		walk: {x: 64, y: 0, w: 256, h: 256, frameWidth: 32},
		walkGold: {x: 320, y: 0, w: 256, h: 256, frameWidth: 32},
		die: {x: 768, y: 0, w: 256, h: 256, frameWidth: 32},
		attack: {x: 576, y: 0, w: 192, h: 256, frameWidth: 32},
		dance1: {x: 0, y: 256, w: 864, h: 32, frameWidth: 18},
		name: "workerS2",
		isSkin: true
	},
	
	mage: {
		file: loadImage("imgs/units/mage.png"),
		_angles: 8,
		idle: {x: 0, y: 0, w: 64, h: 256, frameWidth: 32},
		walk: {x: 64, y: 0, w: 256, h: 256, frameWidth: 32},
		die: {x: 608, y: 0, w: 256, h: 256, frameWidth: 32},
		attack: {x: 320, y: 0, w: 288, h: 256, frameWidth: 32},
		name: "mage"
	},
	
	mageS1: {
		file: loadImage("imgs/units/mageS1.png"),
		_angles: 8,
		idle: {x: 0, y: 0, w: 64, h: 256, frameWidth: 32},
		walk: {x: 64, y: 0, w: 256, h: 256, frameWidth: 32},
		die: {x: 608, y: 0, w: 256, h: 256, frameWidth: 32},
		attack: {x: 320, y: 0, w: 288, h: 256, frameWidth: 32},
		name: "mageS1",
		isSkin: true
	},
	
	priest: {
		file: loadImage("imgs/units/priest.png"),
		_angles: 8,
		idle: {x: 0, y: 0, w: 96, h: 256, frameWidth: 32},
		walk: {x: 96, y: 0, w: 256, h: 256, frameWidth: 32},
		die: {x: 544, y: 0, w: 256, h: 256, frameWidth: 32},
		attack: {x: 352, y: 0, w: 192, h: 256, frameWidth: 32},
		name: "priest"
	},
	
	catapult: {
		file: loadImage("imgs/units/catapult.png"),
		_angles: 8,
		idle: {x: 0, y: 0, w: 40, h: 264, frameWidth: 40},
		walk: {x: 43, y: 0, w: 160, h: 264, frameWidth: 40},
		die: {x: 233, y: 0, w: 357, h: 264, frameWidth: 51},
		attack: {x: 0, y: 279, w: 722, h: 328, frameWidth: 38},
		name: "catapult"
	},
	
	dragon: {
		file: loadImage("imgs/units/dragon.png"),
		_angles: 8,
		walk: {x: 0, y: 0, w: 720, h: 960, frameWidth: 120},
		die: {x: 720, y: 0, w: 1920, h: 960, frameWidth: 120},
		name: "dragon"
	},
	
	wolf: {
		file: loadImage("imgs/units/wolf.png"),
		_angles: 4,
		idle: {x: 0, y: 0, w: 60, h: 120, frameWidth: 30},
		walk: {x: 121, y: 0, w: 180, h: 120, frameWidth: 30},
		die: {x: 181, y: 121, w: 150, h: 120, frameWidth: 30},
		attack: {x: 0, y: 120, w: 180, h: 120, frameWidth: 30},
		name: "wolf"
	},
	
	bird: {
		file: loadImage("imgs/units/bird.png"),
		_angles: 8,
		walk: {x: 0, y: 0, w: 192, h: 572, frameWidth: 32},
		die: {x: 192, y: 0, w: 256, h: 572, frameWidth: 32},
		name: "bird"
	},
	
	airship: {
		file: loadImage("imgs/units/zeppelin.png"),
		_angles: 8,
		walk: {x: 0, y: 0, w: 800, h: 1120, frameWidth: 100},
		die: {x: 800, y: 0, w: 800, h: 1120, frameWidth: 100},
		name: "airship"
	},
	
	werewolf: {
		file: loadImage("imgs/units/beast.png"),
		_angles: 4,
		idle: {x: 623, y: 824, w: 267, h: 232, frameWidth: 89},
		walk: {x: 0, y: 296, w: 712, h: 232, frameWidth: 89},
		die: {x: 0, y: 824, w: 623, h: 232, frameWidth: 89},
		attack: {x: 0, y: 528, w: 623, h: 296, frameWidth: 89},
		special1: {x: 0, y: 0, w: 712, h: 296, frameWidth: 89},
		name: "werewolf"
	},
	
	ballista: {
		file: loadImage("imgs/units/ballista.png"),
		_angles: 8,
		idle: {x: 0, y: 0, w: 66, h: 416, frameWidth: 66},
		walk: {x: 0, y: 0, w: 264, h: 416, frameWidth: 66},
		die: {x: 264, y: 0, w: 330, h: 416, frameWidth: 66},
		attack: {x: 594, y: 0, w: 660, h: 416, frameWidth: 66},
		name: "ballista"
	},
	
	totem: {
		file: loadImage("imgs/units/totem.png"),
		_angles: 1,
		idle: {x: 0, y: 0, w: 88, h: 30, frameWidth: 22},
		walk: {x: 0, y: 0, w: 88, h: 30, frameWidth: 22},
		die: {x: 0, y: 30, w: 324, h: 47, frameWidth: 54},
		special1: {x: 88, y: 0, w: 154, h: 30, frameWidth: 22},
		name: "totem"
	}
	
};

var building_imgs = {
	
	castle: {
		img: {x: 0, y: 0, w: 76, h: 92, frameWidth: 76},
		constructionImg: {x: 80, y: 13, w: 75, h: 78, frameWidth: 76},
		damagedImg: {x: 158, y: 0, w: 76, h: 92, frameWidth: 76},
		busyImgs: {x: 235, y: 0, w: 152, h: 92, frameWidth: 76, frames: [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1]},
		busyDamagedImgs: {x: 188, y: 378, w: 152, h: 92, frameWidth: 76, frames: [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1]},
		upgradeImg: {x: 2, y: 596, w: 76, h: 92, frameWidth: 76},
		upgradeImgDamaged: {x: 80, y: 596, w: 76, h: 92, frameWidth: 76}
	},
	
	barracks: {
		img: {x: 539, y: 160, w: 61, h: 79, frameWidth: 61},
		constructionImg: {x: 417, y: 174, w: 60, h: 64, frameWidth: 60},
		damagedImg: {x: 478, y: 160, w: 61, h: 79, frameWidth: 61},
		busyImgs: {x: 478, y: 318, w: 122, h: 79, frameWidth: 61, frames: [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1]},
		busyDamagedImgs: {x: 478, y: 239, w: 122, h: 79, frameWidth: 61, frames: [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1]}
	},
	
	watchtower: {
		img: {x: 2, y: 190, w: 43, h: 71, frameWidth: 43},
		constructionImg: {x: 46, y: 216, w: 43, h: 46, frameWidth: 43},
		damagedImg: {x: 90, y: 191, w: 43, h: 71, frameWidth: 43}
	},
	
	house: {
		img: {x: 538, y: 0, w: 62, h: 73, frameWidth: 62},
		constructionImg: {x: 478, y: 17, w: 58, h: 56, frameWidth: 62},
		damagedImg: {x: 417, y: 3, w: 59, h: 69, frameWidth: 62}
	},
	
	mine: {
		img: {x: 3, y: 265, w: 60, h: 82, frameWidth: 60},
		imgEmpty: {x: 127, y: 265, w: 60, h: 82, frameWidth: 60}
	},
	
	mages_guild: {
		img: {x: 1, y: 353, w: 60, h: 76, frameWidth: 60},
		constructionImg: {x: 63, y: 369, w: 58, h: 60, frameWidth: 58},
		damagedImg: {x: 123, y: 354, w: 60, h: 76, frameWidth: 60},
		busyImgs: {x: 1, y: 434, w: 120, h: 76, frameWidth: 60, frames: [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1]},
		busyDamagedImgs: {x: 1, y: 514, w: 120, h: 76, frameWidth: 60, frames: [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1]}
	},
	
	workshop: {
		img: {x: 4, y: 94, w: 72, h: 92, frameWidth: 72},
		constructionImg: {x: 77, y: 101, w: 77, h: 85, frameWidth: 77},
		damagedImg: {x: 157, y: 93, w: 72, h: 92, frameWidth: 72},
		busyImgs: {x: 237, y: 93, w: 144, h: 92, frameWidth: 72, frames: [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1]},
		busyDamagedImgs: {x: 196, y: 283, w: 144, h: 92, frameWidth: 72, frames: [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1]}
	},
	
	forge: {
		img: {x: 548, y: 81, w: 84, h: 76, frameWidth: 84},
		constructionImg: {x: 482, y: 90, w: 66, h: 69, frameWidth: 66},
		damagedImg: {x: 395, y: 82, w: 84, h: 76, frameWidth: 84},
		busyImgs: {x: 431, y: 404, w: 168, h: 76, frameWidth: 84, frames: [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1]},
		busyDamagedImgs: {x: 135, y: 190, w: 168, h: 76, frameWidth: 84, frames: [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1]}
	},
	
	start_location: {
		img: {x: 351, y: 405, w: 66, h: 55, frameWidth: 66}
	},
	
	fortress: {
		img: {x: 128, y: 480, w: 76, h: 110, frameWidth: 76},
		damagedImg: {x: 204, y: 480, w: 76, h: 110, frameWidth: 76},
		busyImgs: {x: 280, y: 480, w: 152, h: 110, frameWidth: 76, frames: [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1]},
		busyDamagedImgs: {x: 432, y: 480, w: 152, h: 110, frameWidth: 76, frames: [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1]}
	},
	
	dragons_lair: {
		img: {x: 228, y: 595, w: 62, h: 93, frameWidth: 62},
		constructionImg: {x: 169, y: 644, w: 52, h: 44, frameWidth: 52},
		damagedImg: {x: 295, y: 595, w: 62, h: 93, frameWidth: 62},
		busyImgs: {x: 363, y: 595, w: 62, h: 93, frameWidth: 62, frames: [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1]},
		busyDamagedImgs: {x: 432, y: 595, w: 62, h: 93, frameWidth: 62, frames: [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1]}
	},
	
	wolves_den: {
		img: {x: 3, y: 697, w: 65, h: 65, frameWidth: 65},
		constructionImg: {x: 71, y: 697, w: 65, h: 65, frameWidth: 65},
		damagedImg: {x: 277, y: 697, w: 65, h: 65, frameWidth: 65},
		busyImgs: {x: 139, y: 697, w: 130, h: 65, frameWidth: 65, frames: [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1]},
		busyDamagedImgs: {x: 347, y: 697, w: 130, h: 65, frameWidth: 65, frames: [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1]},
		upgradeImg: {x: 417, y: 866, w: 65, h: 72, frameWidth: 65},
		upgradeImgDamaged: {x: 485, y: 866, w: 65, h: 72, frameWidth: 65}
	},
	
	animal_testing_lab: {
		img: {x: 5, y: 770, w: 77, h: 86, frameWidth: 77},
		constructionImg: {x: 87, y: 777, w: 70, h: 79, frameWidth: 70},
		damagedImg: {x: 317, y: 770, w: 77, h: 86, frameWidth: 77},
		busyImgs: {x: 160, y: 770, w: 154, h: 86, frameWidth: 77, frames: [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1]},
		busyDamagedImgs: {x: 395, y: 770, w: 154, h: 86, frameWidth: 77, frames: [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1]}
	},
	
	adv_workshop: {
		img: {x: 640, y: 2, w: 84, h: 126, frameWidth: 84},
		constructionImg: {x: 641, y: 265, w: 84, h: 82, frameWidth: 84},
		damagedImg: {x: 640, y: 133, w: 84, h: 126, frameWidth: 84},
		busyImgs: {x: 640, y: 2, w: 252, h: 126, frameWidth: 84, frames: [0, 0, 0, 1, 1, 1, 2, 2, 2]},
		busyDamagedImgs: {x: 640, y: 133, w: 252, h: 126, frameWidth: 84, frames: [0, 0, 0, 1, 1, 1, 2, 2, 2]}
	},
	
	werewolves_den: {
		img: {x: 3, y: 866, w: 65, h: 72, frameWidth: 65},
		damagedImg: {x: 208, y: 866, w: 65, h: 72, frameWidth: 65},
		busyImgs: {x: 71, y: 866, w: 130, h: 72, frameWidth: 65, frames: [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1]},
		busyDamagedImgs: {x: 277, y: 866, w: 130, h: 72, frameWidth: 65, frames: [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1]}
	},
	
	church: {
		img: {x: 4, y: 943, w: 74, h: 103, frameWidth: 74},
		constructionImg: {x: 472, y: 965, w: 78, h: 81, frameWidth: 78},
		damagedImg: {x: 82, y: 943, w: 74, h: 103, frameWidth: 74},
		busyImgs: {x: 159, y: 943, w: 148, h: 103, frameWidth: 74, frames: [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1]},
		busyDamagedImgs: {x: 316, y: 943, w: 148, h: 103, frameWidth: 74, frames: [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1]}
	}
};


function fadeIn(jQueryElement)
{
	if(jQueryElement[0].style.display == "inline")
		return;
	
	jQueryElement[0].style.display = "inline";
	
	jQueryElement.css({
		opacity: 0,
		top: (parseInt(jQueryElement.css("top")) - 30) + "px"
	}).animate({
		opacity: 1,
		top: (parseInt(jQueryElement.css("top")) + 30) + "px"
	}, 200);
};

function fadeOut(jQueryElement)
{
	if(jQueryElement[0].style.display == "none")
		return;
	
	jQueryElement[0].style.display = "inline";
	
	jQueryElement.css({
		opacity: 1
	}).animate({
		opacity: 0,
		top: (parseInt(jQueryElement.css("top")) + 30) + "px"
	}, 200, function(){
		jQueryElement.css({
			display: "none",
			top: (parseInt(jQueryElement.css("top")) - 30) + "px"
		});
	});
	
	if(jQueryElement.attr('id') == "infoWindow2")
		fadeOut($('#darkScreenDiv'));
};

function addToChatWindow(p)
{
	var chatWindow = network.game.id ? $('#lobbyGameChatTextArea')[0] : $('#lobbyChatTextArea')[0];
	
	chatWindow.appendChild(p);
	
	if(chatWindow.scrollTop + chatWindow.offsetHeight >= chatWindow.scrollHeight - 250)
		chatWindow.scrollTop = chatWindow.scrollHeight;
};

function checkMapSettingInputs()
{
	$("#maxSupplyInput")[0].value = Math.min(Math.max(0, toInt($("#maxSupplyInput")[0].value)), 200);
	$("#startGoldInput")[0].value = Math.min(Math.max(0, toInt($("#startGoldInput")[0].value)), 999999);
	$("#mineDistInput")[0].value = Math.min(Math.max(0, toInt($("#mineDistInput")[0].value)), 999999);
};

// calculate the build time in ticks for all unit types and upgrade types
function calculateTypesTickValues()
{
	var types_ = game.buildingTypes.concat(game.unitTypes);
	for(var i = 0; i < types_.length; i++)
	{
		var t = types_[i];
		t.radius = t.size / 2;
		
		// if unit
		if(t.movementSpeed >= 0)
		{
			// calculate circle offsets depending on the radius (is used to check if a unit collides with a static object)
			t.circleOffsets = [];
			for(k = 0; k < checkAngles.length; k++)
			{
				var field = new Field(checkAngles[k][0], checkAngles[k][1], true).normalize(t.radius);
				t.circleOffsets.push([field.px, field.py]);
			}
		}
		
		if(t.size)
		{
			t.sizeX = t.size;
			t.sizeY = t.size;
		}
	}
};


var fogMaskAlpha = [
	0.75,
	0.5,
	0
];

var darkFogMaskAlpha = [
	1,
	0.6,
	0
];



AUTH_LEVEL = Object.freeze({
	NONE: 0,
	GUEST: 1,
	PLAYER: 2,
	MOD: 3,
	ADMIN: 4
});

var auth_level_css_classes = [
	"",
	"playerLinkGuest",
	"playerLinkRegistered",
	"playerLinkMod",
	"playerLinkAdmin"
];

var clan_member_role_names = [
	"",
	"moderator",
	"admin"
];

OPEN_QUERIES = Object.freeze({
	ALWAYS: 0,
	NEVER: 1,
	NOT_INGAME: 2
});

var GAME = Object.freeze({
	LOGIN: 0,
	REGISTER: 1,
	PLAYING: 3,
	SKIRMISH: 4,
	EDITOR: 5,
	LOBBY: 6,
	RECOVERY: 8,
	ACCEPT_AGB: 9
});

var game_speeds = [
	{caption: "1/2x", tick_time: 100},
	{caption: "1x", tick_time: 50},
	{caption: "2x", tick_time: 25},
	{caption: "4x", tick_time: 13},
	{caption: "8x", tick_time: 7},
	{caption: "16x", tick_time: 4}
];

var game_state = GAME.LOGIN;

function initHotkeyWindow()
{
	$('#customHotkeysWindowSubdiv').html("");
	
	var div = document.createElement("div");
	div.innerHTML = "<br />Commands<br /><br />";
	div.className = "hotkeyHeadline";
	$('#customHotkeysWindowSubdiv').append(div);
	
	// commands
	var units = basicBuildingTypes.concat(basicUnitTypes);
	var commandObj = {};
	for(var i = 0; i < basicCommands.length; i++)
	{
		var cmd = basicCommands[i];
		if(cmd.hotkey)
		{
			var catName = "";
			
			for(var k = 0; k < units.length; k++)
				if((units[k].commands && units[k].commands[cmd.id_string]) || cmd.type == COMMAND.CANCEL)
				{
					var name = units[k].name;
					
					if(units[k].name == "Castle" || units[k].name == "Fortress")
						name = "Castle / Fortress";
					
					if(units[k].name == "Wolves Den" || units[k].name == "Werewolves Den")
						name = "Wolves Den / Werewolves Den";
						
					
					if(catName == "" || catName == name)
						catName = name;
					
					else
					{
						catName = "General";
						k = units.length;
					}
				}
			
			if(catName != "")
			{
				if(commandObj[catName])
					commandObj[catName].push(cmd);
				else
					commandObj[catName] = [cmd];
			}
		}
	}
	
	_.each(commandObj, function(commands, name){
		var div = document.createElement("div");
		div.innerHTML = name;
		
		$('#customHotkeysWindowSubdiv').append(div);
		div.className = "hotkeySectionTitle";
		
		for(var i = 0; i < commands.length; i++)
		{
			var cmd = commands[i];
			
			var index = 0;
			for(var j = 0; j < basicCommands.length; j++)
				if(basicCommands[j] == cmd)
					index = j;
			
			var p = document.createElement("p");
			p.innerHTML = cmd.name + " ";
			$('#customHotkeysWindowSubdiv').append(p);
			
			var b = document.createElement("button");
			b.innerHTML = getKeyName(cmd.hotkey);
			b.className = "hotkeyButton";
			b.id = "cmd_" + index;
			p.appendChild(b);
			
			b.onclick = function()
			{
				resetAllHotkeyButtons();
				
				this.active_ = true;
				this.className = "hotkeyButtonActive";
				soundManager.playSound(SOUND.CLICK);
			};
		}
	});
	
	div = document.createElement("div");
	div.innerHTML = "<br /><br />Control Groups (set with [ctrl] + [key], add units with [shift] + [key], select with [key])<br /><br />";
	div.className = "hotkeyHeadline";
	$('#customHotkeysWindowSubdiv').append(div);
	
	// ctrl groups
	for(var i = 1; i <= 10; i++)
	{
		var p = document.createElement("p");
		p.innerHTML = "CTRL Group " + i + " ";
		$('#customHotkeysWindowSubdiv').append(p);
		
		var b = document.createElement("button");
		b.innerHTML = getKeyName(getKeyForCtrlGrp(i));
		b.className = "hotkeyButton";
		b.id = "ctrlgrp_" + i;
		p.appendChild(b);
		
		b.onclick = function()
		{
			resetAllHotkeyButtons();
			
			this.active_ = true;
			this.className = "hotkeyButtonActive";
			soundManager.playSound(SOUND.CLICK);
		};
	}
	
	div = document.createElement("div");
	div.innerHTML = "<br /><br />Camera Locations (set with [ctrl] + [key] or [shift] + [key], move to location with [key])<br /><br />";
	div.className = "hotkeyHeadline";
	$('#customHotkeysWindowSubdiv').append(div);
	
	// camera location hotkeys
	for(var i = 1; i <= 6; i++)
	{
		var p = document.createElement("p");
		p.innerHTML = "Camera Location " + i + " ";
		$('#customHotkeysWindowSubdiv').append(p);
		
		var b = document.createElement("button");
		b.innerHTML = getKeyName(getKeyForCamHotkey(i));
		b.className = "hotkeyButton";
		b.id = "camkey_" + i;
		p.appendChild(b);
		
		b.onclick = function()
		{
			resetAllHotkeyButtons();
			
			this.active_ = true;
			this.className = "hotkeyButtonActive";
			soundManager.playSound(SOUND.CLICK);
		};
	}
	
	div = document.createElement("div");
	div.innerHTML = "<br /><br />Spectator Hotkeys<br /><br />";
	div.className = "hotkeyHeadline";
	$('#customHotkeysWindowSubdiv').append(div);
	
	// obs hotkeys
	for(var i = 0; i < obsKeys.length; i++)
	{
		var p = document.createElement("p");
		p.innerHTML = obsAbilityNames[i] + " ";
		$('#customHotkeysWindowSubdiv').append(p);
		
		var b = document.createElement("button");
		b.innerHTML = getKeyName(obsKeys[i]);
		b.className = "hotkeyButton";
		b.id = "obsKey_" + i;
		p.appendChild(b);
		
		b.onclick = function()
		{
			resetAllHotkeyButtons();
			
			this.active_ = true;
			this.className = "hotkeyButtonActive";
			soundManager.playSound(SOUND.CLICK);
		};
	}
	
	div = document.createElement("div");
	div.innerHTML = "<br /><br />Other Hotkeys<br /><br />";
	div.className = "hotkeyHeadline";
	$('#customHotkeysWindowSubdiv').append(div);
	
	// other hotkeys
	for(var i = 0; i < otherKeys.length; i++)
	{
		var p = document.createElement("p");
		p.innerHTML = otherKeyNames[i] + " ";
		$('#customHotkeysWindowSubdiv').append(p);
		
		var b = document.createElement("button");
		b.innerHTML = getKeyName(otherKeys[i]);
		b.className = "hotkeyButton";
		b.id = "otherKey_" + i;
		p.appendChild(b);
		
		b.onclick = function()
		{
			resetAllHotkeyButtons();
			
			this.active_ = true;
			this.className = "hotkeyButtonActive";
			soundManager.playSound(SOUND.CLICK);
		};
	}
};

function addChatMsg(sender, msg, emotes)
{
	var el = network.players[sender];
	
	var p = document.createElement("p");
	
	var time = document.createElement("span");
	time.className = "time";
	time.innerHTML = getFormattedTime() + " &nbsp;";
	
	var span = document.createElement("span");
	var chatMsg_ = kappa(escapeHtml(msg), emotes);
	
	if(chatMsg_ && chatMsg_.length > 0)
	{
		span.innerHTML = ": " + (sender == "Server" ? msg : chatMsg_);
		
		p.appendChild(time);
		if(el)
			p.appendChild(network.getClanLink(el, true));
		p.appendChild(network.getPlayerLink(el ? el : {name: sender, authLevel: AUTH_LEVEL.GUEST}));
		p.appendChild(span);
		
		addToChatWindow(p);
	}
}

function openQueryWindowFor(player)
{
	soundManager.playSound(SOUND.CLICK);
	
	var found = false;
	
	for(var i = 0; i < uimanager.queries.length; i++)
		if(uimanager.queries[i].name == player)
		{
			uimanager.queries[i].activate();
			uimanager.queries[i].i.focus();
			found = true;
		}
	
	if(!found)
	{
		var q = new Query(player);
		uimanager.queries.push(q);
		q.activate();
		q.i.focus();
	}
};

function getClanList()
{
	network.send("get-clan-list");
};

function getPlayerNavRiders(player)
{
	var str = ""; //"<div id='riders_'>";
	str += "<button onclick='network.send(\"get-player-info<<$" + player + "\"); soundManager.playSound(SOUND.CLICK);'>General</button> ";
	str += "<button onclick='network.send(\"get-ladder-history<<$" + player + "\"); soundManager.playSound(SOUND.CLICK);'>Laddergames</button> ";
	str += "<button onclick='network.send(\"get-player-friends<<$" + player + "\"); soundManager.playSound(SOUND.CLICK);'>Friends</button> ";
	str += "<button onclick='network.send(\"get-player-maps<<$" + player + "\"); soundManager.playSound(SOUND.CLICK);'>Maps</button> ";
	str += "<button onclick='network.send(\"get-player-arch<<$" + player + "\"); soundManager.playSound(SOUND.CLICK);'>Achievements</button>";
	str += "</div><br />";
	return str;
};

function getPlayerTopRiders(player)
{
	var str = "";
	str += (player != networkPlayerName) ? (" <button class='inlineChatButton' title='chat with this player' onclick='startChatWith(\"" + player + "\");'> </button>") : "";
	str += addFriendButton ? (" <button id='inlineFriendButton' title='add this player as a friend' onclick='offerFriendship(\"" + player + "\");'> </button>") : "";
	str += (ignores.contains(player.toLowerCase()) || player == networkPlayerName) ? "" : ("<button id='inlineIgnoreButton' title='ignore this player' onclick='pressIgnoreButton(\"" + player + "\");'>ignore</button>");
	str += (!ignores.contains(player.toLowerCase()) || player == networkPlayerName) ? "" : ("<button id='inlineUnignoreButton' title='unignore this player' onclick='pressUnignoreButton(\"" + player + "\");'>unignore</button>");
	str += ((iAmMod || iAmAdmin) && player != networkPlayerName) ? "<button id='banjaminButton' onclick='reallyBan(\"" + player + "\");'>ban</button>" : "";
	return str;
};

function pressIgnoreButton(player)
{
	network.send("ignore<<$" + player);
	soundManager.playSound(SOUND.CLICK);
	$("<button id='inlineUnignoreButton' title='unignore this player' onclick='pressUnignoreButton(\"" + player + "\");'>unignore</button>").insertAfter('#inlineIgnoreButton');
	$('#inlineIgnoreButton').remove();
}

function pressUnignoreButton(player)
{
	network.send("unignore<<$" + player);
	soundManager.playSound(SOUND.CLICK);
	$("<button id='inlineIgnoreButton' title='ignore this player' onclick='pressIgnoreButton(\"" + player + "\");'>ignore</button>").insertAfter('#inlineUnignoreButton');
	$('#inlineUnignoreButton').remove();
}

function offerFriendship(player)
{
	network.send("add-friend<<$" + player);
	soundManager.playSound(SOUND.CLICK);
	addFriendButton = false;
	$('#inlineFriendButton').remove();
	bingMsg("Friendship request sent");
}

function setNoClan(applicationClanTag)
{
	var str = "You are not in a clan.<br /><br /><br />";
	
	if(applicationClanTag && applicationClanTag.length > 0)
		str += "You are currently applying for joining clan [" + applicationClanTag + "] (<a href='#' class='yellowfont' onclick='network.send(\"cancel-application\"); soundManager.playSound(SOUND.CLICK);'>cancel</a>)";
	else
	{
		str += "Join a clan.<br />Clan tag: [<input type='text' id='joinClanTagInput' maxlength='6' size='6' />]<br /><button onclick='joinClanAttempt(); soundManager.playSound(SOUND.CLICK);'>join</button><br /><br /><br />";
		str += "Create a new clan.<br />Clan tag: [<input type='text' id='createClanTagInput' maxlength='6' size='6' />]";
		str += "<br />Clan name: <input type='text' id='createClanNameInput' maxlength='30' /><br /><button onclick='createClanAttempt(); soundManager.playSound(SOUND.CLICK);'>create</button>";
	}
	
	str += "<br /><br /><br /><button onclick='getClanList(); soundManager.playSound(SOUND.CLICK);'>show all clans</button>";
	
	uimanager.playerInfoWindow.setTitle("<font style='color: rgb(255, 248, 57);'>Your clan</font>");
	$('#addScrollableSubDivTextArea').html(str);
	fadeIn($("#playerInfoWindow"));
};

function editClanName()
{
	soundManager.playSound(SOUND.CLICK);
	$('#clanName').html("<input type='text' id='clanNameInput' value='" + $('#clanName').html() + "' />");
	$('#editClanNameButton')[0].onclick = editClanNameSubmit;
	$('#editClanNameButton').html("set");
};

function editClanNameSubmit()
{
	soundManager.playSound(SOUND.CLICK);
	network.send("change-clan-name<<$" + $('#clanNameInput')[0].value);
};

function getClanRiders()
{
	var str = "<button onclick='network.send(\"request-my-clan-info\"); soundManager.playSound(SOUND.CLICK);'>General</button> ";
	str += "<button onclick='network.send(\"request-my-clan-wall\"); soundManager.playSound(SOUND.CLICK);'>Message Board</button> ";
	str += "<button onclick='getClanList(); soundManager.playSound(SOUND.CLICK);'>show all clans</button> ";
	str += "<button onclick='network.send(\"leave-clan\"); soundManager.playSound(SOUND.CLICK);'>leave clan</button><br /><br />";
	return str;
};

function postClanWall()
{
	soundManager.playSound(SOUND.CLICK);
	network.send("post-clan-wall<<$" + $('#clanWallMsgInput').val());
};

function setClanWall(splitMsg)
{
	var str = "Clan member can post messages here. Only clan members can read them.<br /><br /><textarea id='clanWallMsgInput' maxlength='800'></textarea><br /><button onclick='postClanWall();'>send</button><br /><br />";
	
	for(var i = 2; i < splitMsg.length; i += 4)
	{
		str += getPlayerLink(splitMsg[i]) + " <span class='ladderGameTimeTD'>" + splitMsg[i + 3] + "</span>";
		if(splitMsg[1] > 0)
			str += " <button onclick='network.send(\"kill-ally-msg<<$" + splitMsg[i + 2] + "\"); soundManager.playSound(SOUND.CLICK);'>delete</button>";
		str += "<div class='profileTextDiv'>" + escapeHtml(splitMsg[i + 1]).replace(/(?:\r\n|\r|\n)/g, '<br />') + "</div><br />";
	}
	uimanager.playerInfoWindow.setTitle("<font style='color: rgb(255, 248, 57);'>Your clan</font>");
	$('#riderDiv').html(getClanRiders());
	$('#addScrollableSubDivTextArea').html(str);
	fadeIn($("#playerInfoWindow"));
};

function setClan(tag, name, desc, members, admin, apps)
{
	var nameEditButton = (admin >= 2) ? "<button onclick='editClanName();' id='editClanNameButton'>edit</button>" : "";
	var str = "Tag: [" + tag + "]<br />Name: <span id='clanName'>" + name + "</span> " + nameEditButton + "<br />";
	
	str += "<div id='clanTextDiv'>" + (desc ? escapeHtml(desc).replace(/(?:\r\n|\r|\n)/g, '<br />') : "") + "</div>" + (admin >= 2 ? "<button id='clanTextButton' onclick=editClanText()>edit</button>" : "") + "<br /><br />";
	str += "<span class='biggerFont'>Members:</span><br />";
	
	var membersArray = members.split(" ");
	for(var i = 0; i < membersArray.length; i += 2)
	{
		if(membersArray[i].length > 0)
		{
			var role = membersArray[i + 1];
			
			str += getPlayerLink(membersArray[i]) + " <span class='lobbyLabel'>" + clan_member_role_names[role] + "</span> ";
			
			if(membersArray[i] != networkPlayerName)
			{
				if((admin >= 1 && role == 0) || admin == 2)
					str += " (<a href='#' onclick='network.send(\"kick-member<<$" + membersArray[i] + "\"); soundManager.playSound(SOUND.CLICK);' class='yellowfont'>kick</a>)";
				
				if(admin >= 2 && role != 0)
					str += " (<a href='#' onclick='network.send(\"change-member-role<<$" + membersArray[i] + "<<$0\"); soundManager.playSound(SOUND.CLICK);' class='yellowfont'>make member</a>)";
				
				if(admin >= 2 && role != 1)
					str += " (<a href='#' onclick='network.send(\"change-member-role<<$" + membersArray[i] + "<<$1\"); soundManager.playSound(SOUND.CLICK);' class='yellowfont'>make mod</a>)";
				
				if(admin >= 2 && role != 2)
					str += " (<a href='#' onclick='network.send(\"change-member-role<<$" + membersArray[i] + "<<$2\"); soundManager.playSound(SOUND.CLICK);' class='yellowfont'>make admin</a>)";
			}
			
			str += "<br />";
		}
	}
	
	str += "<br /><span class='biggerFont'>Applicants:<span><br />";
	
	var appsArray = apps.split(" ");
	for(var i = 0; i < appsArray.length; i++)
	{
		if(appsArray[i].length > 0)
		{
			str += getPlayerLink(appsArray[i]);
			
			if(admin >= 1)
				str += " (<a href='#' onclick='network.send(\"accept-member<<$" + appsArray[i] + "\"); soundManager.playSound(SOUND.CLICK);' class='greenfont'>accept</a>) (<a href='#' onclick='network.send(\"decline-member<<$" + appsArray[i] + "\"); soundManager.playSound(SOUND.CLICK);' class='redfont'>decline</a>)";
			
			str += "<br />";
		}
	}
	
	uimanager.playerInfoWindow.setTitle("<font style='color: rgb(255, 248, 57);'>Your clan</font>");
	$('#riderDiv').html(getClanRiders());
	$('#addScrollableSubDivTextArea').html(str);
	fadeIn($("#playerInfoWindow"));
};
function updatePlayerClanInfo(playerName, clanName)
{
	$('#playerNameDisplay').html('');
	$('#playerNameDisplay').append(network.getClanLink({clan: clanName, name: playerName}));
	const link = network.getPlayerLink({name: playerName, authLevel: 999, premium: false});
	link.className = "underline ";
	link.id = 'PlayerNameLink'
	$('#playerNameDisplay').append(link);
}

function pauseGame()
{
	if(!network_game)
	{
		game_paused = !game_paused;
		interface_.addMessage(game_paused ? "Game paused" : "Game unpaused", "yellow", imgs.attentionmarkYellow);
		soundManager.playSound(SOUND.POSITIVE);
		worker.postMessage({what: "setPause", val: game_paused});
	}
	else
		network.send("request-pause");
};

function getClanInfo(tag)
{
	soundManager.playSound(SOUND.CLICK);
	network.send("get-clan-info<<$" + tag);
};

function joinClanAttempt()
{
	var tag = $('#joinClanTagInput').val();
	
	if(tag.length > 0)
		network.send("join-clan<<$" + tag);
	
	else
		displayInfoMsg("please fill tag field");
};

function createClanAttempt()
{
	var tag = $('#createClanTagInput').val();
	var name = $('#createClanNameInput').val();
	
	if(tag.length > 0 && name.length > 0)
		network.send("create-clan<<$" + tag + "<<$" + name);
	
	else
		displayInfoMsg("please fill tag and name fields");
};

function resetAllHotkeyButtons()
{
	var el = $('#customHotkeysWindowSubdiv').children();
	
	for(var i = 0; i < el.length; i++)
	{
		var el2 = $(el[i]).children("button");
		
		for(var k = 0; k < el2.length; k++)
		{
			el2[k].active_ = false;
			el2[k].className = "hotkeyButton";
		}
	}
};

function typeNameIsUnique(name)
{
	var found = false;
	
	_.each(lists.types, function(type){
		if(type.name == name)
			found = true;
	});
	
	return !found;
};

function graphicNameIsUnique(name)
{
	var found = false;
	
	_.each(lists.imgs, function(type){
		if(type && type.name == name)
			found = true;
	});
	
	return !found;
};

function getImageFunctionName(func)
{
	var returnVal = "";
	
	_.each(lists.imgs, function(imgFunc, key){
		if(func == imgFunc)
			returnVal = key;
	});
	
	return returnVal;
};

function arraysAreSame(a1, a2, values)
{
	if(a1 == a2)
		return true;
	
	if(!a2)
		a2 = [];
	
	if(!a1)
		a1 = [];
		
	if(Object.prototype.toString.call(a1) != Object.prototype.toString.call(a2))
		return false;
	
	if(Object.prototype.toString.call(a1) === '[object Array]' && a1.length == a2.length) // both are array, compare elemnt by element
	{
		for(var j = 0; j < a1.length; j++)
			if(a1[j] != ((values && (typeof a2[j] == "string") && values[a2[j]]) ? values[a2[j]] : a2[j]))
				return false;
		
		return true;
	}
	
	return false;
};

function objectsAreSame(o1, o2, values)
{
	var isSame = true;
	
	if(o1 == o2 || !o1 && !o2)
		return true;
	
	if((o1 && !o2) || (!o1 && o2))
		return false;
	
	_.each(o1, function(val, key){
		if(((values && (typeof val == "string") && values[val]) ? values[val] : val) != ((values && (typeof o2[key] == "string") && values[o2[key]]) ? values[o2[key]] : o2[key]))
			isSame = false;
	});
	
	_.each(o2, function(val, key){
		if(((values && (typeof val == "string") && values[val]) ? values[val] : val) != ((values && (typeof o1[key] == "string") && values[o1[key]]) ? values[o1[key]] : o1[key]))
			isSame = false;
	});
	
	return isSame;
};

function getBuildingImgNameFromImgObject(o)
{
	var returnVal = null;
	
	_.each(building_imgs, function(val, key){
		if(o == val)
			returnVal = key;
	});
	
	return returnVal;
};

function isObject(o)
{
	return typeof o === 'object' && o !== null;
};

function copyObject(o)
{
	var o2 = {};
	_.each(o, function(val, key){ o2[key] = val; });
	return o2;
};

function setHotkey(key)
{
	var el = $('#customHotkeysWindowSubdiv').children();
	
	for(var i = 0; i < el.length; i++)
	{
		var el2 = $(el[i]).children("button");
		
		for(var k = 0; k < el2.length; k++)
		{
			var split = el2[k].id.split("_");
			
			// if button is command button
			if(el2[k].active_ && keyNames[key] && split[0] == "cmd")
			{
				el2[k].active_ = false;
				el2[k].className = "hotkeyButton";
				
				if(basicCommands[split[1]])
					basicCommands[split[1]].hotkey = key;
				
				if(game && game.commands[split[1]])
					game.commands[split[1]].hotkey = key;
				
				el2[k].innerHTML = keyNames[key];
				
				writeCookie();
				
				return;
			}
			
			// if button is ctrl grp hotkey
			if(el2[k].active_ && keyNames[key] && split[0] == "ctrlgrp")
			{
				el2[k].active_ = false;
				el2[k].className = "hotkeyButton";
				
				// free old key
				var nr = getKeyForCtrlGrp(split[1]);
				if(nr)
					delete ctrlGroupKeys[nr];
				
				// set new key
				ctrlGroupKeys[key] = split[1];
				
				el2[k].innerHTML = keyNames[key];
				
				writeCookie();
				
				return;
			}
			
			// if button is cam hotkey
			if(el2[k].active_ && keyNames[key] && split[0] == "camkey")
			{
				el2[k].active_ = false;
				el2[k].className = "hotkeyButton";
				
				// free old key
				var nr = getKeyForCamHotkey(split[1]);
				if(nr)
					delete cameraHotkeys[nr];
				
				// set new key
				cameraHotkeys[key] = split[1];
				
				el2[k].innerHTML = keyNames[key];
				
				writeCookie();
				
				return;
			}
			
			// if button is obs hotkey
			if(el2[k].active_ && keyNames[key] && split[0] == "obsKey")
			{
				el2[k].active_ = false;
				el2[k].className = "hotkeyButton";
				
				// set key
				obsKeys[split[1]] = key;
				
				el2[k].innerHTML = keyNames[key];
				
				writeCookie();
				
				if(split[1] == 0)
					$('#visionAll').html("All [" + getKeyName(key) + "]");
				
				else
					$('#obsDropdown_' + split[1]).html(obsAbilityNames[split[1]] + " [" + getKeyName(key) + "]");
				
				return;
			}
			
			// if button is other hotkey
			if(el2[k].active_ && keyNames[key] && split[0] == "otherKey")
			{
				el2[k].active_ = false;
				el2[k].className = "hotkeyButton";
				
				// set key
				otherKeys[split[1]] = key;
				
				el2[k].innerHTML = keyNames[key];
				
				writeCookie();
				
				return;
			}
			
		}
	}
};

function getButtonCaptionFromOpenQueriesState()
{
	if(open_queries == OPEN_QUERIES.NEVER)
		return "Never pop up Messages";
	
	if(open_queries == OPEN_QUERIES.NOT_INGAME)
		return "Don't pop up Messages ingame";
	
	return "Always pop up Messages";
};

function setReplaySpeed(index)
{
	replaySpeedIndex = Math.max(Math.min(index, game_speeds.length - 1), 0);
	TICK_TIME = game_speeds[replaySpeedIndex].tick_time;
	$('#replayShowSpeed').html(game_speeds[replaySpeedIndex].caption);
	worker.postMessage({what: "setTickTime", tickTime: TICK_TIME});
};

function getRainTimeFromSeed(seed)
{
	var rng = new RNG(seed);
	var rainTime = [];
	var t_ = rng.getNr(-1, 15);
	var lastPoint = t_;
	var start = true;
	
	while(t_ < 300)
	{
		t_ += start ? rng.getNr(1, 7) : rng.getNr(2, 16);
		
		if(start)
			rainTime.push({start: lastPoint, end: t_});
		
		start = !start;
		lastPoint = t_;
	}
	
	return rainTime;
}

function RNG(seed)
{
	this.m = 0x80000000; // 2**31;
	this.a = 1103515245;
	this.c = 12345;
	this.state = seed ? seed : Math.floor(Math.random() * (this.m - 1));
}

RNG.prototype.getNr = function(min, max)
{
	this.state = (this.a * this.state + this.c) % this.m;
	
	var rangeSize = max - min;
	var randomUnder1 = this.state / this.m;
	return min + randomUnder1 * rangeSize;
};

function littlechatgame(log_)
{
	var lcg_canvas = document.createElement("canvas");
	var lcg_context = lcg_canvas.getContext("2d");
	lcg_canvas.width = $('#lobbyChatTextArea').width() - 20;
	lcg_canvas.height = 90;
		
	lcg = log_;
	lcg.currentPhase = -1;
	lcg.army = [];
	lcg.startTime = Date.now() + 2000;
	lcg.canvas = lcg_canvas;
	lcg.ticksCounter = -1;
	lcg.actualPhase = -1;
	
	game = new Game();
	game.loadMap({
		"name": "unnamed",
		"x": 30,
		"y": 10,
		"units": [],
		"buildings": [],
		"tiles": [],
		"defaultTiles": ["Ground n 6"],
		"unitData":
		{
			"dragon":
			{
				"imageScale": 0.7,
				"height": 1.5,
				"projectileSpeed": 12
			},
			
			"ballista":
			{
				"imageScale": 0.8
			},
			
			"catapult":
			{
				"projectileSpeed": 12,
				"imageScale": 0.8
			},
			
			"fireball":
			{
				"projectileSpeed": 9
			}
		}
	});
	
	lcg_context.font = "bold 32px LCDSOlid";
	drawText(lcg_context, log_.players[0], game.players[1].getColor(), "bold 32px LCDSolid", 10, 30);
	var w1 = lcg_context.measureText(log_.players[0]).width;
	drawText(lcg_context, "vs", "white", "bold 32px LCDSolid", 10 + w1 + 10, 30);
	var w2 = lcg_context.measureText("vs").width;
	drawText(lcg_context, log_.players[1], game.players[2].getColor(), "bold 32px LCDSolid", 10 + w1 + w2 + 20, 30);
	
	globalSoundModifier = globalSoundModifierDefault;
	soundManager.playSound(SOUND.BATTLE_FANFARE);
	globalSoundModifier = 1;
	
	// vision
	for(var x = 0; x < 30; x++)
		for(var y = 0; y < 10; y++)
			PLAYING_PLAYER.team.mask[x][y] = 2;
	
	var players = [
		new Player("pl1", CONTROLLER.COMPUTER, 1),
		new Player("pl2", CONTROLLER.COMPUTER, 2)
	];
	
	var pos = 3;
	
	for(var i = 0; i < log_.armies[0].length; i++)
		lcg.army.push(new Unit({
			x: pos++,
			y: 3.2,
			type: log_.armies[0][i].toUnitType(),
			owner: players[0]
		}));
	
	for(var i = log_.armies[1].length - 1; i >= 0; i--)
		lcg.army.push(new Unit({
			x: pos++,
			y: 3.2,
			type: log_.armies[1][i].toUnitType(),
			owner: players[1]
		}));
	
	addToChatWindow(lcg_canvas);
	
	clearInterval(lcg_interval);
	
	lcg_interval = setInterval(function(){
		
		var timeNow = Date.now();
		
		if(game_state != GAME.LOBBY)
		{
			clearInterval(lcg_interval);
			return;
		}
		
		if(lcg.startTime > timeNow)
			return;
		
		var age = timeNow - lcg.startTime;
		var phaseAge = age % 1500;
		var phaseStartTime = timeNow - phaseAge;
		var phaseAgeInTicks = Math.floor(phaseAge / 50);
		var phase = Math.floor(age / 1500);
		ticksCounter = Math.floor(age / 1000 * 20);
		percentageOfCurrentTickPassed = (age % 50) / 50;
		var phaseType = lcg.actualPhase % 3;
		tickDiff = 0;
		globalSoundModifier = globalSoundModifierDefault;
		
		// if not die phase, set units that have been thrown to target pos, because it might not have happened correctly, if the screen was inactive during throwing
		if(phaseType != 1)
			for(var i = 0; i < lcg.army.length; i++)
				if(lcg.army[i].setToPos)
				{
					lcg.army[i].pos = lcg.army[i].setToPos;
					lcg.army[i].lastTicksPosition = lcg.army[i].setToPos;
					lcg.army[i].drawPos = lcg.army[i].setToPos;
					delete lcg.army[i].setToPos;
				}
		
		// update
		if(phase != lcg.currentPhase)
		{
			lcg.currentPhase = phase;
			
			for(var i = 0; i < lcg.army.length; i++)
			{
				lcg.army[i].order = lists.types.stop;
				lcg.army[i].lastAttackingTick = -999;
				lcg.army[i].lastTicksPosition = lcg.army[i].pos;
			}
			
			var arr = [];
			while(arr.length == 0)
			{
				lcg.actualPhase++;
				arr = lcg.replay[lcg.actualPhase];
				
				if(!arr) // battle over
				{
					if(lcg.hasBeenDrawn)
					{
						clearInterval(lcg_interval);
						lcg_context.font = "bold 32px LCDSOlid";
						
						if(lcg.winner == 0)
							drawText(lcg_context, "draw", "white", "bold 32px LCDSolid", 200, 60);
						else
							drawText(lcg_context, lcg.players[lcg.winner - 1] + " wins", game.players[lcg.winner].getColor(), "bold 32px LCDSolid", 200, 60);
						
						globalSoundModifier = 1;
						
						return;
					}
					else
						arr = [0];
				}
			}
			
			phaseType = lcg.actualPhase % 3;
			
			if(phaseType == 0) // attack phase
			{
				for(var i = 0; i < arr.length; i++)
				{
					if(arr[i].indexOf && arr[i].indexOf("A") >= 0) // attack
					{
						var split = arr[i].split("A");
						
						var u1 = game.getUnitById(split[0]);
						var u2 = game.getUnitById(split[1]);
						
						u1.targetUnit = u2;
						u1.order = lists.types.attack;
						u1.lastAttackingTick = ticksCounter;
						u1.tickOfLastWeaponFired = ticksCounter + u1.type.weaponDelay;
					}
					
					else if(arr[i].indexOf && arr[i].indexOf("S") >= 0) // smash
					{
						var split = arr[i].split("S");
						
						var u1 = game.getUnitById(split[0]);
						var u2 = game.getUnitById(split[1]);
						
						u1.targetUnit = u2;
						u1.order = lists.types.smash;
						u1.lastAttackingTick = ticksCounter;
						u1.tickOfLastWeaponFired = ticksCounter + u1.type.weaponDelay;
					}
					
					else if(arr[i].indexOf && arr[i].indexOf("H") >= 0) // heal
					{
						var split = arr[i].split("H");
						
						var u1 = game.getUnitById(split[0]);
						var u2 = game.getUnitById(split[1]);
						
						u1.targetUnit = u2;
						u1.order = lists.types.heal;
						u1.lastAttackingTick = ticksCounter;
						u1.tickOfLastWeaponFired = ticksCounter + u1.type.weaponDelay;
					}
					
					else if(arr[i].indexOf && arr[i].indexOf("F") >= 0) // fireball
					{
						var split = arr[i].split("F");
						
						var u1 = game.getUnitById(split[0]);
						var u2 = game.getUnitById(split[1]);
						
						u1.targetUnit = u2;
						u1.order = lists.types.attack;
						u1.lastAttackingTick = ticksCounter;
						u1.tickOfLastWeaponFired = ticksCounter + u1.type.weaponDelay;
						
						new Flamestrike({
							from: u1,
							to: new Field(parseInt(split[2]), u1.pos.py, true),
							speed: 3,
							noFinalBlow: true,
							scale: 1
						});
						
						soundManager.playSound(SOUND.FIREBALL, null, 0.5);
					}
				}
			}
			
			if(phaseType == 1) // die phase
			{
				for(var i = 0; i < arr.length; i++)
				{
					if(arr[i].indexOf && arr[i].indexOf("X") >= 0) // get smashed
					{
						var u1 = game.getUnitById(arr[i].split("X")[0]);
						
						u1.isThrowedUntil = ticksCounter + 15;
						u1.throwStart = ticksCounter;
						u1.throwFrom = u1.pos.getCopy();
						u1.throwTo = new Field(parseInt(arr[i].split("X")[1]), u1.pos.py, true);
						u1.lastTicksPosition = u1.throwTo.getCopy();
						u1.setToPos = u1.throwTo.getCopy();
						u1.targetPos_ = u1.throwTo.getCopy();
						u1.target = u1.throwTo.getCopy();
					}
					
					else // die
					{
						var u1 = game.getUnitById(arr[i]);
						
						u1.isAlive = false;
						u1.throwStart = ticksCounter;
						u1.isThrowedUntil = ticksCounter + 25;
						u1.throwFrom = u1.pos;
						u1.throwTo = u1.pos;
						
						if(u1.type.deathSound)
							soundManager.playSound(u1.type.deathSound, null, 0.5);
					}
				}
			}
			
			if(phaseType == 2) // move phase
			{
				for(var i = 0; i < arr.length; i++)
					if(arr[i].indexOf && arr[i].indexOf("M") >= 0)
					{
						var u1 = game.getUnitById(arr[i].split("M")[0]);
						
						u1.targetPos_ = new Field(arr[i].split("M")[1], u1.pos.py, true);
						u1.originPos_ = u1.pos.getCopy();
						u1.target = u1.targetPos_;
						u1.moveStartTime_ = phaseStartTime;
						u1.order = lists.types.move;
					}
			}
		}
		
		if(lcg.ticksCounter != ticksCounter)
		{
			lcg.ticksCounter = ticksCounter;
			tickDiff = 1;
			
			for(var i = 0; i < lcg.army.length; i++)
			{
				var u = lcg.army[i];
				
				if(phaseType == 0) // attack phase
				{
					if((u.order == lists.types.attack || u.order == lists.types.smash) && phaseAgeInTicks < u.type.weaponCooldown - 5)
					{
						u.hitCycle++;
						u.lastAttackingTick = ticksCounter;
						
						if(u.tickOfLastWeaponFired == ticksCounter)
						{
							if(u.type.attackEffect) // create projectile (if ranged)
								startEffect(u.type.attackEffect, {
									from: u,
									to: u.targetUnit,
									speed: u.type.projectileSpeed / 2
								});
							
							if(u.type.meleeHitSound)
								soundManager.playSound(u.type.meleeHitSound, null, 0.5);
							
							if(u.type.attackLaunchSound)
								soundManager.playSound(u.type.attackLaunchSound, null, 0.5);
							
							if(u.type.meleeHitSound && u.targetUnit.type.painSound)
								soundManager.playSound(u.targetUnit.type.painSound, null, 0.5);
						}
					}
					
					if(u.tickOfLastWeaponFired == ticksCounter && u.order == lists.types.heal)
					{
						startEffect("heal", {
							originPos: u.pos,
							from: u.targetUnit
						});
						
						soundManager.playSound(SOUND.HEAL, null, 0.5);
					}
				}
				
				if(u.targetPos_ && u.pos.distanceTo2(u.targetPos_) > 0.03)
				{
					u.lastTicksPosition = u.pos;
					u.pos = u.originPos_.addNormalizedVector(u.targetPos_, (Math.min(timeNow - u.moveStartTime_, 1500) / 1500) * u.originPos_.distanceTo2(u.targetPos_));
				}
				else
					u.lastTicksPosition = u.pos;
			}
		}
		
		lcg.canvas.style.width = "95%";
		lcg.canvas.width = lcg.canvas.width;
		SCALE_FACTOR = 1.5;
		FIELD_SIZE = 16 * SCALE_FACTOR;
		c = lcg.canvas.getContext("2d");
		lcg.hasBeenDrawn = true;
		
		// draw
		for(var i = 0; i < lcg.army.length; i++)
		{
			lcg.army[i].updateDrawPosition();
			lcg.army[i].draw();
		}
		
		// draw effectz
		var objs = game.objectsToDraw.slice();
		for(var i = 0; i < objs.length; i++)
			if(objs[i].isEffect)
			{
				objs[i].draw();
				
				if(objs[i].isExpired())
				{
					if(objs[i].to && objs[i].to.type && objs[i].to.type.painSound)
						soundManager.playSound(objs[i].to.type.painSound, null, 0.5);
					
					if(objs[i].to && objs[i].to.type && objs[i].to.type.painSound2)
						soundManager.playSound(objs[i].to.type.painSound2, null, 0.5);
					
					if(objs[i].constructor == LaunchedRock)
						soundManager.playSound(SOUND.CATA_IMPACT, null, 0.5);
					
					game.objectsToDraw.erease(objs[i]);
				}
			}
		
		globalSoundModifier = 1;
		
		var ageFactor = Math.min(age / 1000, 1);
		lcg_context.font = "bold " + (31 - ageFactor * 13) + "px LCDSOlid";
		drawText(lcg_context, log_.players[0], game.players[1].getColor(), "bold " + (31 - ageFactor * 13) + "px LCDSolid", 10, 30 - ageFactor * 9);
		var w1 = lcg_context.measureText(log_.players[0]).width;
		drawText(lcg_context, "vs", "white", "bold " + (31 - ageFactor * 13) + "px LCDSolid", 10 + w1 + (10 - ageFactor * 4), 30 - ageFactor * 9);
		var w2 = lcg_context.measureText("vs").width;
		drawText(lcg_context, log_.players[1], game.players[2].getColor(), "bold " + (31 - ageFactor * 13) + "px LCDSolid", 10 + w1 + w2 + (20 - ageFactor * 8), 30 - ageFactor * 9);
		
		c = originalC;
		
	}, 10);
};

function escapeHtml(text)
{
	return text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
};

// Subsitute chat messages
function kappa(text, permissions)
{
	// replace ish
	if((new RegExp("\u5350|\u534D", "g")).test(text))
		return "";
	
	permissions = permissions ? hex32ToBin(permissions) : null;
	
	// console.dir(permissions);
	var em = emotes.concat(_emotes2);
	
	//?
	for(var i = 0; i < em.length; i++)
		if(!em[i].dbPos || (permissions && em[i].dbPos <= permissions.length && permissions.substr(permissions.length - em[i].dbPos, 1) == "1"))
			text = text.replace(new RegExp(em[i].text, "g"), "#<<#<>#<" + i + "#<<#<>#");
	
	// Own name highlighting
	text = text.replace(new RegExp(networkPlayerName, "gi"), "<span class='highlighted2'>" + networkPlayerName + "</span>");
	
	// emotes
	for(var i = 0; i < em.length; i++)
	{
		// console.dir(em[i]);
		if(!em[i].dbPos || (permissions && em[i].dbPos <= permissions.length && permissions.substr(permissions.length - em[i].dbPos, 1) == "1"))
		{
			text = text.replace(new RegExp("#<<#<>#<" + i + "#<<#<>#", "g"), "<img class='kappa' src='imgs/emotes/" + em[i].img + "' />");
		}
	}
	
	return text;
};

function soundFaceOut()
{
	if(soundManager.buildingClickSound[0] && soundManager.buildingClickSound[0].fadeOut)
	{
		var newVolume = soundManager.buildingClickSound[0].sound.volume - soundManager.buildingClickSound[0].maxVolume / 11;
		
		if(newVolume <= 0)
		{
			soundManager.buildingClickSound[0].sound.pause();
			soundManager.buildingClickSound[0].sound.volume = 0;
			soundManager.buildingClickSound[0].sound.currentTime = 0;
			soundManager.buildingClickSound.splice(0, 1);
		}
		
		else
		{
			soundManager.buildingClickSound[0].sound.volume = newVolume;
			setTimeout(soundFaceOut, 50);
		}
	}
}

function levelUp(splitMsg)
{
	var xp1 = getXPRequiredForLvl(splitMsg[1]);
	var xp2 = getXPRequiredForLvl(parseInt(splitMsg[1]) + 1);
	
	var str = "<div class='xpBar' style='width: 200px; height: 30px; margin: 0 auto; position: relative;'>";
	str += "<div style='width: " + (((splitMsg[2] - xp1) / (xp2 - xp1)) * 200) + "px; height: 30px;'></div><p style='font-size: 22px;'>" + splitMsg[2] + " / " + xp2 + "</p></div>";
	str += "<p style='font-size: 14px;'>" + xp2 + " exp required for level " + (parseInt(splitMsg[1]) + 1) + "</p>";
	str += splitMsg[3] > 0 ? "<div id='goldRewardONLvlUp' title='You received " + splitMsg[3] + " gold as a reward'><span>+" + splitMsg[3] + "</span> <img src='imgs/gold2.png' class='pixelated' style='height: 32px;' /></div>" : "";
	
	storedAchivements.push({
		text: "<img style='height: 200px;' src='imgs/level-up.png' /><br /><span style='font-size: 30px;'>You reached level <span class='greenfont' style='font-size: 42px;'>" + splitMsg[1] + "</span></span><br /><br />" + str,
		sound: SOUND.ARCHIVEMENT3
	});
	
	showAchivement();
	
	gold = parseInt(splitMsg[3]) + gold;
	$('#playerGold').html(currencyFormatter(gold));
	
	for(var i = 4; i < splitMsg.length; i++)
		unlockEmote(splitMsg[i]);
};
// TODO: Review this
function alphabetizePlayers(p_dict)
{

	// Grabs all players, separates by authLevel/Premium status, then alphabetizes them
	
	gst_arr = [];
	acc_arr = [];
	pre_arr = [];
	mod_arr = [];
	dev_arr = [];
	alpha_arr = [];	
	new_dict = {};
	
	/* Separate players by their authLevel and Premium Status:
		authLevel 1 = Guest
		authLevel 2 = Normal Account
		authLevel 2 w/ Premium = Premium
		authLevel 3 = Moderator
		authLevel 4 = Developer	
	*/

	for (auth in p_dict)
		if (p_dict[auth].authLevel == "1")
			gst_arr.push(p_dict[auth].name.toLowerCase());
		else if ((p_dict[auth].authLevel == "2") && (p_dict[auth].premium != true))
			acc_arr.push(p_dict[auth].name.toLowerCase());
		else if ((p_dict[auth].authLevel == "2") && (p_dict[auth].premium == true))
			pre_arr.push(p_dict[auth].name.toLowerCase());		
		else if (p_dict[auth].authLevel == "3")
			mod_arr.push(p_dict[auth].name.toLowerCase());
		else if (p_dict[auth].authLevel == "4")
			dev_arr.push(p_dict[auth].name.toLowerCase());				
	
	gst_arr.sort();
	acc_arr.sort();
	pre_arr.sort();
	mod_arr.sort();
	dev_arr.sort();
	
	var omega_arr = alpha_arr.concat(dev_arr, mod_arr, pre_arr, acc_arr, gst_arr)

	for (name in omega_arr)
		for (p in p_dict)
			if (omega_arr[name] == p_dict[p].name.toLowerCase())
				new_dict[name] = p_dict[p];

	return new_dict;
};

function showMicroTransWindow()
{
	var str = "<br /><button class='microTransButton' onclick='network.send(\"request-emotes-info\"); soundManager.playSound(SOUND.CLICK);'>Emotes";
	// str += "<img style='position: absolute; left: 380px; top: 30px;' src='imgs/emotes/not-bad.png' />";
	// str += "<img style='position: absolute; left: 180px; top: 30px;' src='imgs/emotes/orly.jpg' />";
	str += "</button>";
	str += "<button class='microTransButton' onclick='network.send(\"request-skins-info\"); soundManager.playSound(SOUND.CLICK);'>Skins & Dances</button>";
	str += "<button class='microTransButton' onclick='showPremiumInfo(); soundManager.playSound(SOUND.CLICK);'>Premium Account</button>";
	str += "<button class='microTransButton' onclick='showTreasureInfo(); soundManager.playSound(SOUND.CLICK);'>Treasure Chest</button>";
	
	$('#addScrollableSubDivTextArea').html(str);
	fadeIn($('#playerInfoWindow'));
	
	uimanager.playerInfoWindow.setTitle("<font style='color: rgb(255, 248, 57);'>Unlockable Items</font>");
};

function showTreasureInfo()
{
	var str = "<div id='premium_window'><img class='pixelated' style='height: 120px;' src='imgs/emotes/chest.png'><br /><br />";
	
	str += "<p style='color: rgb(255, 248, 57); font-size: 22px;'>Treasure Chest</p>";
	str += "<div class='profileTextDiv'>Treasure chests contain random items, you never know what you will get. You may get some gold, an item or something else. There may be even secret items in some treasure chests.</div><br /><br />";
	
	var tc = specials[1];
	
	if(gold >= tc.gold) // FIX
		str += "<div><button class='buy_button' onclick='getItem4Gold(\"" + tc.artNr + "\");'>Buy a treasure chest for " + tc.gold + " gold</button>";
	
	else
		str += "<span class='redfont'>" + tc.gold + " gold required</span></div>";
	
	str += "</div>";
	
	$('#addScrollableSubDivTextArea').html(str);
	
	fadeIn($('#playerInfoWindow'));
	uimanager.playerInfoWindow.setTitle("<font style='color: rgb(255, 248, 57);'>Treasure Chest</font>", "<button onclick='soundManager.playSound(SOUND.CLICK); showMicroTransWindow();'>back</button>");
};

function showPremiumInfo()
{
	var secLeft = (premium_until - parseInt(Date.now() / 1000));
	
	var str = "<div id='premium_window'><img class='pixelated' style='height: 140px;' src='imgs/emotes/premium.png'><br /><br />";
	
	str += "<p>A premium account includes the following features:</p>";
	str += "<div class='profileTextDiv'><div><span class='likePremiumColor'>Green player name:</span> You name will show up in green instead of yellow</div>";
	str += "<div><span class='likePremiumColor'>Bonus xp:</span> You will receive 25% more experience from games</div>";
	str += "<div><span class='likePremiumColor'>No ad:</span> You dont see the ad banner in the main lobby anymore</div>";
	str += "<div><span class='likePremiumColor'>Emotes:</span> Includes the following emotes:</div><div>";
	
	for(var i = 0; i < emotes.length; i++)
		if(emotes[i].special && emotes[i].special == "requires_premium")
			str += "<img class='buytableImgs' src='imgs/emotes/" + emotes[i].img + "' /> ";
	
	str += "</div></div><br />";
	
	if(secLeft > 0)
		str += "<div>Your premium account expires in <span class='ladderGameTimeTD'>" + secToDate(secLeft) + "</span></div><br />";
	
	var pr = specials[0];
	
	if(gold >= pr.gold)
	{
		if(secLeft > 0)
			str += "<div><button class='buy_button' onclick='getItem4Gold(\"" + pr.artNr + "\");'>Extend by 30 days for " + pr.gold + " gold</button>";
			
		else
			str += "<div><button class='buy_button' onclick='getItem4Gold(\"" + pr.artNr + "\");'>Get 30 days premium account for " + pr.gold + " gold</button>";
	}
	
	else
		str += "<span class='redfont'>" + pr.gold + " gold required for 30 days</span></div>";
	
	str += "</div>";
	
	$('#addScrollableSubDivTextArea').html(str);
	
	fadeIn($('#playerInfoWindow'));
	uimanager.playerInfoWindow.setTitle("<font style='color: rgb(255, 248, 57);'>Premium Account</font>", "<button onclick='soundManager.playSound(SOUND.CLICK); showMicroTransWindow();'>back</button>");
};

function secToDate(sec)
{
	var str = "";
	
	if(sec > 60 * 60 * 24)
	{
		str += parseInt(sec / (60 * 60 * 24)) + " days, ";
		sec = sec % (60 * 60 * 24);
	}
	
	if(sec > 60 * 60)
	{
		str += parseInt(sec / (60 * 60)) + " hours, ";
		sec = sec % (60 * 60);
	}
	
	str += Math.ceil(sec / 60) + " min";
	
	return str;
};

function setSkin(artNr, unitType, j)
{
	soundManager.playSound(SOUND.CLICK);
	
	for(var i = 0; i < 39; i++)
		$('#skins_' + unitType + "_" + i).removeClass("b_active").addClass("b_inactive");
	
	$('#skins_' + unitType + "_" + j).removeClass("b_inactive").addClass("b_active");
	
	network.send("set-skin<<$" + artNr + "<<$" + unitType);
};

function getItem4Gold(artNr)
{
	soundManager.playSound(SOUND.CLICK);
	
	var arch_ = emotes.concat(skins, dances, specials);
	for(var i = 0; i < arch_.length; i++)
		if(arch_[i].artNr == artNr)
		{
			//console.log(artNr);
			displayInfoMsg("Get " + arch_[i].name + " for " + arch_[i].gold + " gold ?<br /><br /><br /><button onclick='network.send(\"get-item-4-gold<<$" + artNr + "\"); fadeOut($(\"#infoWindow\")); soundManager.playSound(SOUND.CLICK);'>Get it !</button>");
			return;
		}
}

function unlockEmote(artNr, newPremiumTime)
{
	var arch_ = emotes.concat(skins, dances, goldPacks, specials, _emotes2);
	for(var i = 0; i < arch_.length; i++)
		if(arch_[i].artNr == artNr)
		{
			fadeOut($("#playerInfoWindow"));
			
			var text = "";
			var img = "";
			var text2 = "";
			
			if(arch_[i].type == "skins")
			{
				var img = unit_imgs[arch_[i].img];
				
				var w = img.idle.frameWidth;
				var h = img.idle.h / img._angles;
				
				if(w > h)
				{
					h = 160 * (h / w);
					w = 160;
				}
				else
				{
					w = 160 * (w / h);
					h = 160;
				}
				
				var w2 = img.file[1].width * (w / img.idle.frameWidth);
				var h2 = img.file[1].height * (h / (img.idle.h / img._angles));
				var x = img.idle.x * (w2 / img.file[1].width);
				var y = img.idle.y * (h2 / img.file[1].height);
				
				text = "Skin <span class='greenfont'> " + arch_[i].name + "</span> unlocked";
				img = "<div style='width: " + w + "px; height: " + h + "px; overflow: hidden; position: relative; margin: 0 auto;'><img class='pixelated' style='position: absolute; left: " + -x + "px; top: " + -y + "px; width: " + w2 + "px; height: " + h2 + "px;' src='" + (img.file[1].toDataURL ? img.file[1].toDataURL() : img.file[1].src) + "' /></div>";
				text2 = "Select this skin from the 'Skins and Dances' menu to use it. Works in multiplayer games only.";
			}
			
			else if(arch_[i].type == "dances")
			{
				var img = unit_imgs[arch_[i].img];
				
				var w = img.idle.frameWidth;
				var h = img.idle.h / img._angles;
				
				if(w > h)
				{
					h = 160 * (h / w);
					w = 160;
				}
				else
				{
					w = 160 * (w / h);
					h = 160;
				}
				
				var w2 = img.file[1].width * (w / img.idle.frameWidth);
				var h2 = img.file[1].height * (h / (img.idle.h / img._angles));
				var x = img.idle.x * (w2 / img.file[1].width);
				var y = img.idle.y * (h2 / img.file[1].height);
				
				text = "Dance <span class='greenfont'> " + arch_[i].name + "</span> unlocked";
				img = "<div style='width: " + w + "px; height: " + h + "px; overflow: hidden; position: relative; margin: 0 auto;'><img class='pixelated' style='position: absolute; left: " + -x + "px; top: " + -y + "px; width: " + w2 + "px; height: " + h2 + "px;' src='" + (img.file[1].toDataURL ? img.file[1].toDataURL() : img.file[1].src) + "' /></div>";
				text2 = "In a multiplayer game, select one or more units of this type and type '" + arch_[i].chat_str + "' in chat to make them dance.";
			}
			
			else if(arch_[i].type == "emotes")
			{
				text = (arch_[i].hidd ? "<span class='hidden_item'>Hidden</span> " : "") + "Emote <span class='greenfont'> " + arch_[i].name + "</span> unlocked";
				img = "<img class='pixelated' style='height: 160px;' src='imgs/emotes/" + arch_[i].img + "' />";
				text2 = "Type '" + arch_[i].text + "' in lobby chat to use this emote.";
			}
			
			else if(arch_[i].type == "gold")
			{
				text = "Received <span class='yellowfont' style='font-size: 40px;'> " + arch_[i].reward + "</span> gold";
				img = "<img class='pixelated' style='height: 160px;' src='imgs/gold2.png' />";
				$('#playerGold').html(currencyFormatter(gold + parseInt(arch_[i].reward)));
			}
			
			else if(arch_[i].type == "special")
			{
				if(arch_[i].type_2 == "premium")
				{
					text = "Premium account unlocked";
					img = "<img class='pixelated' style='height: 160px;' src='imgs/emotes/" + arch_[i].img + "' />";
					premium_until = newPremiumTime;
				}
			}
			
			storedAchivements.push({
				text: img + "<br /><br /><br /><br /><br /><span style='font-size: 30px;'>" + text + "</span><div style='margin-top: 20px;'>" + text2 + "</div>",
				sound: SOUND.ARCHIVEMENT
			});
			
			showAchivement();
			
			return;
		}
};

function unlockAchivement(index)
{
	var a = achivements[index];
	
	if(!a)
		return;
	
	storedAchivements.push({
		text: "<img class='pixelated' style='height: 135px;' src='imgs/achivements/" + a.img + "' /><br /><br /><br /><div style='font-size: 24px;'>Achievement <span class='ach_name'> " + a.name + "</span> unlocked</div><div class='achivement_text'>(" + a.text + ")</div><br /><div id='ach_lowline' title='The amount of gold you get for this achievement'><span>Reward:</span> <span id='reward_amount'>" + a.reward + "</span> <img class='pixelated' style='width: 48px;' src='imgs/gold2.png'/></div>",
		sound: SOUND.ARCHIVEMENT
	});
	
	$('#playerGold').html(currencyFormatter(gold + a.reward));
	
	showAchivement();
};

function showAchivement()
{
	if($('#infoWindow2').css('display') == "none" && storedAchivements.length > 0 && game_state != GAME.PLAYING)
	{
		var a = storedAchivements.splice(0, 1)[0];
		displayInfoMsg2(a.text);
		soundManager.playSound(a.sound);
	}
};

function showAchivementsWindow(ach_str)
{
	uimanager.playerInfoWindow.setTitle("<font style='color: rgb(255, 248, 57);'>Achievements</font>");
	
	var str = "";
	
	for(var i = 0; i < achivements.length; i++)
	{
		var a = achivements[i];
		var rewardStr = a.reward ? `(reward: ${a.reward} gold)` : "";
		str += "<div class='achivement_div " + (checkDBPos(a.dbPos, ach_str) ? "" : "achivement_img_locked") + `' title='${a.text} ${rewardStr}'>`;
		str += "<img class='pixelated' style='height: 108px;' src='imgs/achivements/" + a.img + "' /><p " + (checkDBPos(a.dbPos, ach_str) ? "" : "class='greyfont'") + ">" + a.name + "</p></div>";
	}
	
	$('#addScrollableSubDivTextArea').html(str);
	fadeIn($('#playerInfoWindow'));
};

function showBuyGoldWindow(myId)
{
	soundManager.playSound(SOUND.CLICK);
	
	uimanager.playerInfoWindow.setTitle("<font style='color: rgb(255, 248, 57);'>Gold</font>");
	
	var str = "";
	
	for(var i = 0; i < goldPacks.length; i++)
	{
		var g = goldPacks[i];
		str += "<div class='gold_buy_div' title='Buy " + g.reward + " gold for " + g.price + " €'><div class='buy_gold_title'>" + g.name + "</div>";
		str += "<div class='buy_gold_reward_div'><span class='buy_gold_span'>" + g.reward + "</span> <img src='imgs/gold2.png' class='pixelated' style='width: 48px;' /></div>";
		str += "<div>" + getBuyButton0(g.artNr, g.price, myId) + "</div></div>";
	}
	
	$('#addScrollableSubDivTextArea').html("<div style='margin: 14px;'>" + goldDescription + "</div>" + str);
	fadeIn($('#playerInfoWindow'));
};

function rfSBTN() // refresh Survey Button
{
	if(network.authedAndLogged && srvState == "monetizable")
		$('#playerGoldWrap')[0].innerHTML += " <button id='freeGoldButton' onclick='fgs();'>Get 400 gold for free!</button>";
	
	else
		setTimeout(cnSrv, 60 * 60 * 1000);
};

function cnSrv()
{
	srv = Survata.createSurveywall({
		brand: "Littlewargame",
		explainer: npf,
		contentName: Date.now().toString()
	});
	
	srv.on("load", function(data){
		srvState = data.status;
		rfSBTN();
	});
	
	srv.on("interviewComplete", function() {
		network.send("delete-map-current");
		setTimeout(cnSrv, 30 * 1000);
	});
}

function fgs() // free gold survey
{
	srv.startInterview();
	$('#freeGoldButton').remove();
};

function checkDBPos(pos, dbEntry)
{
	return dbEntry.length >= pos && dbEntry.substr(dbEntry.length - pos, 1) == "1";
};

function animateDances(offsets, maxs, xs, ys)
{
	setTimeout(function(){
		if($('#dance_img_0').is(":visible"))
		{
			for(var i = 0; i < offsets.length; i++)
			{
				var offset = parseFloat($('#dance_img_' + i)[0].style.marginLeft) - offsets[i];
				
				if(offset < (-maxs[i] + offsets[i] / 2))
					offset = 0;
				
				$('#dance_img_' + i)[0].style.marginLeft = (offset - xs[i]) + "px";
				$('#dance_img_' + i)[0].style.marginTop = -ys[i] + "px";
			}
			
			animateDances(offsets, maxs, xs, ys);
		}
	}, 150);
};

function hex32ToBin(s)
{
	var returnVal = "";
	
	for(var i = s.length - 1; i >= 0; i--)
	{
		var char_ = s.substr(i, 1);
		var val = !isNaN(char_) ? parseInt(char_) : char_.charCodeAt(0) - 'A'.charCodeAt(0) + 10;
		
		for(var k = 1; k <= 5; k++)
		{
			var modulu = val % Math.pow(2, k);
			returnVal = (modulu == 0 ? "0" : "1") + returnVal;
			val -= modulu; 
		}
	}
	
	return returnVal;
};

function showImprint()
{
	soundManager.playSound(SOUND.CLICK);
	$('#addScrollableSubDivTextArea2').html("<br /><br /><div style='margin-left: 30px;'>littlewargame.com<br /><br />Owner:<br />Addicting Games, Inc.<br />15332 Antioch Street Los Angeles<br /> Suite 200<br /> California 90272<br /> USA</br>email: chris@addictinggames.com</div>");
	fadeIn($('#playerInfoWindow2'));
	uimanager.playerInfoWindow2.setTitle("<font style='color: rgb(255, 248, 57);'>Imprint</font>");
};

function getItemFromArtNr(artNr)
{
	var arr = emotes.concat(skins, dances, goldPacks, specials, _emotes2);
	
	for(var i = 0; i < arr.length; i++)
		if(arr[i].artNr == artNr)
			return arr[i];
	
	return null;
};

function acceptAGB()
{
	network.send("i-accept-agb");
	soundManager.playSound(SOUND.CLICK);
};

function showBuyWindow(artNr, playerID)
{
	var item = getItemFromArtNr(artNr);
	
	if(!item)
		return;
	
	soundManager.playSound(SOUND.CLICK);
	
	var str = "<span style='font-size: 16px;'><div class='legalDiv'>";
	
	if(item.type == "gold")
	{
		str += "You are about to buy " + item.reward + " gold for " + item.price + "€. Gold is a currency for Littlewargame. It can be used to buy several things like Emoticons, custom unit skins and other things. ";
		str += "Gold can not be changed back to money and it can not be transferred to other Littlewargame accounts.";
	}
	
	else if(item.type == "emotes")
		str += "You are about to buy the " + item.name + " emote for " + item.price + "€. The emote can be posted in the lobby chat.";
	
	else if(item.type == "skins")
		str += "You are about to buy the " + item.name + " skin for " + item.price + "€. This skin can be used as an alternate unit graphic in multiplayer games.";
	
	else if(item.type == "dances")
		str += "You are about to buy the " + item.name + " dance for " + item.price + "€. This dance can be used to perform a dance move in multiplayer games.";
	
	str += " (Vendor: 'Littlewargame'; owner: Johannes Bonitz, Schrobenhausener Str. 30, 80686 Munich). The bought item is fully usable for at least 3 months. After that, in rare cases, the usage might be limited or altered, for example when the game is modified through updates. ";
	str += "The payment will be handled via Paypal. The bought item will be activated and usable shortly after a successful payment. In rare cases, the activation can take longer up to several hours due to technical difficulties. ";
	str += "This is a one-time payment. No further costs are incurred.<br /><input type='checkbox' id='check1' /><label for='check1'> I have read and accepted the above text</label></div>";
	
	// agb
	str += "<div class='legalDiv'><input type='checkbox' id='check2' /><label for='check2'> I accept the <a class='underline' onclick='showAGB();'>Terms and Conditions</a></label></div>";
	
	str += "<div class='legalDiv'><input type='radio' name='legal_radio' id='check3' value='1' /><label for='check3'> I accept the <a class='underline' onclick='showWRE();'>Cancellation policy</a> and explicitly demand that you start providing the demanded service right now, before the end of the cancellation period. I am aware that I lose my right of cancellation on complete fulfilment of the contract from your side.</label>";
	str += "<br /><input type='radio' name='legal_radio' id='check4' value='2' /><label for='check4'> I do not accept and want to use the service only after the end of the cancellation period (3 months)</label></div><br />";
	
	str += getBuyButton(item.name, item.artNr + "_" + playerID, item.price) + "</span>";
	
	$('#addScrollableSubDivTextArea').html(str);
	fadeIn($('#playerInfoWindow'));
	uimanager.playerInfoWindow.setTitle("<font style='color: rgb(255, 248, 57);'>Buy item</font>");
	
	$('#buybutton_form').on('submit', onSubmit);
};

function onSubmit(e)
{
		if(!$('#check1').prop('checked'))
		{
			displayInfoMsg("You have to accept the text");
			e.preventDefault();
			return false;
		}
		
		if(!$('#check2').prop('checked'))
		{
			displayInfoMsg("You have to accept the terms and conditions");
			e.preventDefault();
			return false;
		}
		
		var radioVal = $('input[name="legal_radio"]:checked').val();
		
		if(!radioVal)
		{
			displayInfoMsg("You have to select a cancellation policy option");
			e.preventDefault();
			return false;
		}
		
		$('#buy_form_item_number')[0].value = $('#original_value')[0].value + "_" + radioVal;
		
		setTimeout(function(){
			$('#addScrollableSubDivTextArea').html("<div style='width: 100%; text-align: center; margin-top: 200px; font-size: 30px;'>Waiting while payment is being handled ...</div>");
		}, 1000);
		
		return true;
};

function showAGB()
{
	$.ajax({
		dataType: 'text',
		url: "agb.html"
	}).done(function(data){
		soundManager.playSound(SOUND.CLICK);
		uimanager.playerInfoWindow2.setTitle("<font style='color: rgb(255, 248, 57);'>Terms and conditions</font>");
		$('#addScrollableSubDivTextArea2').html("<div style='font-size: 14px;'>" + data + "</div>");
		fadeIn($('#playerInfoWindow2'));
		$('#addScrollableSubDivTextArea2')[0].scrollTop = 0;
	});
};

function showAGB2()
{
	$.ajax({
		dataType: 'text',
		url: "agb.html"
	}).done(function(data){
		soundManager.playSound(SOUND.CLICK);
		$('#agbAcceptDivSubDiv').html("<div style='font-size: 14px;'>" + data + "</div><br /><button onclick='acceptAGB();' id='acceptAGBButton'>I have read and accepted the terms and conditions</button>");
		fadeIn($('#agbAcceptDiv'));
	});
};

function showWRE()
{
	$.ajax({
		dataType: 'text',
		url: "wre.html"
	}).done(function(data){
		soundManager.playSound(SOUND.CLICK);
		uimanager.playerInfoWindow2.setTitle("<font style='color: rgb(255, 248, 57);'>Cancellation policy</font>");
		$('#addScrollableSubDivTextArea2').html("<div style='font-size: 14px;'>" + data + "</div>");
		fadeIn($('#playerInfoWindow2'));
		$('#addScrollableSubDivTextArea2')[0].scrollTop = 0;
	});
};

function showDSE()
{
	$.ajax({
		dataType: 'text',
		url: "dse.html"
	}).done(function(data){
		soundManager.playSound(SOUND.CLICK);
		uimanager.playerInfoWindow2.setTitle("<font style='color: rgb(255, 248, 57);'>Privacy Policy</font>");
		$('#addScrollableSubDivTextArea2').html("<div style='font-size: 14px;'>" + data + "</div>");
		fadeIn($('#playerInfoWindow2'));
		$('#addScrollableSubDivTextArea2')[0].scrollTop = 0;
	});
};

function getBuyButton0(artNr, price, playerID)
{
	return " <button onclick='showBuyWindow(\"" + artNr + "\", \"" + playerID + "\");' class='buy_button'><span class='buy_button_buy'>buy</span><span>&nbsp;for&nbsp;</span><span class='buy_button_price'>" + price + "€</span></button>";
};

function getBuyButton(item_name, art_nr, price)
{
	var str = ' <form target="_blank" action="https://www.paypal.com/cgi-bin/webscr" method="post" id="buybutton_form">';
	str += '<input type="hidden" name="cmd" value="_xclick" />';
	str += '<input type="hidden" name="business" value="info@teachme.com" />';
	str += '<input type="hidden" name="item_name" value="' + item_name + '" />';
	str += '<input type="hidden" id="buy_form_item_number" name="item_number" value="' + art_nr + '" />';
	str += '<input type="hidden" id="original_value" name="original_value" value="' + art_nr + '" />';
	str += '<input type="hidden" name="amount" value="' + price + '" />';
	str += '<input type="hidden" name="no_shipping" value="1" />';
	str += '<input type="hidden" name="no_note" value="1"/ >';
	str += '<input type="hidden" name="currency_code" value="EUR" />';
	// str += '<input type="image" src="imgs/paypal_button.jpg" name="submit" alt="Buy with PayPal" />';
	str += " <button type='submit' class='buy_button'><span class='buy_button_buy'>buy</span><span>&nbsp;for&nbsp;</span><span class='buy_button_price'>" + price + "€</span></button>";
	// str += '<img src="https://www.paypal.com/en_US/i/scr/pixel.gif" width="1" height="1" />';
	str += '</form>';
	
	return str;
};

var rAF = (function(){
	return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function(callback){ window.setTimeout(callback, 1000 / 100); };
})();

// validates if a username is correct
function validatePlayerName(name)
{
	return name.length > 2 && name.length < 21 && name.match(/[A-Za-z0-9\-\_]*/) == name;
};

function writeCookie()
{
	var in90Days = getGMTDateString4Days(90);
	
	// build hotkey string
	var str = "";
	var str2 = "";
	var str3 = "";
	var el = $('#customHotkeysWindowSubdiv').children();
	
	for(var i = 0; i < el.length; i++)
	{
		var el2 = $(el[i]).children("button");
		
		for(var k = 0; k < el2.length; k++)
		{
			var cmd_id = el2[k].id.split("_");
			
			// if command hotkey
			if(cmd_id[0] == "cmd" && basicCommands[cmd_id[1]])
				str += cmd_id[1] + ":" + getKeyFromStr(el2[k].innerHTML) + "#";
			
			// if ctrl grp hotkey
			if(cmd_id[0] == "ctrlgrp")
				str2 += cmd_id[1] + ":" + getKeyFromStr(el2[k].innerHTML) + "#";
			
			// if cam location hotkey
			if(cmd_id[0] == "camkey")
				str3 += cmd_id[1] + ":" + getKeyFromStr(el2[k].innerHTML) + "#";
		}
	}
	
	// obs keys
	var obskeysStr_ = "";
	for(var i = 0; i < obsKeys.length; i++)
		obskeysStr_ += obsKeys[i] + "#";
	
	// other keys
	var otherkeysStr_ = "";
	for(var i = 0; i < otherKeys.length; i++)
		otherkeysStr_ += otherKeys[i] + "#";
	
	// set name and expiration date
	// console.log(`saving name cookie ${networkPlayerName}`);
	document.cookie = "name=" + networkPlayerName + "; expires=" + in90Days;
	document.cookie = "sound_volume=" + sound_volume + "; expires=" + in90Days;
	document.cookie = "music_volume=" + music_volume + "; expires=" + in90Days;
	document.cookie = "mouse_scroll_off=" + (mouse_scroll_when_window_mode ? "false" : "true") + "; expires=" + in90Days;
	document.cookie = "open_queries=" + (open_queries ? open_queries : "0") + "; expires=" + in90Days;
	document.cookie = "dontShowFaq=" + (dontShowFaq ? "true" : "false") + "; expires=" + in90Days;
	document.cookie = "dontShowTutButton=" + (dontShowTutButton ? "true" : "false") + "; expires=" + in90Days;
	document.cookie = "hotkeys=" + str + "; expires=" + in90Days;
	document.cookie = "ctrlgrp=" + str2 + "; expires=" + in90Days;
	document.cookie = "camkey=" + str3 + "; expires=" + in90Days;
	document.cookie = "obskeys=" + obskeysStr_ + "; expires=" + in90Days;
	document.cookie = "otherkeys=" + otherkeysStr_ + "; expires=" + in90Days;
	document.cookie = "scrollSpeed=" + scrollSpeed + "; expires=" + in90Days;
	document.cookie = "mmScrollInvert=" + (mmScrollInvert ? "true" : "false") + "; expires=" + in90Days;
	document.cookie = "noShowHPBarsWhenFullHP=" + (noShowHPBarsWhenFullHP ? "true" : "false") + "; expires=" + in90Days;
	document.cookie = "noMainMenuMusic=" + (noMainMenuMusic ? "true" : "false") + "; expires=" + in90Days;
	document.cookie = "globalSoundModifierDefault=" + globalSoundModifierDefault + "; expires=" + in90Days;
	document.cookie = "scale_factor=" + SCALE_FACTOR + "; expires=" + in90Days;
	document.cookie = "noRain=" + noRain + "; expires=" + in90Days;
};


function getGMTDateString4Days(days)
{
	var date = new Date();
	date.setTime(date.getTime() + days * 24 * 60 * 60 * 1000); // actually in 90 days
	return date.toGMTString();
};

function killFaqMsg0()
{
	soundManager.playSound(SOUND.CLICK);
	displayInfoMsg("<br />Hide this message ? You will still be able to read the FAQs by clicking the F.A.Q. button in the options window.<br /><br /><button onclick='killFaqMsg();'>Yes</button> <button onclick='fadeOut($(\"#infoWindow\")); soundManager.playSound(SOUND.CLICK);'>No</button>");
};

function killFaqMsg()
{
	soundManager.playSound(SOUND.CLICK);
	$('#faqContainer').remove();
	dontShowFaq = true;	
	writeCookie();
	fadeOut($("#infoWindow"));
};

function killTutorialButton()
{
	$('#tutorialButton').remove();
	soundManager.playSound(SOUND.CLICK);
	dontShowTutButton = true;
	writeCookie();
};

function higherTerrain()
{
	editor.selectedItemType = null;
	editor.terrainModifier = 1;
	soundManager.playSound(SOUND.CLICK);
};

function lowerTerrain()
{
	editor.selectedItemType = null;
	editor.terrainModifier = -1;
	soundManager.playSound(SOUND.CLICK);
};

function addRamp()
{
	editor.selectedItemType = null;
	editor.terrainModifier = 0.5;
	soundManager.playSound(SOUND.CLICK);
};

function killRamp()
{
	editor.selectedItemType = null;
	editor.terrainModifier = -0.5;
	soundManager.playSound(SOUND.CLICK);
};

function testMap()
{
	uimanager.showLoadingScreen(lobbyPlayerManager.map, lobbyPlayerManager.getPlayerSettingsArrayObject()); // show loading screen
	mapData = game.export_(false); // save map data, so after ending test game, we can go back to the editor and reload the start map state
	soundManager.playSound(SOUND.CLICK);
	$('#lobbyGameChatInput')[0].style.visibility = 'hidden';
	$('#lobbyChatInput')[0].style.visibility = 'hidden';
	
	setTimeout(function(){
		game_state = GAME.PLAYING;
		game = new Game();
		game.loadMap(mapData);
		
		PLAYING_PLAYER = game.players[1];
		PLAYING_PLAYER.controller = CONTROLLER.HUMAN;
		
		worker.postMessage({
			what: "start-game",
			fromEditor: true,
			map: mapData,
			network_game: network_game,
			game_state: game_state,
			networkPlayerName: networkPlayerName,
			aiRandomizer: Math.ceil(Math.random() * 100000)
		});
	}, 50);
	
	game.playingFromEditor = true;
}

// is called, when a user enters values in the x/y-size inputs of the new map window in the editor, checks if theyre valid and makes then, if not
function checkNewMapInputs()
{
	var x = parseInt($('#newMapSizeX')[0].value);
	var y = parseInt($('#newMapSizeY')[0].value);
	
	if(!x)
		x = MIN_MAP_SIZE;
	
	if(!y)
		y = MIN_MAP_SIZE;
	
	if(x < MIN_MAP_SIZE)
		x = MIN_MAP_SIZE;
	
	if(y < MIN_MAP_SIZE)
		y = MIN_MAP_SIZE;
	
	if(x > MAX_MAP_SIZE)
		x = MAX_MAP_SIZE;
	
	if(y > MAX_MAP_SIZE)
		y = MAX_MAP_SIZE;
	
	$('#newMapSizeX')[0].value = x;
	$('#newMapSizeY')[0].value = y;
};

var onDrag = function(e, ui)
{
	var fiftyPercent = ui.helper.css("marginLeft").replace('px', '') < 0;
	
	var left = ui.position.left - (fiftyPercent ? (ui.helper.width() / 2) : 0);
	
	if(left < 10)
		ui.position.left = 10 + (fiftyPercent ? (ui.helper.width() / 2) : 0);
	
	if(ui.position.top < 10)
		ui.position.top = 10;
	
	if(left + ui.helper.width() > WIDTH - 10)
		ui.position.left = WIDTH - 10 - ui.helper.width() / (fiftyPercent ? 2 : 1);
	
	if(ui.position.top + ui.helper.height() > HEIGHT - 120)
		ui.position.top = HEIGHT - 120 - ui.helper.height();
};

function drawCircle(x, y, size, color, fillColor, yScale, lineWidth)
{
	var yScale_ = yScale ? yScale : 0.7;
	c.scale(1, yScale_);
	c.lineWidth = 0.75 * SCALE_FACTOR * (lineWidth ? lineWidth : 1);
	c.beginPath();
	c.arc(x, y / yScale_, size, 0, 2 * Math.PI, false);
	
	if(color)
	{
		c.strokeStyle = color;
		c.stroke();
	}
	
	if(fillColor)
	{
		c.fillStyle = fillColor;
		c.fill();
	}
	
	c.scale(1, 1 / yScale_);
};

function drawBar(x, y, w, h, percentage, color, lineWidth)
{
	var lineWidth_ = lineWidth ? Math.floor(lineWidth) : 2;
	
	c.fillStyle = "white";
	c.fillRect(x - lineWidth_, y - lineWidth_, w + lineWidth_ * 2, h + lineWidth_ * 2);
	c.fillStyle = color;
	c.fillRect(x, y, w * percentage, h);
};

function getPlNfo(player)
{
	soundManager.playSound(SOUND.CLICK);
	network.send('get-player-info<<$' + player);
};

function getLgNfo(nr)
{
	soundManager.playSound(SOUND.CLICK);
	network.send("get-league<<$" + nr);
};

function getLeagueLink(rank, addName, scale, nolink)
{
	scale = scale || 1;
	// Add link
	var str = (!nolink ? "<a class='league-link' href='#' onclick=getLgNfo(" + rank + ")>" : "");
	// Set offset
	var offset = - (10 * scale);
	str += "<span class='league-span pixelated' style='background-position: -" + (rank * 41 * scale) + "px "+ offset +"px; ";
	// Set scale
	str += "background-size: " + (4 * 200) + "%; width: " + (scale * 41) + "px; height: " + (41 * scale) + "px;'></span>";
	str += (addName ? " <span class='underline' style='float: right; margin-top: 15%;'>" + leagueNames[rank] + "</span>": "") + (!nolink ? "</a>" : "");
	return str;
};

function getPlayerLink(playerName, addColor, addClan, customAuthLevel)
{
	var playerElement = network.players[playerName];
	var className = ((addColor && playerElement) ? auth_level_css_classes[playerElement.authLevel] : "");
	if(playerElement && playerElement.premium && playerElement.authLevel < AUTH_LEVEL.MOD)
		className = "playerLinkPremium";
	if(customAuthLevel >= 0)
		className = auth_level_css_classes[customAuthLevel];
	var clan = (addClan && playerElement) ? "[<a href='#' onclick='getClanInfo(\"" + playerElement.clan + "\");' class='clanLink'>" + playerElement.clan + "</a>] " : "";
	return clan + "<a href='#' class='underline " + className + "' onclick=getPlNfo(this.innerHTML)>" + playerName + "</a>";
};

function bingMsg(msg, noSound)
{
	if(game_state == GAME.PLAYING)
		return;
	
	if(!noSound)
		soundManager.playSound(SOUND.BING2, null, 0.65);
	
	$('#bingMessageWindow').html("<p>" + msg + "</p>");
	$('#bingMessageWindow').fadeIn(1000);
	
	setTimeout(function(){
		$('#bingMessageWindow').fadeOut(1000);
	}, 4000);
};

/*
function insertName(name)
{
	var str = $('#lobbyChatInput')[0].value;
	
	str = str.split(" ");
	str[str.length - 1] = name;
	
	$('#lobbyChatInput')[0].value = str.join(" ");
	$('#lobbyChatInput')[0].focus();
	$('#nameSuggestDiv')[0].style.display = "none";
	
	soundManager.playSound(SOUND.CLICK2);
};
*/

function killTutorialButton()
{
	$('#tutorialButtonSpan').remove();
	dontShowTutButton = true;
	writeCookie();
	fadeOut($("#infoWindow"));
}

function sendActivationCode()
{
	if(sentActivationCode)
		return;
	
	sentActivationCode = true;
	
	var getString = window.location.search;
	
	if(getString.substr(0, 16) == "?activationCode=")
	{
		getString = (getString.split("="))[1];
		network.send("activate-account<<$" + getString);
	}
	
	if(getString.substr(0, 14) == "?recoveryCode=")
	{
		getString = (getString.split("="))[1];
		network.send("recover-account-2<<$" + getString);
	}
};

function editPersonalText()
{
	var b = $('#profileTextButton');
	
	if(b.html() == "edit")
	{
		$('#personalTextDiv').html("<textarea maxlength='500' id='personalTextTextArea'>" + $('#personalTextDiv').html().replace(/<br\s*[\/]?>/gi, "\n") + "</textarea>");
		b.html("save");
	}
	
	else
	{
		network.send("update-profile-text<<$" + $('#personalTextTextArea')[0].value);
		$('#personalTextDiv').html(escapeHtml($('#personalTextTextArea')[0].value).replace(/(?:\r\n|\r|\n)/g, '<br />'));
		b.html("edit");
	}
	
	soundManager.playSound(SOUND.CLICK);
};

function editClanText()
{
	var b = $('#clanTextButton');
	
	if(b.html() == "edit")
	{
		$('#clanTextDiv').html("<textarea maxlength='800' id='clanTextTextArea'>" + $('#clanTextDiv').html().replace(/<br\s*[\/]?>/gi, "\n") + "</textarea>");
		b.html("save");
	}
	
	else
	{
		network.send("update-clan-text<<$" + $('#clanTextTextArea')[0].value);
		$('#clanTextDiv').html(escapeHtml($('#clanTextTextArea')[0].value).replace(/(?:\r\n|\r|\n)/g, '<br />'));
		b.html("edit");
	}
	
	soundManager.playSound(SOUND.CLICK);
};

function importGraphic()
{
	// create new input and simulate a click on it and set function (we have to make a new one, so onchange works when the same replay is loaded 2 times in a row)
	fileInput = document.createElement("input");
	fileInput.type = "file";
	fileInput.click();
	
	fileInput.onchange = function()
	{
		var file = fileInput.files[0];
		if(file)
		{
			var reader = new FileReader();
			reader.readAsDataURL(file);
			reader.onload = function(e){
				
				var i = 1;
				var name = "newimg" + i;
				while(customImgs[name])
				{
					i++;
					name = "newimg" + i;
				}
				
				var newImg = new Image();
				newImg.src = e.currentTarget.result;
				
				newImg.onload = function(){
					customImgs[name] = [newImg].concat(ImageTransformer.replaceColors(newImg, searchColors, playerColors));
					refreshCustomImgs();
				};
			};
		}
	}
	
	soundManager.playSound(SOUND.CLICK);
};

function refreshCustomImgs()
{
	var str = "";
	
	for(key in customImgs)
		if(!unit_imgs[key] && !building_imgs[key] && key != "buildingSheet" && key != "tileSheet" && key != "miscSheet")
		{
			str += "<div class='customImgPrv' title='" + key + "'><img src='" + (customImgs[key][0].toDataURL ? customImgs[key][0].toDataURL() : customImgs[key][0].src) + "' />";
			str += "<br /><button onclick=killCustomImg('" + key + "');>x</button> <input type='text' value='" + key + "'/></div> ";
		}
	
	$('#customGraphicsDiv').html(str);
};

function saveCustomGraphics()
{
	var divs = $('.customImgPrv').toArray();
	
	for(var i = 0; i < divs.length; i++)
	{
		var newName = $(divs[i]).children("input").toArray()[0].value;
		var oldName = divs[i].title;
		
		if(newName != divs[i].title)
		{
			if(newName.length > 20 || newName.length < 3 || newName.match(/[A-Za-z0-9]*/) != newName)
			{
				displayInfoMsg(newName + " is not a valid name (3 - 20 chars, letters and numbers only)!");
				return;
			}
			
			if(customImgs[newName])
			{
				displayInfoMsg(newName + " is already used!");
				return;
			}
			
			customImgs[newName] = customImgs[oldName];
			
			delete customImgs[oldName];
		}
	}
	
	fadeOut($('#customGraphicsWindow'));
	soundManager.playSound(SOUND.CLICK);
};

function killCustomImg(key)
{
	if(!unit_imgs[key] && !building_imgs[key] && customImgs[key])
	{
		for(var i = 0; i < game.graphics.length; i++)
			if(game.graphics[i].file == customImgs[key])
				game.graphics[i].file = miscSheet;
		
		delete customImgs[key];
	}
	
	refreshCustomImgs();
	
	soundManager.playSound(SOUND.CLICK);
};

function getQueryMsg(networkArray)
{
	var msg = networkArray[7] ? kappa(escapeHtml(networkArray[7]), networkArray[1]) : "";
	
	if(networkArray[4] == "2")
		return "<span style='color: rgb(189, 189, 189);'>This player does not exist.</span>";
	
	if(networkArray[4] == "9")
		return "<span style='color: rgb(189, 189, 189);'>This player ignores you.</span>";
	
	if(!msg || msg.length == 0)
		return "";
	
	else
	{
		var note = networkArray[4] == 1 ? "<span style='color: rgb(189, 189, 189);'> (This player is offline. The message will be delivered when he goes online.)</span>" : "";
		return (networkArray[3].length > 0 ? getPlayerLink(escapeHtml(networkArray[3]), true, false, (networkArray[6] == "true" && networkArray[5] < AUTH_LEVEL.MOD) ? "playerLinkPremium" : networkArray[5]) : "") + ": " + msg + note;
	}
};

function startChatWith(playerName)
{
	soundManager.playSound(SOUND.CLICK);
	
	var found = false;
	
	for(var i = 0; i < uimanager.queries.length; i++)
		if(uimanager.queries[i].name == playerName)
		{
			uimanager.queries[i].activate();
			uimanager.queries[i].i.focus();
			found = true;
		}
	
	if(!found)
	{
		var q = new Query(playerName);
		uimanager.queries.push(q);
		q.activate();
		q.i.focus();
	}
};

function reallyBan(player)
{
	soundManager.playSound(SOUND.CLICK);
	displayInfoMsg("Ban " + player + " for how many hours ?<br /><br /><input type='text' id='time2Ban' value ='0'/><br /><br />");
	var button = uimanager.createButton("confirmBanButton", "ban this fucker", function(){
		network.send("ban<<$" + this.player_ + "<<$" + $('#time2Ban').val());
		soundManager.playSound(SOUND.CLICK);
	});
	button.player_ = player;
	$('#infoWindowTextArea').append(button);
};

function getPlayerNameArrayFromPlayerSettingsArrayObject(o)
{
	var arr = [];
	for(var i = 0; i < o.length; i++)
		arr.push(o[i].name);
	return arr;
};

function getFormattedTime()
{
	// get time (hh:mm)
	var timeObject = new Date();
	var minutes = timeObject.getMinutes();
	minutes = minutes < 10 ? "0" + minutes : minutes;
	return timeObject.getHours() + ":" + minutes;
};

function toggleFullscreen(element)
{
	if(element.requestFullScreenWithKeys)
	{
		if(!document.fullScreen)
			element.requestFullScreenWithKeys();
		else
			document.exitFullScreen();
	}
	
	if(element.requestFullScreen)
	{
		if(!document.fullScreen)
			element.requestFullscreen();
		else
			document.exitFullScreen();
	}
	 
	else if(element.mozRequestFullScreen)
	{
		if(!document.mozFullScreen)
			element.mozRequestFullScreen();
		else
			document.mozCancelFullScreen();
	}
	 
	else if(element.webkitRequestFullScreen)
	{
		if(!document.webkitIsFullScreen)
			element.webkitRequestFullScreen(element.ALLOW_KEYBOARD_INPUT);
		else
			document.webkitCancelFullScreen();
	}
	
	resize();
};

function createExplosion(x, y, size)
{
	var pos = new Field(x, y);
	
	for(var i = 0; i < 15; i++)
		new Sprite({
			from: pos.add2(Math.random() * Math.PI * 2, Math.random()),
			img: imgs.particle.img,
			scaleFunction: i < 10 ? function(){ return 4; } : function(){ return 6; },
			age: 1.3 + Math.random(),
			r1: Math.random() * 0.4,
			r2: Math.random() * 5 - 3,
			r3: Math.random() * 5 - 3,
			zFunction: function(age){ return Math.min(Math.pow(age * 1.6 - 1.5 + this.r1, 2) - 2.2, 0); },
			xFunction: function(age){ return Math.sqrt(age) * this.r2; },
			yFunction: function(age){ return Math.sqrt(age) * this.r3; }
		});
	
	new Dust({from: pos, scale: size + Math.random(), ageScale: 2 + Math.random()});
	
	for(var i = 0; i <= 2; i++)
		new Dust({from: pos.add3(Math.random() - 0.5, 0), scale: size + Math.random(), ageScale: 2 + Math.random(), height: Math.random()});
	
	// create big fire and smoke effects
	for(var i = 0; i <= 2; i++)
	{
		setTimeout(function(){
			new Sprite({
				from: new Field(x, y, true).add2(Math.random() * Math.PI * 2, Math.random() * 0.5),
				img: imgs["fire" + (Math.floor(Math.random() * 4) + 1)],
				scaleFunction: function(age){ return (1 / (age + 0.25) + age - 4) * (-2) + this.r1; },
				r1: 1 + Math.random() * 2,
				zFunction: function(age){ return -age * 2; }
			});
		}, i * 317);
		
		setTimeout(function(){
			for(var k = 0; k <= 1; k++)
				new Dust({from: pos.add3(Math.random() - 0.5, 0), scale: size + Math.random(), ageScale: 2 + Math.random(), height: Math.random() - 0.5});
		}, i * 333);
	}
	
	// create side smoke effects (big dust clouds that go sideways)
	for(var i = 0; i < Math.PI * 2; i += Math.random() * 1.5)
		new Dust({
			from: pos,
			scale: Math.random() * 7 + 1.5,
			ageScale: 2,
			vz: 0.01,
			xFunction: function(age){
				return ((-1) / (age + 0.3) + 3) * this.x_;
			},
			yFunction: function(age){
				return ((-1) / (age + 0.3) + 3) * this.y_;
			},
			x_: Math.cos(i),
			y_: Math.sin(i)
		});
	
	// create soot
	game.groundTilesCanvas.getContext('2d').drawImage(miscSheet[0], imgs.soot.img.x, imgs.soot.img.y, imgs.soot.img.w, imgs.soot.img.h, x * FIELD_SIZE / SCALE_FACTOR - imgs.soot.img.w / 2, (y + 2) * FIELD_SIZE / SCALE_FACTOR - imgs.soot.img.h / 2, imgs.soot.img.w, imgs.soot.img.h);
};

function startGame(ignoreSameTeam)
{
	if(ignoreSameTeam)
		fadeOut($('#infoWindow'));
	
	network.send("cancel-ladder");
	fadeOut($('#ladderWindow'));
	
	soundManager.playSound(SOUND.CLICK);
	
	// check if all players are on the same team, and display warning, if yes
	var team = -1;
	var ok = $('[name="teamButton"]').length <= 1;
	
	$('[name="teamButton"]').each(function(){
		var newTeam = parseInt(this.innerHTML.split(" ")[1]);
		if(team == -1)
			team = newTeam;
		else if(team != newTeam)
			ok = true;
	});
	
	if(!ok && !ignoreSameTeam)
	{
		displayInfoMsg("<p>Everyone is on the same team !</p><br /><button onclick='startGame(true);'>start anyway</button>");
		return;
	}
	
	// if multiplayer, send msg to server, that we wanna start
	if(game_state == GAME.LOBBY && network && network.socket)
		network.send("start-game");
	
	// if singleplayer
	else
	{
		// show loading screen
		uimanager.showLoadingScreen(lobbyPlayerManager.map, lobbyPlayerManager.getPlayerSettingsArrayObject());
		
		setTimeout(function(){
			game_state = GAME.PLAYING;
			mapData = "";
			
			var aiRandomizer = Math.ceil(Math.random() * 100000);
			game = new Game();
			game.loadMap(lobbyPlayerManager.map, lobbyPlayerManager.getPlayerSettingsArrayObject(), aiRandomizer);
			
			worker.postMessage({
				what: "start-game",
				map: lobbyPlayerManager.map,
				players: lobbyPlayerManager.getPlayerSettingsArrayObject(),
				network_game: network_game,
				game_state: game_state,
				networkPlayerName: networkPlayerName,
				aiRandomizer: aiRandomizer
			});
		}, 50);
	}
	$('#lobbyGameChatInput')[0].style.visibility = 'hidden';
};

function updatePlayerDropdowns()
{
	for(var i = 0; i < MAX_PLAYERS; i++)
	{
		var state = $("#pl_slot_" + i).val();
		$("#pl_team_" + i)[0].style.visibility = state == "closed" ? "hidden" : "visible";
		$("#pl_ai_" + i)[0].style.visibility = state == "computer" ? "visible" : "hidden";
	}
};

function getPlayerSettings()
{
	var arr = [];
	for(var i = 0; i < MAX_PLAYERS; i++)
		arr.push({
			slot: $("#pl_slot_" + i).val(),
			team: $("#pl_team_" + i).val(),
			ai: $("#pl_ai_" + i).val()
		});
	return arr;
};

function refreshPlayerSettingsHTML(arr)
{
	for(var i = 0; arr && i < arr.length; i++)
	{
		$('#pl_slot_' + i).val(arr[i].slot);
		$('#pl_team_' + i).val(arr[i].team);
		$('#pl_ai_' + i).val(arr[i].ai);
	}
	
	updatePlayerDropdowns();
}

function getDefaultPlayerSettings(countPlayers)
{
	var arr = [];
	
	var count = parseInt(countPlayers ? countPlayers : MAX_PLAYERS);
	if(!(count >= 1 && count <= MAX_PLAYERS))
		count = 2;
	
	for(var i = 0; i < MAX_PLAYERS; i++)
		arr.push({
			slot: i < count ? "open" : "closed",
			team: "any",
			ai: "normal AI"
		});
	
	return arr;
};

function realTimeCompile(htmlEl, compilerType)
{
	var jqueryEL = $("#" + htmlEl.parentNode.id).parent().parent();
	var parseResult = new Compiler(compilerType).parse($(htmlEl).val());

	jqueryEL.prop("title", parseResult[0] ? "condition is ok" : parseResult[1]);
	jqueryEL.tooltip({content: jqueryEL.prop("title")});
	jqueryEL.tooltip("open");
}

function getRankCode(text)
{
	return text.replace(/S/g, "<img src='imgs/star-white.png' style='margin-bottom: -2px;' /> ")
		.replace(/Y/g, "<img src='imgs/star-yellow.png' style='margin-bottom: -2px;' /> ")
		.replace(/G/g, "<img src='imgs/star-green.png' style='margin-bottom: -2px;' /> ")
		.replace(/R/g, "<img src='imgs/star-red.png' style='margin-bottom: -2px;' /> ");
}

function getAINamesArray()
{
	var arr = ["Normal AI"];
	for(var i = 0; i < countCustomAIFunctions; i++)
		arr.push("Custom AI " + (i + 1));
	return arr;
};

function createGame(indexOrName, mapImg)
{
	var name = $('#gameNameInput').val().trim();
	var pw = $('#gamePWInput').val();
	
	soundManager.playSound(SOUND.CLICK);
	
	if(!(name.length < 21 && name.match(/[A-Za-z0-9\-\_\?\!\(\)\[\]\+\#\.\:\,\;\* ]*/) == name))
	{
		displayInfoMsg("invalid game name");
		return;
	}
	
	if(!(pw.length < 21 && pw.match(/[A-Za-z0-9\-\_\?\!\(\)\[\]\+\#\.\:\,\;\* ]*/) == pw))
	{
		displayInfoMsg("invalid password");
		return;
	}
	
	network.send("create-game-custom<<$" + indexOrName + "<<$" + GAME_VERSION + "<<$" + (createdMulti && game_state != GAME.EDITOR ? "1" : "0") + "<<$" + name + "<<$" + pw);
	$('#selectMapArea').html("<br /><br /><br /><br /><br /><br /><span id='loading'>loading...</span>");
	
	currentMapImg = mapImg;
};
function requestNewSkirmishMap(mapID, mapImg)
{
	network.send("change-map<<$"+mapID);
	currentMapImg = mapImg;
};

function joinPWGame(game_id)
{
	network.send("join-game<<$" + game_id + "<<$" + GAME_VERSION + "<<$" + $('#game_pw').val());
	fadeOut($('#infoWindow'));
	soundManager.playSound(SOUND.CLICK);
};

function requestCustomMapsPage(page, onlyTutorials)
{
	if(game_state == GAME.EDITOR)
	{
		network.send("get-custom-maps-editor<<$" + page + "<<$" + $('#mapSearchInput')[0].value + "<<$" + $('#mapSearchSelect')[0].value);
		$('#loadExternalButton')[0].style.visibility = "visible";
	}
	else
	{
		network.send("get-custom-maps<<$" + page + "<<$" + $('#mapSearchInput')[0].value + "<<$" + $('#mapSearchSelect')[0].value + "<<$" + (onlyTutorials ? "1" : "0"));
		$('#loadExternalButton')[0].style.visibility = "hidden";
	}
	
	$('#selectMapArea').html("<br /><br /><br /><br /><br /><br /><span id='loading'>loading...</span>");
	soundManager.playSound(SOUND.CLICK);
};

function displayInfoMsg(msg)
{
	fadeIn($('#infoWindow'));
	$('#infoWindowTextArea').html(msg);
};

function displayInfoMsg2(msg, arch_sound)
{
	fadeIn($('#darkScreenDiv'));
	fadeIn($('#infoWindow2'));
	$('#infoWindowTextArea2').html(msg);
	soundManager.playSound(arch_sound ? SOUND.ARCHIVEMENT : SOUND.OPEN_WINDOW, null, 0.7);
};

function sendFriendRequest()
{
	network.send("add-friend<<$" + $('#newFriendInput')[0].value);
};

function showAllDivisions()
{
	var str = "";
	
	var x = 10;
	var y = 10;
	
	for(var i = 0; i < leagueNames.length; i++)
	{
		str += "<div style='position: absolute; left: " + x + "px; top: " + y + "px;'>" + getLeagueLink(i, true, 3) + "</div>";
		
		y += 100;
		
		if(i == 3)
		{
			y = 10;
			x += 270;
		}
	}
	
	uimanager.playerInfoWindow.setTitle("<font style='color: rgb(255, 248, 57);'>Divisions</font>");
	$('#addScrollableSubDivTextArea').html(str);
	fadeIn($("#playerInfoWindow"));
};

function clearCache()
{
	var cache1 = false;
	var cache2 = false;
	
	for(var i = 0; i < game.buildings.length; i++)
	{
		if(game.buildings[i].owner.isEnemyOfPlayer(PLAYING_PLAYER))
			cache1 = true;
		
		else if(game.buildings[i].owner.controller != CONTROLLER.NONE)
			cache2 = true;
	}
	
	if(cache1 && network_game)
		network.send("cache-clear");
	
	else if(cache2 && network_game)
		network.send("cache-clear-extended");
};


var visionOffsets = [];
var countCircles = 6;

for(var i = 0; i <= countCircles; i++)
	visionOffsets[i] = [];

for(var x = -7; x <= countCircles + 1; x++)
	for(var y = -7; y <= countCircles + 1; y++)
	{
		var dist = Math.sqrt(x * x + y * y);
		
		for(var i = 0; i <= countCircles; i++)
			if(dist <= i && dist >= i - 1)
				visionOffsets[i].push([x, y]);
	}

function getPlayerCountFromMap(map)
{
	var players = [];
	var units = map.units.concat(map.buildings);
	for(var k = 0; k < units.length; k++)
		if(units[k].owner != 0 && !players.contains(units[k].owner))
			players.push(units[k].owner);
	
	return players.length;
};

function getImageFromMap(map)
{
	var imgSize = 265;
	
	var newCanvas = document.createElement('canvas');
	newCanvas.width = imgSize;
	newCanvas.height = imgSize;
	var ctx = newCanvas.getContext("2d");
	
	// set scales
	var scale_x = imgSize / map.x;
	var scale_y = imgSize / map.y;
	
	// fill map with default tiles background
	ctx.fillStyle = map.defaultTiles[0].toUnitType().minimapColor;
	ctx.fillRect(0, 0, imgSize, imgSize);
	
	// draw tiles
	for(var k = 0; k < map.tiles.length; k++)
	{
		var type = map.tiles[k].type.toUnitType();
		if(type.blocking)
		{
			ctx.fillStyle = type.minimapColor;
			ctx.fillRect((map.tiles[k].x - 1) * scale_x, (map.tiles[k].y - 1) * scale_y, type.sizeX * scale_x, type.sizeY * scale_y);
		}
	}
	
	// draw buildings
	for(var k = 0; k < map.buildings.length; k++)
	{
		var type = map.buildings[k].type.toUnitType();
		var size = type ? type.size : 3;
		
		if(map.buildings[k].owner == 0 && map.buildings[k].type.alwaysNeutral)
			ctx.fillStyle = "yellow";
		
		else if(map.buildings[k].owner == 0)
			ctx.fillStyle = "#4DA6AE";
		
		else
		{
			var colorArray = playerColors[map.buildings[k].owner - 1][4];
			ctx.fillStyle = "rgba(" + colorArray[0] + ", " + colorArray[1] + ", " + colorArray[2] + ", 1)";
		}
		
		ctx.fillRect((map.buildings[k].x - 1) * scale_x, (map.buildings[k].y - 1) * scale_y, size * scale_x, size * scale_y);
	}
	
	return newCanvas.toDataURL("image/png");
};

var interpreter = [
	
	{
		funcName: "getField",
		func: function(s){
			var type = s.replace(/ /g, "").split(".");
			
			if(lists.types[type[0]])
			{
				if(lists.types[type[0]][type[1]] && typeof lists.types[type[0]][type[1]] !== "number")
					return lists.types[type[0]][type[1]];
				
				if(lists.types[type[0]].isUpgrade)
					return lists.types[type[0]].getValue(type[1], PLAYING_PLAYER, true) * ((list_upgrade_fields[type[1]] && list_upgrade_fields[type[1]].displayScale) ? list_upgrade_fields[type[1]].displayScale : 1);
				
				else if(lists.types[type[0]].isUnit)
					return lists.types[type[0]].getValue(type[1], PLAYING_PLAYER) * ((list_unit_fields[type[1]] && list_unit_fields[type[1]].displayScale) ? list_unit_fields[type[1]].displayScale : 1);
				
				else if(lists.types[type[0]].isBuilding)
					return lists.types[type[0]].getValue(type[1], PLAYING_PLAYER) * ((list_building_fields[type[1]] && list_building_fields[type[1]].displayScale) ? list_building_fields[type[1]].displayScale : 1);
				
				else if(lists.types[type[0]].isModifier)
					return lists.types[type[0]].getValue(type[1], PLAYING_PLAYER) * ((list_modifiers_fields[type[1]] && list_modifiers_fields[type[1]].displayScale) ? list_modifiers_fields[type[1]].displayScale : 1);
				
				else // ability
					return lists.types[type[0]].getValue([type[1]], game.selectedUnits[0]) * ((list_ability_fields[type[1]] && list_ability_fields[type[1]].displayScale) ? list_ability_fields[type[1]].displayScale : 1);
			}
			
			return "";
		}
	},
	
	{
		funcName: "getUpgradeLevel",
		func: function(s){
			var type = lists.types[s.replace(/ /g, "")];
			return type ? PLAYING_PLAYER.getUpgradeLevel(type) : 0;
		}
	},
	
	{
		funcName: "upgradeCountInResearch",
		func: function(s){
			var type = lists.types[s.replace(/ /g, "")];
			return type ? PLAYING_PLAYER.upgradeCountInResearch(type) : 0;
		}
	},
	
	{
		funcName: "add",
		func: function(s){
			var numbers = s.replace(/ /g, "").split(",");
			var number = 0;
			for(var i = 0; i < numbers.length; i++)
				number += parseInt(numbers[i]);
			return number;
		}
	},
	
	{
		funcName: "mul",
		func: function(s){
			var numbers = s.replace(/ /g, "").split(",");
			var number = 1;
			for(var i = 0; i < numbers.length; i++)
				number *= parseInt(numbers[i]);
			return number;
		}
	},
	
	{
		funcName: "sub",
		func: function(s){
			var numbers = s.replace(/ /g, "").split(",");
			var number = parseInt(numbers[0]);
			for(var i = 1; i < numbers.length; i++)
				number -= parseInt(numbers[i]);
			return number;
		}
	},
	
	{
		funcName: "div",
		func: function(s){
			var numbers = s.replace(/ /g, "").split(",");
			var number = parseInt(numbers[0]);
			for(var i = 1; i < numbers.length; i++)
				number /= parseInt(numbers[i]) ? parseInt(numbers[i]) : 1;
			return number;
		}
	}
	
];

function interpreteString(s, unit)
{
	if(typeof s !== "string")
		return "";
	
	for(var i = 0; i < interpreter.length; i++)
	{
		var data = interpreter[i];
		
		var s1 = s.indexOf(data.funcName + "(");
		var s2 = s.indexOf(")", s1);
		
		while(s1 >= 0 && s2 >= 0 && s2 > s1)
		{
			var s3 = s.split(data.funcName + "(");
			s3[1] = s3.slice(1).join(data.funcName + "(");
			var s4 = s3[1].split(")");
			s4[1] = s4.slice(1).join(")");
			
			s = s3[0] + data.func(s4[0], unit) + s4[1];
			
			s1 = s.indexOf(data.funcName + "(");
			s2 = s.indexOf(")", s1);
		}
	}
	
	return s;
};

// gets called when all the images are loaded, creates the color specific unit images from the original ones
function createColorTransformedUnitImages()
{
	var animNames = ["idle", "walk", "walkGold", "attack", "die", "special1", "dance1", "dance2"];
	
	// units
	_.each(unit_imgs, function(img){
		var img_ = img.idle ? img.idle : img.walk;
		
		img.file = [img.file].concat(ImageTransformer.replaceColors(img.file, searchColors, playerColors));
		img.file = img.file.concat(ImageTransformer.getGreyScaledImage(img.file[0]));
		
		// creating non existing images by linking them to walk img
		for(var i = 0; i < animNames.length; i++)
			if(!img[animNames[i]])
				img[animNames[i]] = img.walk;
	});
	
	buildingSheet = [buildingSheet].concat(ImageTransformer.replaceColors(buildingSheet, searchColors, playerColors));
	buildingSheet = buildingSheet.concat(ImageTransformer.getGreyScaledImage(buildingSheet[0]));
	
	miscSheet = [miscSheet].concat(ImageTransformer.replaceColors(miscSheet, searchColors, playerColors));
	miscSheet = miscSheet.concat(ImageTransformer.getGreyScaledImage(miscSheet[0]));
	
	tileSheet = [tileSheet].concat(ImageTransformer.replaceColors(tileSheet, searchColors, playerColors));
	tileSheet = tileSheet.concat(ImageTransformer.getGreyScaledImage(tileSheet[0]));
};

// draw wrapped text (returns the number of drawed lines)
function drawText(ctx, text, color, size, x, y, w, align, alpha, fillStyle, shadowStyle, height)
{
	var text2 = text;
	var w2 = w ? w : 99999;
	alpha = alpha ? alpha : 1;
	var returnValue = 1; // number of lines we used to draw the text
	
	ctx.font = size;
	ctx.textAlign = align ? align : "left";
	
	// check if text fits in line, if not, recursively call for next line
	if(ctx.measureText(text).width > w2)
	{
		var words = text.split(" ");
		
		var line = words[0];
		var lastFittingLine;
		var i = 1;
		
		while(ctx.measureText(line).width <= w2 && i < words.length)
		{
			lastFittingLine = line;
			line = line + " " + words[i];
			i++;
		}
		
		text2 = lastFittingLine ? lastFittingLine : text;
		
		words.splice(0, Math.max(i - 1, 1));
		
		if(words.length > 0)
			returnValue += drawText(ctx, words.join(" "), color, size, x, y + height + 4, w2, align, alpha, fillStyle, shadowStyle, height);
	}
	
	var textWidth = ctx.measureText(text2).width;
	
	// round
	var x2 = Math.floor(x);
	var y2 = Math.floor(y);
	
	// fillrect, if fillstyle parameter passed
	if(fillStyle)
	{
		ctx.globalAlpha = alpha;
		ctx.fillStyle = fillStyle;
		ctx.fillRect(x2 - (align == "center" ? (textWidth + 6) / 2 : 0), y2 - height * 0.9, textWidth + 6, height * 1.1);
	}
	
	// nu shadow
	// ctx.shadowColor = shadowStyle ? shadowStyle : "black";
	// ctx.shadowBlur = 3;
	
	// draw text
	ctx.fillStyle = color;
	ctx.fillText(text2, x2, y2);
	ctx.globalAlpha = 1;
	
	// ctx.shadowBlur = 0;
	
	return returnValue;
};

// loads an image and returns the image object. Also increments the ressourcesToLoad variable. This gets decremented when img is loaded, so we can check this variable and only start the game when its 0
function loadImage(imgFile)
{
	ressourcesToLoad++;
	
	var img = new Image();
	
	img.onload = function() { ressourceLoaded(img); };
	img.src = imgFile;
	img.srcCpy = imgFile; // in case we must load img again, store the path
	
	return img;
};

var tileSheet = loadImage("imgs/tileSheet.png");
var miscSheet = loadImage("imgs/miscSheet.png");
var buildingSheet = loadImage("imgs/buildingSheet_new.png");

// when window gets resized, this is calld
function resize()
{
	WIDTH = window.innerWidth;
	HEIGHT = window.innerHeight;
	canvas.width = WIDTH;
	canvas.height = HEIGHT;
	
	// Settings
	c.mozImageSmoothingEnabled = false;
	c.imageSmoothingEnabled = false;
};

// decreses the ressourcesToLoad counter and and starts the game if all ress are loaded
function ressourceLoaded(img)
{
	// if not loaded, try again
	if(img && (!img.complete || !(img.width > 0)))
	{
		img.src = "";
		img.src = img.srcCpy;
		return;
	}
	
	ressourcesToLoad--;
	
	// display % loaded
	var numberOfRessources = Math.max(80, ressourcesToLoad);
	c.fillRect(WIDTH / 2 - 296, HEIGHT - 146, 592 * ((numberOfRessources - ressourcesToLoad) / numberOfRessources), 42);
	
	// if all images are loaded, do some final stuff and then start the game
	if(ressourcesToLoad == 0)
	{
		// load music
		musicManager = new MusicManager(music_volume, sound_volume);
		musicManager.bindEvents();
		
		// load sound
		soundManager = new SoundManager();
		
		// load replace colors
		var len = searchColors.length;
		var colorsImg = ImageTransformer.getImgFromSheet(tileSheet, {x: 196, y: 0, w: len, h: 1});
		var colorsImgData = colorsImg.getContext('2d').getImageData(0, 0, colorsImg.width, colorsImg.height).data;
		for(var i = 0; i < len; i++)
			searchColors[i] = [colorsImgData[i * 4], colorsImgData[i * 4 + 1], colorsImgData[i * 4 + 2]];
		
		// create images for units for the other players by transforming colors from original image
		createColorTransformedUnitImages();
		
		// load tile imgs from spritesheet
		var tiles = tileTypes.concat(cliffs, cliffs_winter, egypt_cliffs, grave_cliffs, ramp_tiles, ramp_tiles_egypt, ramp_tiles_grave);
		for(var i = 0; i < tiles.length; i++)
		{
			tiles[i].img.frameWidth = tiles[i].img.w;
			tiles[i].img = {img: tiles[i].img, file: tileSheet, name: tiles[i].name};
			
			tiles[i].minimapColor = tiles[i].minimap_color ? tiles[i].minimap_color : ImageTransformer.getAverageColor(tiles[i].img);
			
			if(tiles[i].imgEditor)
				tiles[i].img.imgEditor = tiles[i].imgEditor;
			
			tileImgs[tiles[i].name] = tiles[i].img;
		}
		
		for(var i = 0; i < tileTypes.length; i++)
		{
			building_imgs[tileTypes[i].name] = tileTypes[i].img;
			tileTypes[i].img = tileTypes[i].name;
		}
		
		for(key in building_imgs)
			building_imgs[key].name = key;
		
		for(key in imgs)
		{
			imgs[key].frameWidth = 0;
			imgs[key] = {
				img: imgs[key],
				name: key,
				id_string: key,
				file: miscSheet
			};
		}
		
		if(network && network.connected)
			sendActivationCode();
		
		initCustomImgsObj();
		
		$('#loadingSoldier').remove();
		// Login after this?
		
		// start Main Loop
		rAF(mainLoop);
	}
};

function initCustomImgsObj()
{
	for(key in customImgs)
		delete customImgs[key];
	
	for(key in unit_imgs)
		customImgs[key] = unit_imgs[key].file;
	
	customImgs["buildingSheet"] = buildingSheet;
	customImgs["tileSheet"] = tileSheet;
	customImgs["miscSheet"] = miscSheet;
};
// parent class for map object types (unit types, building typed, tile / doodas types)
function MapObjectType()
{
	this.projectileLen = 0.2;
	this.projectileStartHeight = 0;
	this.projectileSpeed = 8;
	this.imageScale = 1;
	this.canAttackGround = true;
	this.isHeatSeeking = true;
	this.aoeRadius = 0;
	this.isInvisible = false;
	this.noShow = false;
	this.controllable = true;
	this.hasDetection = false;
};

MapObjectType.prototype.replaceReferences = function()
{
	var t = this;
	if(this.commands)
		_.each(this.commands, function(c, key){
			if(typeof c == "string")
				t.commands[key] = lists.types[c];
		});
	
	if(this.img && (typeof this.img == "string"))
		this.img = lists.imgs[this.img] ? lists.imgs[this.img] : (this.isBuilding ? lists.imgs.castle : lists.imgs.soldier);
	
	if(this.modifiers)
		for(var k = 0; k < this.modifiers.length; k++)
			if(typeof this.modifiers[k] == "string")
				this.modifiers[k] = lists.types[this.modifiers[k]];
	
	if(this.modifiersSelf)
		for(var k = 0; k < this.modifiersSelf.length; k++)
			if(typeof this.modifiersSelf[k] == "string")
				this.modifiersSelf[k] = lists.types[this.modifiersSelf[k]];
	
	if(this.spawnModifiers)
		for(var k = 0; k < this.spawnModifiers.length; k++)
			if(typeof this.spawnModifiers[k] == "string")
				this.spawnModifiers[k] = lists.types[this.spawnModifiers[k]];
	
	if(this.modifiersPerLevel)
		for(var k = 0; k < this.modifiersPerLevel.length; k++)
			if(typeof this.modifiersPerLevel[k] == "string")
				this.modifiersPerLevel[k] = lists.types[this.modifiersPerLevel[k]];
	
	if(this.costIncreaseGroup)
		for(var k = 0; k < this.costIncreaseGroup.length; k++)
			if(typeof this.costIncreaseGroup[k] == "string")
				this.costIncreaseGroup[k] = lists.types[this.costIncreaseGroup[k]];
};

MapObjectType.prototype.getValue = function(value, owner)
{
	return this[value] + owner.getValueModifier(value, this);
};

MapObjectType.prototype.toString = function()
{
	return this.name;
};

// where would this be placed regarding the current mouse cursor pos
MapObjectType.prototype.getFieldFromMousePos = function()
{
	return game.getFieldFromPos(null, null, !this.isCliff).add3(-this.sizeX / 2 + 0.5, -this.sizeY / 2 + 0.5);
};

MapObjectType.prototype.getDataFields = function()
{
	return this.isUnit ? list_unit_fields : list_building_fields;
};

MapObjectType.prototype.draw = function(x, y)
{
	var img = this.img.img;
	var scale = this.getValue("imageScale", PLAYING_PLAYER) * SCALE_FACTOR;
	
	var x_ = 0;
	var y_ = 0;
	
	// decorations coords are exact pixels
	if(this.ignoreGrid)
	{
		x_ = Math.floor((x - (img.w / 2) * SCALE_FACTOR) / SCALE_FACTOR) * SCALE_FACTOR - game.cameraX;
		y_ = Math.floor(((y + 3 * SCALE_FACTOR) - (img.h / 2) * SCALE_FACTOR) / SCALE_FACTOR) * SCALE_FACTOR - game.cameraY;
	}
	
	else
	{
		x_ = (x - 1 + this.sizeX / 2) * FIELD_SIZE - game.cameraX - img.w / 2 * scale;
		y_ = (y - 1 + this.sizeY) * FIELD_SIZE - game.cameraY - img.h * scale;
	}
	
	var nr = Math.max(PLAYING_PLAYER.number, 1);
	
	c.drawImage(this.img.file[this.img.file[nr] ? nr : 0], img.x, img.y, img.w, img.h, x_, y_, img.w * scale, img.h * scale);
};

MapObjectType.prototype.couldBePlacedAt = function(field, dontIgnoreHiddenBlocks)
{
	var checkObj = dontIgnoreHiddenBlocks ? PLAYING_PLAYER.team : game;
	var distanceAllowed = true;
	
	for(var x = field.x; x < field.x + this.sizeX; x++)
		for(var y = field.y; y < field.y + this.sizeY; y++)
		{
			// get the nearest CC, Goldmine and Start Location, because those are not allowed to be placed near eachother
			var f = new Field(x, y);
			var nextGoldmine = game.getNextBuildingOfType(f, null, false, "startGold");
			var nextCC = game.getNextBuildingOfType(f, null, false, "takesGold");
			
			if(this.takesGold && nextGoldmine && nextGoldmine.pos.distanceTo2(f) < game.globalVars.mineDist)
				distanceAllowed = false;
			
			if(this.startGold && nextCC && nextCC.pos.distanceTo2(field) < game.globalVars.mineDist)
				distanceAllowed = false;
			
			if(checkObj.fieldIsBlockedForBuilding(x, y) || !distanceAllowed)
				return false;
		}
	
	return true;
};

MapObjectType.prototype.getTitleImage = function()
{
	var img = (game_state == GAME.EDITOR && this.img.imgEditor) ? this.img.imgEditor : this.img.img;
	
	return {file: this.img.file[0], x: img.x, y: img.y, w: img.w, h: img.h};
};
UnitType.prototype = new MapObjectType();
function UnitType(data)
{
	_.extend(this, data);
	
	// copy arrays (so they dont get only referenced)
	var thisRef = this;
	_.each(data, function(val, key){
		thisRef[key] = Object.prototype.toString.call(thisRef[key]) === "[object Array]" ? thisRef[key].slice() : thisRef[key];
	});
	
	// copy command object
	this.commands = copyObject(this.commands);
	
	this.minimapColor = "#ffffff";
	
	this.isUnit = true;
	
	this.dustCreationChance = this.dustCreationChance ? this.dustCreationChance : 0.05; // if not set, use default which is 0,05
	
	this.minRange = this.minRange ? this.minRange : -999; // if no min range is set, set it to -999 (otherwise some calculations would fail)
	
	this.id = game.unitTypeIdCounter++;
	
	this.animSpeed = this.animSpeed ? this.animSpeed : 1.5;
	
	this.oscillationAmplitude = this.oscillationAmplitude ? this.oscillationAmplitude : 0;
	
	this.yesSound = this.yesSound ? this.yesSound : SOUND.YES;
	this.yesSoundVolume = this.yesSoundVolume ? this.yesSoundVolume : 0.6;
	this.readySound = this.readySound ? this.readySound : SOUND.READY;
	this.readySoundVolume = this.readySoundVolume ? this.readySoundVolume : 0.9;
	
	this.selectionOffsetY = this.selectionOffsetY ? this.selectionOffsetY : 0;
	this.height = this.height ? this.height : 0.3;
	this.deathAnimationSpeed = data.deathAnimationSpeed ? data.deathAnimationSpeed : 0.6;
};

UnitType.prototype.addToLists = function()
{
	lists.types[this.id_string] = this;
	lists.unitTypes[this.id_string] = this;
};

// get the title img of this unit type; if nr is passed, return img of color of player nr, else return of player PLAYING_PLAYER
UnitType.prototype.getTitleImage = function(player)
{
	player = player ? player : game.players[1];
	
	var img = (player && player.skins && player.skins[this.id_string]) ? player.skins[this.id_string] : this.img;
	
	return {file: img.file[player ? player.number : 1], x: img.idle.x, y: img.idle.y, w: img.idle.frameWidth, h: img.idle.h / img._angles};
};

// checks if the unit could stand at a position (without beeing blocked, only checks for buildings and tiles, not units)
UnitType.prototype.couldStandAt = function(pos)
{
	if(this.flying)
	{
		for(i = 0; i < this.circleOffsets.length; i++)
			if(game.fieldIsBlockedFlying(Math.ceil(pos.px + this.circleOffsets[i][0]), Math.ceil(pos.py + this.circleOffsets[i][1])))
				return false;
	}
	
	else
	{
		for(i = 0; i < this.circleOffsets.length; i++)
			if(game.fieldIsBlocked(Math.ceil(pos.px + this.circleOffsets[i][0]), Math.ceil(pos.py + this.circleOffsets[i][1])))
				return false;
	}
	
	return true;
};

// find the next free position where a unit of this type could stand (is pos is valid itself, return pos; only check for buildings and tiles, no units)
UnitType.prototype.getNextFreePositionFrom = function(pos)
{
	var testPos = pos;
	var len = 0.02;
	var i = 0;
	
	while(!this.couldStandAt(testPos))
	{
		testPos = pos.add(new Field(angleOffsets[i][0], angleOffsets[i][1], true).normalize(len));
		len += 0.02;
		i = (i + 1) % 12;
	}
	
	return testPos;
};

UnitType.prototype.getBasicType = function()
{
	for(var i = 0; i < basicUnitTypes.length; i++)
		if(basicUnitTypes[i].id_string == this.id_string)
			return basicUnitTypes[i];
	
	return false;
};

// not sure if this gets ever called (it does when placing in editor)
UnitType.prototype.draw = function(px, py)
{
	var img = this.getTitleImage();
	var scale = this.getValue("imageScale", PLAYING_PLAYER) * SCALE_FACTOR;
	c.drawImage(img.file, img.x, img.y, img.w, img.h, px - img.w / 2 * scale - game.cameraX, py - img.h / 2 * scale - game.cameraY, img.w * scale, img.h * scale);
};
BuildingType.prototype = new MapObjectType();
function BuildingType(data)
{
	this.preventsReveal = true;
	this.preventsLoss = true;
	
	this.deathSound = SOUND.BUILDING_DEATH;
	
	_.extend(this, data);
	
	// copy arrays (so they dont get only referenced)
	var thisRef = this;
	_.each(data, function(val, key){
		thisRef[key] = Object.prototype.toString.call(thisRef[key]) === "[object Array]" ? thisRef[key].slice() : thisRef[key];
	});
	
	// copy command object
	this.commands = copyObject(this.commands);
	
	this.minRange = this.minRange ? this.minRange : -999; // if no min range is set, set it to -999 (otherwise some calculations would fail)
	
	this.isBuilding = true;
	
	this.minimapColor = "white";
	
	this.id = game.buildingTypeIdCounter++;
	
	this.height = this.height ? this.height : 1;
	
	this.selectionOffsetY = this.selectionOffsetY ? this.selectionOffsetY : 0;
};

BuildingType.prototype.addToLists = function()
{
	lists.types[this.id_string] = this;
	// lists.imgs[this.id_string] = this.img;
	lists.unitTypes[this.id_string] = this;
	lists.buildingTypes[this.id_string] = this;
	lists.buildingsUpgrades[this.id_string] = this;
};

BuildingType.prototype.getValue = function(value, owner)
{
	if(value == "cost")
		return owner.getCostOfNextInstanceForBuilding(this);
	
	return this[value] + owner.getValueModifier(value, this);
};

BuildingType.prototype.getBasicType = function()
{
	for(var i = 0; i < basicBuildingTypes.length; i++)
		if(basicBuildingTypes[i].id_string == this.id_string)
			return basicBuildingTypes[i];
	
	return false;
};

BuildingType.prototype.getTitleImage = function(player)
{
	player = player ? player : game.players[1];
	
	var img = (player && player.skins && player.skins[this.id_string]) ? player.skins[this.id_string] : this.img;
	
	return {file: img.file[player ? player.number : 1], x: img.img.x, y: img.img.y, w: img.img.frameWidth, h: img.img.h};
};
TileType.prototype = new MapObjectType();
function TileType(data)
{
	_.extend(this, data);
	
	/*
	// if img is an array (= animated tile), load all the images, else only load one img
	if(Object.prototype.toString.call(data.img) === '[object Array]')
	{
		for(var i = 0; i < data.img.length; i++)
			this.img[i] = loadImage(data.img[i]);
	}
	else
		this.img = loadImage(data.img);
	*/
	
	this.minimapColor = "#ffffff"; // will be calculated correctly, when img is loaded
	this.isTile = true;
	
	this.circleOffset = 0.16;
	this.circleSize = this.sizeX * 0.75;
};

TileType.prototype.replaceReferences = function()
{
	if(this.img && lists.imgs[this.name])
		this.img = lists.imgs[this.name];
};
function Upgrade(data)
{
	_.extend(this, data);
		
	// copy arrays (so they dont get only referenced)
	var thisRef = this;
	_.each(data, function(val, key){
		thisRef[key] = Object.prototype.toString.call(thisRef[key]) === "[object Array]" ? thisRef[key].slice() : thisRef[key];
	});
	
	this.isUpgrade = true;
};

Upgrade.prototype.getValue = function(value, owner, alsoUnderConstruction)
{
	return (typeof this[value] === "number") ? (this[value] + owner.getValueModifier(value, this, alsoUnderConstruction)) : this[value];
};

Upgrade.prototype.replaceReferences = function()
{
	if(this.effectsTypes)
		for(var k = 0; k < this.effectsTypes.length; k++)
			if(typeof this.effectsTypes[k] == "string")
				this.effectsTypes[k] = lists.types[this.effectsTypes[k]];
	
	if(typeof this.image == "string")
		this.image = lists.imgs[this.image] ? lists.imgs[this.image] : lists.imgs.attentionmarkYellow;
};

Upgrade.prototype.getDataFields = function()
{
	return list_upgrade_fields;
};

Upgrade.prototype.getTitleImage = function(nr)
{
	return this.image.getTitleImage(nr);
};

Upgrade.prototype.addToLists = function()
{
	lists.types[this.id_string] = this;
	lists.upgrades[this.id_string] = this;
	lists.buildingsUpgrades[this.id_string] = this;
};

Upgrade.prototype.getBasicType = function()
{
	for(var i = 0; i < basicUpgrades.length; i++)
		if(basicUpgrades[i].id_string == this.id_string)
			return basicUpgrades[i];
	
	return false;
};

function Compiler(compilerType)
{
	switch(compilerType) {
		case "Command": this.processIdentifier = Command.prototype.compilerProcessIdentifier; break;
		case "Modifier": this.processIdentifier = Modifier.prototype.compilerProcessIdentifier; break;
	}
}

// Returns an array of 2 elements, where the 1st item is false on error and true on no error,
// and the 2nd element is an error message if applicable
Compiler.prototype.parse = function(str)
{
	if(!str || str.length == 0)
		return [0, "no content"];

	this.tokens = [];

	// First, convert the input string into a stream of tokens
	
	// The following function checks for a match of the regex in the string starting at index i
	// Returns null for no match, or an int indicating the length of the match if there is one
	var match = (str, i, regex) =>
	{
		var match = str.substr(i, str.length).match(regex);
		return (match && match.index == 0) ? match[0].length : null;
	}

	var len;
	for(var i = 0; i < str.length;)
	{
		if(len = match(str, i, /\s+/)) {} // Consume any whitespace

		else if(len = match(str, i, /[a-zA-Z_]+(\.[a-zA-Z_]+)*/))
		{
			var identifier = str.substr(i, len);
			var processed = this.processIdentifier(identifier);
			if (!processed)
			{
				delete this.tokens;
				return [false, "Invalid identifier: " + identifier];
			}
			this.tokens.push({type: "identifier", raw: identifier, output: processed});
		}

		// Sparate token due to ambiguity between subtraction and negative sign
		else if(len = match(str, i, /\-/))
			this.tokens.push({type: "minus", raw: "-", output: "-"});

		else if(len = match(str, i, /[0-9]+(\.[0-9]+|)/))
		{
			var number = str.substr(i, len);
			this.tokens.push({type: "number", raw: number, output: number});
		}

		else if(len = match(str, i, /(\+|\*|\/|\%|\^)/))
		{
			var operator = str.substr(i, len);
			this.tokens.push({type: "arithmetic", raw: operator, output: (operator = "^") ? "**" : operator});
		}

		else if(len = match(str, i, /(>=|<=|>|<|==|=|!=)/))
		{
			var operator = str.substr(i, len);
			this.tokens.push({type: "comparison", raw: operator, output: (operator == "=") ? "==" : operator});
		}

		else if(len = match(str, i, /(&&|\|\|)/))
		{
			var operator = str.substr(i, len);
			this.tokens.push({type: "logical", raw: operator, output: operator});
		}

		else if(len = match(str, i, /\(/))
			this.tokens.push({type: "open_paren", raw: "(", output: "("});

		else if(len = match(str, i, /\)/))
			this.tokens.push({type: "close_paren", raw: ")", output: ")"});

		else {
			delete this.tokens;
			return [false, "Invalid character: " + str[i]];
		}

		i += len;
	}

	if(this.tokens.length == 0)
	{
		delete this.tokens;
		return [false, "Empty expression provided"];
	}

	// Verify that the provided expression is valid using a non-deterministic pushdown automaton
	//  with terminals v, c, a, l, (, ), with mappings to tokens as in the following maps
	var token_map = {
		"identifier": "v", "minus": "-", "number": "v", "comparison": "c", "arithmetic": "a",
		"logical": "l", "open_paren": "(", "close_paren": ")", "": ""
	};

	var reverse_token_map_readable = {
		"v": "identifier or number", "-": "minus sign", "c": "comparison operator", "a": "arithmetic operator",
		"l": "logical operator", "(": "(", ")": ")", "": ""
	};

	// The pushdown automaton is generated from the following grammar:
	//  E -> vTCAM | -VTCAM | vUCAM | -VUCAM | (APTCAM | (APUCAM | (EPM
	//  M -> lEM | epsilon
	//  A -> vT | -VT | vU | -VU | (APT | (APU
	//  T -> aAT | epsilon
	//  U -> -AU | epsilon
	//  C -> c
	//  P -> )
	//  V -> v
	// which is the (decidedly not pretty) Greibach normal form of the much more straightforward (and equivalent) grammar:
	//  E -> A E A | (E) | E l E
	//  A -> A a A | A - A | (A) | v | -v
	// where E represents a valid logical expression for checking conditions, and A represents any arithmetic expression

	// Transition function, where the first character of the key is the token, and the second is the symbol on the top of the stack
	// The corresponding array is the set of possible transitions,
	//  where each string represents what the current top of the stack can be replaced with
	// There is an exact correspondence between the Greibach normal form of the grammar and the transition function
	var transition_fn = {
		"vE": ["MACT", "MACU"],
		"-E": ["MACTV", "MACUV"],
		"(E": ["MACTPA", "MACUPA", "MPE"],
		"lM": ["ME"],
		"M": [""],
		"vA": ["T", "U"],
		"-A": ["TV", "UV"],
		"(A": ["TPA", "UPA"],
		"aT": ["TA"],
		"T": [""],
		"-U": ["UA"],
		"U": [""],
		"cC": [""],
		")P": [""],
		"vV": [""]
	};

	// Set of stacks, where each stack in the set represents a possible parse of the remaining part of the input string
	// Starts as E, because any string must necessarily be parsed as an expression (E)
	var stacks = new Set(["E"]);

	// Takes a stack and a token as input, and appends the set of reachable stack states from that stack to newStacks
	var transition = (stack, token, newStacks) => {
		var top = stack[stack.length - 1];
		var pair = token_map[token] + top;
		if(pair in transition_fn)
		{
			transition_fn[pair].forEach((substitution) => {
				newStacks.add(stack.substr(0, stack.length - 1) + substitution);
			});
		}
	};

	// Performs as many epsilon transitions as possible,
	// adding new stacks until no more epsilon transitions are available
	var performEpsilonTransitions = () => {
		while(true)
		{
			var newStacks = new Set(stacks);

			stacks.forEach((stack) => {
				transition(stack, "", newStacks);
			});

			if(newStacks.size == stacks.size)
				break;

			stacks = newStacks;
		}
	};

	// Consumes a token, advancing the PDA by one step
	var consumeToken = (token) => {
		var newStacks = new Set();

		stacks.forEach((stack) => {
			transition(stack, token, newStacks);
		});
		stacks = newStacks;

		performEpsilonTransitions();
	};

	// Iterate through all the tokens to parse the entire expression
	for(var i = 0; i < this.tokens.length; i++)
	{
		consumeToken(this.tokens[i].type);

		// If there are no more stacks left, there was a syntax error
		// No stacks left means there is no remaining viable way to parse the expression
		if(stacks.size == 0)
		{
			var humanName;
			var printRaw = false;
			// Return a readable error message
			switch(this.tokens[i].type)
			{
				case "identifier":
				case "number":
				case "logical":
					humanName = this.tokens[i].type;
					printRaw = true;
					break;
				case "comparison":
				case "arithmetic":
					humanName = this.tokens[i].type + " operator";
					printRaw = true;
					break;
				case "open_paren":
					humanName = "opening parenthesis";
					break;
				case "close_paren":
					humanName = "closing parenthesis";
					break;
				case "minus":
					humanName = "minus sign";
					break;
			}
			var errMsg = "Unexpected " + humanName + " " + (printRaw ? this.tokens[i].raw : "");
			delete this.tokens;
			return [false, errMsg];
		}
	}

	if(!stacks.has(""))
	{
		// Produce an error message indicating what characters we expected at the end of the string

		// Create a map from symbol at the top of the stack to tokens that it could start with
		var expectedTokens = {};
		Object.keys(transition_fn).filter((key) => key.length == 2).forEach((key) => {
			if (!expectedTokens[key[1]])
				expectedTokens[key[1]] = [];
			expectedTokens[key[1]].push(key[0]);
		})

		// Filter the previous map by the stack symbols that were at the top of the remaining stacks
		var options = new Set();
		stacks.forEach((stack) => {
			var top = stack[stack.length - 1];
			expectedTokens[top].forEach((token) => options.add(reverse_token_map_readable[token]));
		});
		delete this.tokens;
		return [false, "Incomplete expression, expected one of: " + Array.from(options).join(", ")]
	} 
	else
		return [true, ""];
}

// Takes the list of parameters of the function to be generated and returns the compiled function
Compiler.prototype.compile = function(signature)
{
	var fn;
	eval("fn = function(" + signature.join(",") + "){return " + this.tokens.map((token) => token.output).join("") + ";};");
	return fn;
};

function Command(data)
{
	this.manaCost = [0];
	this.goldCost = 0;
	this.range = [0];
	this.minRange = [-999];
	this.aoeRadius = [0];
	this.damage = [0];
	this.projectileSpeed = [8];
	this.hitsFriendly = true;
	this.hitsEnemy = true;
	this.hitsSelf = true;
	this.effectScale = 1;
	this.projectileAoeRadius = [0];
	this.projectileDamage = [0];
	this.modifiers = [];
	this.summonedUnits = [];
	this.autocastConditions = "";
	this.cooldown = 0;
	this.cooldown2 = 0;
	this.attackEffectInit = "spell";
	this.bounceDistMax = 0;
	this.bounceDistMin = 0;
	
	_.extend(this, data);
	
	// copy arrays (so they dont get only referenced)
	var thisRef = this;
	_.each(data, function(val, key){
		thisRef[key] = Object.prototype.toString.call(thisRef[key]) === "[object Array]" ? thisRef[key].slice() : thisRef[key];
	});
	
	this.isCommand = true;
	
	this.id = game.global_command_id++;
	
	if(!IS_LOGIC && this.image)
	{
		interface_.buttons.push(new Button(this));
		
		if(this.requiredLevels && this.requiredLevels.length > 0)
			interface_.buttons.push(new Button(this, true));
	}
};

Command.prototype.compilerProcessIdentifier = function(id)
{
	var pieces = id.split(".");

	if(pieces.length > 1)
		if(pieces[0] != "type" && pieces[0] != "this" && pieces[0] != "owner")
			return false;

	if(id != "true" && id != "false")
		id = id.substr(0, 5) != "this." ? ("u." + id) : ("u" + id);

	return id;
};

Command.prototype.getTitleImage = function(nr)
{
	return this.image.getTitleImage(nr);
};

Command.prototype.canTargetUnit = function(u)
{
	for(var k = 0; k < this.targetRequiremementsArray.length; k++)
	{
		var met = false;
		
		for(var i = 0; i < this.targetRequiremementsArray[k].length; i++)
			if(this.targetRequiremementsArray[k][i].func(u))
				met = true;
		
		if(!met)
			return false;
	}
	
	return true;
}

Command.prototype.replaceReferences = function()
{
	if(typeof this.unitType == "string")
		this.unitType = lists.types[this.unitType];
	
	if(typeof this.improvedBuilding == "string")
		this.improvedBuilding = lists.types[this.improvedBuilding];
	
	if(typeof this.upgrade == "string")
		this.upgrade = lists.types[this.upgrade];
	
	if(typeof this.image == "string")
		this.image = lists.imgs[this.image] ? lists.imgs[this.image] : lists.imgs.attentionmarkYellow;
	
	if(this.modifiers)
		for(var k = 0; k < this.modifiers.length; k++)
			if(typeof this.modifiers[k] == "string")
				this.modifiers[k] = lists.types[this.modifiers[k]];
	
	if(this.modifiersSelf)
		for(var k = 0; k < this.modifiersSelf.length; k++)
			if(typeof this.modifiersSelf[k] == "string")
				this.modifiersSelf[k] = lists.types[this.modifiersSelf[k]];
	
	if(this.summonedUnits)
		for(var k = 0; k < this.summonedUnits.length; k++)
			if(typeof this.summonedUnits[k] == "string")
				this.summonedUnits[k] = lists.types[this.summonedUnits[k]];
	
	if(this.requirementType)
		for(var k = 0; k < this.requirementType.length; k++)
			if(typeof this.requirementType[k] == "string")
				this.requirementType[k] = lists.types[this.requirementType[k]];
	
	this.targetRequiremementsArray = [];
	
	if(this.targetRequirements1 && this.targetRequirements1.length > 0)
		this.targetRequiremementsArray.push(this.targetRequirements1);
	
	if(this.targetRequirements2 && this.targetRequirements2.length > 0)
		this.targetRequiremementsArray.push(this.targetRequirements2);
	
	if(this.targetRequirements3 && this.targetRequirements3.length > 0)
		this.targetRequiremementsArray.push(this.targetRequirements3);
	
	for(var i = 0; i < this.targetRequiremementsArray.length; i++)
		for(var k = 0; k < this.targetRequiremementsArray[i].length; k++)
			if(typeof this.targetRequiremementsArray[i][k] == "string")
				this.targetRequiremementsArray[i][k] = targetRequirements[this.targetRequiremementsArray[i][k]];
};

Command.prototype.getValue = function(field, unit)
{
	if(field == "summonedUnits" || field == "modifiers" || field == "modifiersSelf")
		return this[field][Math.min(this[field].length - 1, unit.abilityLevels[this.id] - 1)];
	
	return ((unit.abilityLevels && (field == "manaCost" || field == "range" || field == "minRange" || field == "damage" || field == "aoeRadius" || field == "projectileSpeed" || field == "projectileDamage" || field == "projectileAoeRadius"))
		? this[field][Math.min(this[field].length - 1, unit.abilityLevels[this.id] - 1)] : this[field]) + (unit.owner ? unit.owner.getValueModifier(field, this) : unit.getValueModifier(field, this));
};

Command.prototype.getDataFields = function()
{
	return list_ability_fields;
};

Command.prototype.addToLists = function()
{
	lists.types[this.id_string] = this;
	lists.commands[this.id_string] = this;
};

Command.prototype.getBasicType = function()
{
	for(var i = 0; i < basicCommands.length; i++)
		if(basicCommands[i].id_string == this.id_string)
			return basicCommands[i];
	
	return false;
};

Command.prototype.aoeHitsUnit = function(caster, target)
{
	if(caster == target)
		return this.hitsSelf;
	
	var isEnemy = caster.owner.isEnemyOfPlayer(target.owner);
	
	if((isEnemy && !this.hitsEnemy) || (!isEnemy && !this.hitsFriendly))
		return false;
	
	if(this.targetFilters)
		for(var i = 0; i < this.targetFilters.length; i++)
			if(!target.type[this.targetFilters[i]])
				return false;
	
	if(this.targetFiltersExclude)
		for(var i = 0; i < this.targetFiltersExclude.length; i++)
			if(target.type[this.targetFiltersExclude[i]])
				return false;
	
	return true;
};






function Modifier(data)
{
	this.isModifier = true;
	
	this.maxStack = 1;
	this.auraHitsFriendly = true;
	this.auraHitsAllied = true;
	this.auraHitsEnemy = true;
	this.auraHitsSelf = true;
	
	_.extend(this, data);
	
	// copy arrays (so they dont get only referenced)
	var thisRef = this;
	_.each(data, function(val, key){
		thisRef[key] = Object.prototype.toString.call(thisRef[key]) === "[object Array]" ? thisRef[key].slice() : thisRef[key];
	});
};

Modifier.prototype.compilerProcessIdentifier = function(id)
{
	var pieces = id.split(".");

	if(pieces.length <= 1)
		return false;

	if(pieces[0] != "type" && pieces[0] != "this")
		return false;

	return "u" + id;
};

Modifier.prototype.getDataFields = function()
{
	return list_modifiers_fields;
};

Modifier.prototype.replaceReferences = function()
{
	if(typeof this.image == "string")
		this.image = lists.imgs[this.image] ? lists.imgs[this.image] : lists.imgs.attentionmarkYellow;
	
	if(this.unitImg && (typeof this.unitImg == "string"))
		this.unitImg = lists.imgs[this.unitImg] ? lists.imgs[this.unitImg] : lists.imgs.attentionmarkYellow;
	
	if(this.auraModifiers)
		for(var k = 0; k < this.auraModifiers.length; k++)
			if(typeof this.auraModifiers[k] == "string")
				this.auraModifiers[k] = lists.types[this.auraModifiers[k]];
	
	if(this.killModifiers)
		for(var k = 0; k < this.killModifiers.length; k++)
			if(typeof this.killModifiers[k] == "string")
				this.killModifiers[k] = lists.types[this.killModifiers[k]];
	
	if(this.addCommands)
		for(var k = 0; k < this.addCommands.length; k++)
			if(typeof this.addCommands[k] == "string")
				this.addCommands[k] = lists.types[this.addCommands[k]];
	
	if(this.disabledCommands)
		for(var k = 0; k < this.disabledCommands.length; k++)
			if(typeof this.disabledCommands[k] == "string")
				this.disabledCommands[k] = lists.types[this.disabledCommands[k]];
};

Modifier.prototype.addToLists = function()
{
	lists.types[this.id_string] = this;
	lists.modifiers[this.id_string] = this;
};

Modifier.prototype.getBasicType = function()
{
	for(var i = 0; i < basicModifiers.length; i++)
		if(basicModifiers[i].id_string == this.id_string)
			return basicModifiers[i];
	
	return false;
};

Modifier.prototype.getValue = function(field, owner)
{
	return this[field] + owner.getValueModifier(field, this);
};

Modifier.prototype.getTitleImage = function(nr)
{
	return this.image.getTitleImage(nr);
};

Modifier.prototype.aoeHitsUnit = function(caster, target)
{
	if(!this.auraHitsSelf && caster == target)
		return false;
	
	var isEnemy = caster.owner.isEnemyOfPlayer(target.owner);
	var sameTeam = caster.owner.team == target.owner.team;
	
	if((isEnemy && !this.auraHitsEnemy) || (!isEnemy && sameTeam && !this.auraHitsFriendly) || (!isEnemy && !sameTeam && !this.auraHitsAllied))
		return false;
	
	if(this.auraTargetFilters)
		for(var i = 0; i < this.auraTargetFilters.length; i++)
			if(!target.type[this.auraTargetFilters[i]])
				return false;
	
	if(this.auraTargetFiltersExclude)
		for(var i = 0; i < this.auraTargetFiltersExclude.length; i++)
			if(target.type[this.auraTargetFiltersExclude[i]])
				return false;
	
	return true;
};
function Graphic(data)
{
	this.isGraphic = true;
	this.noLogic = true;
	
	_.extend(this, data);
	
	this.dataFiles = [];
	
	if(!this.id_string)
		this.id_string = this.name;
	
	if(!this.name)
		this.name = this.id_string;
	
	if(!this.img)
		this.img = {x: 0, y: 0, w: 0, h: 0, frameWidth: 0, frames: []};
	
	if(!this.idle)
		this.idle = {x: 0, y: 0, w: 0, h: 0, frameWidth: 0, frames: []};
	
	if(!this.file)
		this.file = "buildingSheet";
};

Graphic.prototype.getDataURLFile = function(index)
{
	if(this.dataFiles[index])
		return this.dataFiles[index];
	
	if(!this.file[index])
		return null;
	
	var img = this.getTitleImage(index);
	
	var canv_ = document.createElement("canvas");
	canv_.width = img.w;
	canv_.height = img.h;
	canv_.getContext("2d").drawImage(img.file, img.x, img.y, img.w, img.h, 0, 0, img.w, img.h);
	
	var w = img.w;
	var h = img.h;
	
	if(w > h)
	{
		h = 54 * (h / w);
		w = 54;
	}
	else
	{
		w = 54 * (w / h);
		h = 54;
	}
	
	var el = document.createElement("img");
	el.src = canv_.toDataURL();
	el.width = w;
	el.height = h;
	
	this.dataFiles[index] = el;
	
	return this.dataFiles[index];
};

Graphic.prototype.getDataFields = function()
{
	return list_graphic_fields;
};

Graphic.prototype.replaceReferences = function()
{
	if(this.file && (typeof this.file == "string"))
		this.file = customImgs[this.file] ? customImgs[this.file] : miscSheet;
};

Graphic.prototype.addToLists = function()
{
	lists.imgs[this.id_string] = this;
};

Graphic.prototype.getBasicType = function()
{
	if(unit_imgs[this.id_string])
		return unit_imgs[this.id_string];
	
	if(building_imgs[this.id_string])
		return building_imgs[this.id_string];
	
	if(imgs[this.id_string])
		return imgs[this.id_string];
	
	return false;
};

Graphic.prototype.getTitleImage = function(nr)
{
	if(this._angles)
		return {file: this.file[this.file[nr] ? nr : 0], x: this.idle.x, y: this.idle.y, w: this.idle.frameWidth, h: this.idle.h / this._angles};
	
	return {file: this.file[this.file[nr] ? nr : 0], x: this.img.x, y: this.img.y, w: this.img.frameWidth ? this.img.frameWidth : this.img.w, h: this.img.h};
};
Tile.prototype = new MapObject();
function Tile(data)
{
	_.extend(this, data);

	// random offset for drawing (only on not ground not decoration tiles, do the tiles do appear not so much "in line")
	this.randomOffsetX = 0;
	this.randomOffsetY = 0;

	if(this.type.ignoreGrid)
		this.pos = new Field(this.x, this.y, true);
	
	else
	{
		this.pos = new Field(this.x - 1 + this.type.sizeX / 2, this.y - 1 + this.type.sizeY / 2, true);
		
		// if not ground, add a random offset for drawing, to make it look more naturally
		if(this.type.blocking && !this.type.isCliff && !this.type.noRandomOffset)
		{
			this.randomOffsetX = Math.random() * 0.2 - 0.1;
			this.randomOffsetY = Math.random() * 0.2 - 0.1;
		}
	}
	
	this.drawPos = this.type.isGround ? this.pos : this.pos.add3(0, -game.getHMValue2(Math.floor(this.x), Math.floor(this.y)) * CLIFF_HEIGHT);
	this.owner = game.players[0]; // tiles always belong to the neutral player
	this.yDrawingOffset = this.type.blocking ? this.drawPos.py + this.randomOffsetY + this.type.sizeY / 2 : this.drawPos.py;
	
	if(this.type.blocking)
	{
		game.blockingTiles.push(this);

		if(game_state == GAME.EDITOR && this.type.isCliff!=true && data.noHistory != true)
			editor.clipboard.history.addObject(this);

		this.switchBlocking(true, data.dontRefreshNBs);
		
		// switch on for all the teams
		for(var i = 0; i < game.teams.length; i++)
			this.switchBlockingForTeam(true, game.teams[i]);
	}
	
	else if(!this.type.isDefault) {
		// adding the tile to the history
		game.groundTiles2.push(this);
		if(game_state == GAME.EDITOR && (this.type.isCliff!=true && data.noHistory != true)) {
			editor.clipboard.history.addObject(this);
		}

	}
	// define random offset, if this is an animated tile (img = array), define a random time offset for animation
	if(Object.prototype.toString.call(this.type.img) === '[object Array]')
		this.randomOffsetFrame = Math.floor(Math.random() * 1000) % this.type.img.length;
	
	this.modifierMods = {};
};

Tile.prototype.getYDrawingOffset = function()
{
	return this.yDrawingOffset;
};

// draw; expects screen bounds (ingame coords)
/*
Tile.prototype.draw = function(x1, x2, y1, y2)
{
	// if not in screen, return
	if(!(this.pos.px + 1 >= x1 && this.pos.py + 1 >= y1 && this.pos.px - 1 <= x2 && this.pos.py <= y2))
		return;
	
	// check if this.type.img is an array, if yes, its animated and we have to look for the current frame
	var img = this.type.img;
	if(Object.prototype.toString.call(img) === '[object Array]')
		img = this.type.img[(Math.floor(ticksCounter / 6) + this.randomOffsetFrame) % this.type.img.length];
	
	var x = (this.pos.px + this.randomOffsetX) * FIELD_SIZE - img.width * SCALE_FACTOR / 2 - game.cameraX;
	var y = (this.pos.py + this.randomOffsetY + this.type.sizeY / 2) * FIELD_SIZE - img.height * SCALE_FACTOR - game.cameraY;
	
	c.drawImage(img, x, y, img.width * SCALE_FACTOR, img.height * SCALE_FACTOR);
};
*/
// represents a field in the grid or an exact position; p_mode = true => exact position, else Field
function Field(x, y, p_mode)
{
	if(p_mode)
	{
		this.px = x;
		this.py = y;
		this.x = Math.ceil(x);
		this.y = Math.ceil(y);
	}
	else
	{
		this.x = x;
		this.y = y;
		this.px = x - 0.5;
		this.py = y - 0.5;
	}
	
	this.isField = true;
};

// get distance to other field, using field values
Field.prototype.distanceTo = function(otherField)
{
	return otherField ? Math.sqrt(Math.pow(this.x - otherField.x, 2) + Math.pow(this.y - otherField.y, 2)) : 999999;
};

// get distance to other field, using exact positions
Field.prototype.distanceTo2 = function(otherField)
{
	return otherField ? Math.sqrt(Math.pow(this.px - otherField.px, 2) + Math.pow(this.py - otherField.py, 2)) : 999999;
};

Field.prototype.isSameGrid = function(otherField)
{
	return this.x == otherField.x && this.y == otherField.y;
};

// get vector from here to other Field
Field.prototype.vectorTo = function(otherField)
{
	return new Field(otherField.px - this.px, otherField.py - this.py, true);
};

// normalize the vector to a set length
Field.prototype.normalize = function(factor)
{
	var len = Math.sqrt(this.px * this.px + this.py * this.py);
	if(len == 0)
		len = 0.001;
	
	this.px *= factor / len;
	this.py *= factor / len;
	return this;
};

Field.prototype.getLen = function()
{
	return Math.sqrt(this.px * this.px + this.py * this.py);
}

// adds a vector to this one from x and y values
Field.prototype.add = function(otherField)
{
	return new Field(this.px + otherField.px, this.py + otherField.py, true);
};

Field.prototype.add3 = function(x, y)
{
	return new Field(this.px + x, this.py + y, true);
};

Field.prototype.mul = function(x, y)
{
	return new Field(this.px * x, this.py * y, true);
};

// returns a new field, created from adding a vector from this to otherfield with a fixed length
Field.prototype.addNormalizedVector = function(otherField, len)
{
	var x = otherField.px - this.px;
	var y = otherField.py - this.py;
	
	var len2 = Math.sqrt(x * x + y * y);
	if(len2 == 0)
		len2 = 0.001;
	
	x *= len / len2;
	y *= len / len2;
	
	return new Field(this.px + x, this.py + y, true);
};

// adds a vector to this field with a given angle and length and returns the resulting field; a different name might be cool
Field.prototype.add2 = function(angle, len)
{
	return this.add(new Field(Math.cos(angle), Math.sin(angle), true).normalize(len));
};

// get angle from this point to another point
Field.prototype.getAngleTo = function(otherField)
{
	var returnValue = Math.atan((otherField.py - this.py) / (otherField.px - this.px));
	returnValue -= otherField.px - this.px < 0 ? Math.PI : 0;
	return returnValue;
};

Field.prototype.getCopy = function()
{
	return new Field(this.px, this.py, true);
};

Field.prototype.equals = function(otherField)
{
	return this.px == otherField.px && this.py == otherField.py;
};

Field.prototype.toString = function()
{
	return this.px + ":" + this.py;
};
var CLIFF_HEIGHT = 1.5;
var MAX_MAP_SIZE = 172;
var MAX_CLIFF_LEVEL = 2;
var MAX_PLAYERS = 6;
var BUILDING_QUEUE_LEN = 5;
var BUILDING_START_HP_PERCENTAGE = 0.2;
var MAX_SUPPLY = 100;
var MINE_DIST = 7;
var START_GOLD = 300;
var TICK_TIME = 50;

var customImgs = {};
var possibleAngleCounts = {"1": 1, "4": 4, "8": 8};

function toInt(i)
{
	var i2 = parseInt(i);
	return isNaN(i2) ? 0 : i2;
}

function checkField(field, val, unscaled)
{
	if(field.type == "selection")
		return val;
	
	if(field.type == "bool")
	{
		if(val)
			return true;
		return false;
	}
	
	if(field.type == "integer")
	{
		val = parseInt(val);
		
		if(isNaN(val))
			val = 0;
		
		if(val > field.max_val)
			val = field.max_val;
		
		else if(val < field.min_val)
			val = field.min_val;
		
		return val;
	}
	
	if(field.type == "float")
	{
		val = parseFloat(val);
		
		if(isNaN(val))
			val = 0;
		
		var max_val = field.max_val;
		var min_val = field.min_val;
		
		if(unscaled && field.displayScale)
		{
			max_val /= field.displayScale;
			min_val /= field.displayScale;
		}
		
		if(val > max_val)
			val = max_val;
		
		else if(val < min_val)
			val = min_val;
		
		return val;
	}
	
	if(field.type == "string")
	{
		if(!val)
			val = "";
		
		if(val.length > field.max_len)
			val = val.slice(0, field.max_len);
		
		else if(val.length < field.min_len)
			for(var i = 0; i < field.min_len - val.length; i++)
				val += "_";
		
		return val;
	}
}

function getRampTypeFromCode(code)
{
	var ramps = (game.theme && game.theme.ramps) ? game.theme.ramps : ramps;
	
	for(var i = 0; i < ramps.length; i++)
		if(ramps[i].code == code)
			return ramps[i];
	
	return ramps[0];
}

function getThemeByName(name)
{
	for(var i = 0; i < mapThemes.length; i++)
		if(mapThemes[i].name == name)
			return mapThemes[i];
}

Array.prototype.contains = function(value)
{
	for(var i = 0; i < this.length; i++)
		if(this[i] == value)
			return true;
	return false;
}

Array.prototype.erease = function(element)
{
	for(var i = 0; i < this.length; i++)
		if(this[i] == element)
			{
				this.splice(i, 1);
				return true;
			}
	return false;
}

String.prototype.toUnitType = function()
{
	var types_ = game ? game.unitTypes.concat(game.buildingTypes, tileTypes, cliffs, cliffs_winter, egypt_cliffs, grave_cliffs, ramp_tiles, ramp_tiles_egypt, ramp_tiles_grave, game.upgrades) : basicUnitTypes.concat(basicBuildingTypes, tileTypes, cliffs, cliffs_winter, ramp_tiles, basicUpgrades);
	
	for(var i = 0; i < types_.length; i++)
		if(this == types_[i].name)
			return types_[i];
	
	return null;
}




var COMMAND = Object.freeze({
	MAKEUNIT: 1,
	UNIVERSAL: 2,
	MAKEBUILDING: 3,
	IDLE: 7,
	HOLDPOSITION: 8,
	ATTACK: 9,
	CANCEL: 10,
	MOVE: 11,
	MOVETO: 12,
	MINE: 13,
	REPAIR: 14,
	AMOVE: 15,
	SWITCH_CC: 22,
	UPGRADE: 23,
	BUILDING_UPGRADE: 25,
	LOAD: 26,
	UNLOAD: 27,
	UNLOAD2: 28,
	ATTACK_GROUND: 29,
	TELEPORT: 30,
	DAMAGING_PROJECTILE: 31,
	DANCE: 32
});

var EDITOR_COMMANDS = Object.freeze({
	MAKEUNIT: 1,
	MAKEBUILDING: 3,
	IDLE: 7,
	HOLDPOSITION: 8,
	ATTACK: 9,
	CANCEL: 10,
	MOVE: 11,
	REPAIR: 14,
	UNIVERSAL: 2,
	SWITCH_CC: 22,
	UPGRADE: 23,
	BUILDING_UPGRADE: 25,
	ATTACK_GROUND: 29,
	TELEPORT: 30
});

var ability_type_fields = {};

ability_type_fields[COMMAND.MAKEUNIT] =
[
	"name",
	"type",
	"unitType",
	"hotkey",
	"commandCard",
	"interfacePosX",
	"interfacePosY",
	"image",
	"description",
	"requirementType",
	"requirementLevel",
	"requirementText",
	"manaCost",
	"hasAutocast",
	"autocastDefault",
	"requiredLevels",
	"learnCommandCard",
	"learnInterfacePosX",
	"learnInterfacePosY",
	"learnHotkey"
];

ability_type_fields[COMMAND.MAKEBUILDING] =
[
	"name",
	"type",
	"unitType",
	"hotkey",
	"commandCard",
	"interfacePosX",
	"interfacePosY",
	"image",
	"description",
	"requirementType",
	"requirementLevel",
	"requirementText",
	"manaCost",
	"range",
	"requiredLevels",
	"learnCommandCard",
	"learnInterfacePosX",
	"learnInterfacePosY",
	"learnHotkey"
];

ability_type_fields[COMMAND.IDLE] =
[
	"name",
	"type",
	"hotkey",
	"commandCard",
	"interfacePosX",
	"interfacePosY",
	"image",
	"description",
	"requirementType",
	"requirementLevel",
	"requirementText",
	"manaCost"
];

ability_type_fields[COMMAND.REPAIR] =
[
	"name",
	"type",
	"hotkey",
	"commandCard",
	"interfacePosX",
	"interfacePosY",
	"image",
	"description",
	"targetRequirements1",
	"targetRequirements2",
	"targetRequirements3",
	"requirementType",
	"requirementLevel",
	"requirementText",
	"manaCost",
	"range",
	"hasAutocast",
	"autocastConditions"
];

ability_type_fields[COMMAND.HOLDPOSITION] =
[
	"name",
	"type",
	"hotkey",
	"commandCard",
	"interfacePosX",
	"interfacePosY",
	"image",
	"description",
	"requirementType",
	"requirementLevel",
	"requirementText",
	"manaCost"
];

ability_type_fields[COMMAND.ATTACK] =
[
	"name",
	"type",
	"hotkey",
	"commandCard",
	"interfacePosX",
	"interfacePosY",
	"image",
	"description",
	"requirementType",
	"requirementLevel",
	"requirementText",
	"manaCost"
];

ability_type_fields[COMMAND.CANCEL] =
[
	"name",
	"type",
	"hotkey",
	"commandCard",
	"interfacePosX",
	"interfacePosY",
	"image",
	"description",
	"requirementType",
	"requirementLevel",
	"requirementText"
];

ability_type_fields[COMMAND.MOVE] =
[
	"name",
	"type",
	"hotkey",
	"commandCard",
	"interfacePosX",
	"interfacePosY",
	"image",
	"description",
	"requirementType",
	"requirementLevel",
	"requirementText"
];

ability_type_fields[COMMAND.TELEPORT] =
[
	"name",
	"type",
	"hotkey",
	"commandCard",
	"interfacePosX",
	"interfacePosY",
	"image",
	"attackEffect",
	"description",
	"requirementType",
	"requirementLevel",
	"requirementText",
	"launchSound",
	"manaCost",
	"goldCost",
	"effectScale",
	"castingDelay",
	"cooldown",
	"cooldown2",
	"range",
	"minRange",
	"animationName",
	"requiresVision",
	"requiredLevels",
	"modifiersSelf",
	"learnInterfacePosX",
	"learnInterfacePosY",
	"learnCommandCard",
	"learnHotkey",
	"attackEffectInit"
];

ability_type_fields[COMMAND.UNIVERSAL] =
[
	"name",
	"type",
	"hotkey",
	"targetIsPoint",
	"targetIsUnit",
	"isInstant",
	"isChanneled",
	"playLaunchSoundOnce",
	"useAoeCursor",
	"commandCard",
	"interfacePosX",
	"interfacePosY",
	"image",
	"attackEffect",
	"description",
	"requirementType",
	"requirementLevel",
	"requirementText",
	"targetRequirements1",
	"targetRequirements2",
	"targetRequirements3",
	"launchSound",
	"manaCost",
	"goldCost",
	"aoeRadius",
	"damage",
	"projectileDamage",
	"projectileAoeRadius",
	"maximizeRangeWhenCasting",
	"hitsFriendly",
	"hitsEnemy",
	"hitsSelf",
	"targetFilters",
	"targetFiltersExclude",
	"effectScale",
	"projectileSpeed",
	"duration",
	"castingDelay",
	"cooldown",
	"cooldown2",
	"range",
	"minRange",
	"bounceDistMin",
	"bounceDistMax",
	"bouncePower",
	"animationName",
	"causesFlameDeath",
	"modifiers",
	"summonedUnits",
	"summonsUseWaypoint",
	"summonsWaypointAMove",
	"ignoreSupplyCheck",
	"requiresVision",
	"requiredLevels",
	"modifiersSelf",
	"learnInterfacePosX",
	"learnInterfacePosY",
	"learnCommandCard",
	"learnHotkey",
	"hasAutocast",
	"autocastDefault",
	"autocastConditions",
	"attackEffectInit"
];

ability_type_fields[COMMAND.SWITCH_CC] =
[
	"name",
	"type",
	"hotkey",
	"commandCard",
	"interfacePosX",
	"interfacePosY",
	"image",
	"description",
	"requirementType",
	"requirementLevel",
	"requirementText",
	"targetCC"
];

ability_type_fields[COMMAND.UPGRADE] =
[
	"name",
	"type",
	"hotkey",
	"commandCard",
	"interfacePosX",
	"interfacePosY",
	"image",
	"description",
	"requirementType",
	"requirementLevel",
	"requirementText",
	"upgrade",
	"manaCost",
	"hasAutocast",
	"autocastDefault"
];

ability_type_fields[COMMAND.BUILDING_UPGRADE] =
[
	"name",
	"type",
	"hotkey",
	"commandCard",
	"interfacePosX",
	"interfacePosY",
	"image",
	"description",
	"requirementType",
	"requirementLevel",
	"requirementText",
	"improvedBuilding",
	"manaCost"
];

ability_type_fields[COMMAND.ATTACK_GROUND] =
[
	"name",
	"type",
	"hotkey",
	"useAoeCursor",
	"commandCard",
	"interfacePosX",
	"interfacePosY",
	"image",
	"description",
	"requirementType",
	"requirementLevel",
	"requirementText",
	"manaCost"
];

var commandTypeDescriptions = {
	MAKEUNIT: "This command will produce / train a unit. Set a unit type to determinate which unit will be produced.",
	MAKEBUILDING: "This command will construct a building. Set a unit type to determinate which building will be constructed",
	UNIVERSAL: "This is a universal type that you want to pick for most spells (damagespells, heal, ...). It uses most of the fields like dmg, aoeRadius, range, ...",
	SWITCH_CC: "This command will switch the command menu. This is used for example to go to the submenu for making buildings. Set the targetCC field to determinate which command menu to go.",
	UPGRADE: "This command will research an upgrade.",
	BUILDING_UPGRADE: "This command will upgrade this building / unit to another one set the improvedBuilding field to determinate which building / unit it will be morphed into.",
	ATTACK_GROUND: "This command will order the unit to attack the target position."
};



var graphic_type_fields = {};




var BUILDING_STATE = Object.freeze({
	NORMAL: 1,
	UNDER_CONSTRUCTION: 2,
	BUSY: 3,
	BUSY_DAMAGED: 4,
	DAMAGED: 5,
	UPGRADING: 6,
	UPGRADING_DAMAGED: 7,
	EMPTY: 8,
	DEAD: 0
});

var CONTROLLER = Object.freeze({
	HUMAN: 0,
	COMPUTER: 1,
	NONE: 2,
	REMOTE: 3,
	SPECTATOR: 4
});

var SOUND = Object.freeze({
	NONE: 0,
	PAIN: 1,
	DEATH: 2,
	SWING: 3,
	PLACE: 4,
	POSITIVE: 5,
	NEGATIVE: 6,
	CLICK: 7,
	CLICK2: 8,
	GUN: 9,
	SWORD: 10,
	BUILD: 11,
	BUILDING_DEATH: 12,
	READY: 13,
	YES: 14,
	INGAMECLICK: 15,
	BUILDING_FINISHED: 16,
	UNDER_ATTACK: 17,
	VICTORY: 18,
	DEFEAT: 19,
	FLAMESTRIKE_LAUNCH: 20,
	FLAMESTRIKE_IMPACT: 21,
	MAGE_ATTACK: 22,
	MAGE_IMPACT: 23,
	CATA_HIT: 24,
	CATA_LAUNCH: 25,
	CATA_IMPACT: 26,
	BUILDING_PAIN: 27,
	REPAIR: 28,
	CATA_DEATH: 29,
	GAME_START: 30,
	HEAL: 31,
	BING: 32,
	SWITCH: 33,
	ZIP: 34,
	ZIP3: 35,
	SPELL: 36,
	DRAGON_YES: 37,
	DRAGON_SPAWN: 38,
	DRAGON_DEATH: 39,
	FALL: 40,
	DRAGON_FIRE: 41,
	MINE: 42,
	WOLF_YES: 43,
	WOLF_READY: 44,
	WOLF_DEATH: 45,
	WOLF_HIT: 46,
	WOLF_PAIN: 47,
	LADDER_START: 48,
	ROUNDHOUSE: 49,
	BIGHIT: 50,
	STRONG_HIT: 51,
	BEAST_DIE: 52,
	BEAST_YES: 53,
	BEAST_READY: 54,
	FLESH: 55,
	FLAK: 56,
	SHOCKWAVE: 57,
	FIREBALL: 58,
	SKELETON_SPAWN: 59,
	SKELETON_YES: 60,
	SKELETON_PAIN: 61,
	BING2: 62,
	ARCHIVEMENT: 63,
	ARCHIVEMENT2: 64,
	ARCHIVEMENT3: 65,
	AURA_HEAL: 66,
	PLASMA_SHIELD: 67,
	WARP: 68,
	BIRD_SPAWN: 69,
	BIRD_YES: 70,
	BIRD_DEATH: 71,
	BIRD_SLAM: 72,
	BATTLE_FANFARE: 73,
	A_WS: 74,
	CC: 75,
	CHURCH: 76,
	DRAGONS_LAIR: 77,
	FORGE: 78,
	HOUSE: 79,
	LAB: 80,
	MAGES_GUILD: 81,
	RAX: 82,
	WW_DEN: 83,
	W_DEN: 84,
	WORKSHOP: 85
});





var checkAngles = [[1, 0], [3, 1], [1, 1], [1, 3], [0, 1], [-1, 3], [-1, 1], [-3, 1], [-1, 0], [-3, -1], [-1, -1], [-1, -3], [0, -1], [1, -3], [1, -1], [3, -1]];
var angleOffsets = [[0.5, 0.86], [0.86, 0.5], [1, 0], [0.86, -0.5], [0.5, -0.86], [0, -1], [-0.5, -0.86], [-0.86, -0.5], [-1, 0], [-0.86, 0.5], [-0.5, 0.86], [0, 1]];






var targetRequirements = {
	
	isBiological: {
		func: function(target){ return target.type.isBiological; },
		text: "Target needs to be a biological unit.",
		isTargetRequirement: true,
		funcName: "isBiological"
	},
	
	isMechanical: {
		func: function(target){ return target.type.isMechanical; },
		text: "Target needs to be a mechanical unit.",
		isTargetRequirement: true,
		funcName: "isMechanical"
	},
	
	isBuilding: {
		func: function(target){ return target.type.isBuilding; },
		text: "Target needs to be a building.",
		isTargetRequirement: true,
		funcName: "isBuilding"
	},
	
	isUnit: {
		func: function(target){ return target.type.isUnit; },
		text: "Target needs to be a unit.",
		isTargetRequirement: true,
		funcName: "isUnit"
	},
	
	isFlying: {
		func: function(target){ return target.type.flying; },
		text: "Target needs to be flying.",
		isTargetRequirement: true,
		funcName: "isFlying"
	},
	
	isGround: {
		func: function(target){ return !target.type.flying; },
		text: "Target needs to be on the ground.",
		isTargetRequirement: true,
		funcName: "isGround"
	},
	
	notFullHp: {
		func: function(target){ return target.hp < target.type.hp; },
		text: "Target has full life.",
		isTargetRequirement: true,
		funcName: "notFullHp"
	}
	
};




var targetFilters1 = {
	
	flying: "flying",
	isBiological: "isBiological",
	isMechanical: "isMechanical",
	isUndead: "isUndead",
	uniqueAndHeroic: "uniqueAndHeroic",
	isBeast: "isBeast",
	isHuman: "isHuman",
	isInvisible: "isInvisible"
	
};




// Units
var basicUnitTypes = [
	
	{
		name: "Soldier",
		id_string: "soldier",
		hp: 125,
		supply: 2,
		movementSpeed: 2.47 / 20,
		weaponCooldown: 1.15 * 20,
		weaponDelay: 0.25 * 20,
		dmg: 9,
		armor: 1,
		range: 0.2,
		size: 0.95,		// diameter
		vision: 8,
		circleSize: 0.43,
		circleOffset: 0,
		commands: {
			stop: "stop",
			holdposition: "holdposition",
			attack: "attack",
			move: "move",
			moveto: "moveto",
			amove: "amove"
		},
		buildTime: 25 * 20,
		cost: 85,
		healthbarOffset: 1.1,
		healthbarWidth: 0.7,
		img: "soldier",
		description: "Soldiers are basic melee combat units.",
		tabPriority: 7,
		drawOffsetY: 10, // how many pixels the unit image is shifted to the bottom when drawing
		meleeHitSound: SOUND.SWORD, // sound that is played, when this unit melee-hits another unit
		meleeHitVolume: 1,
		painSound: SOUND.PAIN,
		painSoundVolume: 0.4,
		painSound2: SOUND.FLESH,
		painSoundVolume2: 1,
		deathSound: SOUND.DEATH,
		isBiological: true,
		cargoUse: 2
	},

	{
		name: "Archer",
		id_string: "archer",
		hp: 80,
		supply: 2,
		movementSpeed: 2.41 / 20,
		weaponCooldown: 1.4 * 20,
		weaponDelay: 0.45 * 20,
		dmg: 6,
		armor: 0,
		range: 5,
		size: 0.95,		// diameter
		vision: 8,
		projectileSpeed: 12,
		projectileStartHeight: 0.25,
		attackLaunchSound: SOUND.SWING,
		circleSize: 0.43,
		circleOffset: 0.0,
		commands: {
			stop: "stop",
			holdposition: "holdposition",
			attack: "attack",
			move: "move",
			moveto: "moveto",
			amove: "amove"
		},
		buildTime: 25 * 20,
		cost: 85,
		healthbarOffset: 1.45,
		healthbarWidth: 0.7,
		img: "archer",
		description: "Archers are weaker than Soldiers, but can shoot over distance.",
		projectileLen: 0.2, // Fields
		tabPriority: 6,
		drawOffsetY: 10, // how many pixels the unit image is shifted to the bottom when drawing
		painSound: SOUND.PAIN,
		painSoundVolume: 0.4,
		painSound2: SOUND.FLESH,
		painSoundVolume2: 1,
		deathSound: SOUND.DEATH,
		bodyPower: 0.8,
		isBiological: true,
		canAttackFlying: true,
		cargoUse: 2,
		attackEffect: "arrow"
	},

	{
		name: "Worker",
		id_string: "worker",
		hp: 60,
		supply: 1,
		movementSpeed: 2.6 / 20,
		weaponCooldown: 1.0 * 20,
		weaponDelay: 0.3 * 20,
		dmg: 5,
		armor: 0,
		range: 0.2,
		size: 0.85,		// diameter
		vision: 8,
		repairRate: 8 / 20,
		repairCost: 0.05,
		circleSize: 0.43,
		circleOffset: 0.125,
		commands: {
			stop: "stop",
			holdposition: "holdposition",
			attack: "attack",
			move: "move",
			moveto: "moveto",
			amove: "amove",
			mine: "mine",
			buildcastle: "buildcastle",
			buildbarracks: "buildbarracks",
			buildwatchtower: "buildwatchtower",
			buildhouse: "buildhouse",
			repair: "repair",
			buildmagesguild: "buildmagesguild",
			buildworkshop: "buildworkshop",
			buildforge: "buildforge",
			buildings: "buildings",
			buildings2: "buildings2",
			builddragonslair: "builddragonslair",
			buildwolvesden: "buildwolvesden",
			buildanimaltestinglab: "buildanimaltestinglab",
			buildadvancedworkshop: "buildadvancedworkshop",
			buildchurch: "buildchurch",
			back: "back",
			back2: "back2"
		},
		buildTime: 27 * 20,
		cost: 50,
		healthbarOffset: 0.95,
		healthbarWidth: 0.7,
		img: "worker",
		description: "Workers gather gold and construct buildings. They can also fight, but are not very good at it.",
		tabPriority: 10,
		drawOffsetY: 12.5, // how many pixels the unit image is shifted to the bottom when drawing
		// meleeHitSound: SOUND.REPAIR, // sound that is played, when this unit melee-hits another unit
		// meleeHitVolume: 1.0,
		meleeHitSound: SOUND.REPAIR, // sound that is played, when this unit melee-hits another unit
		meleeHitVolume: 0.6,
		painSound: SOUND.PAIN,
		painSoundVolume: 0.4,
		painSound2: SOUND.FLESH,
		painSoundVolume2: 1,
		deathSound: SOUND.DEATH,
		isBiological: true,
		cargoUse: 1,
		isPassive: true,
		bodyPower: 0.8
	},
	
	{
		name: "Mage",
		id_string: "mage",
		hp: 80,
		supply: 3,
		mana: 100,
		startMana: 50,
		manaRegenerationRate: 0.8 / 20, // per tick
		movementSpeed: 2.2 / 20,
		weaponCooldown: 2.0 * 20,
		weaponDelay: 0.2 * 20,
		dmg: 5,
		armor: 0,
		range: 5,
		size: 0.95,		// diameter
		vision: 8,
		projectileSpeed: 10,
		projectileStartHeight: 0.5,
		attackLaunchSound: SOUND.MAGE_ATTACK,
		circleSize: 0.43,
		circleOffset: 0.125,
		commands: {
			stop: "stop",
			holdposition: "holdposition",
			attack: "attack",
			move: "move",
			moveto: "moveto",
			amove: "amove",
			summonslowfield: "summonslowfield",
			fireball: "fireball"
		},
		buildTime: 32 * 20,
		cost: 150,
		healthbarOffset: 1.25,
		healthbarWidth: 0.7,
		img: "mage",
		description: "Mages can cast several spells.",
		tabPriority: 15,
		drawOffsetY: 12, // how many pixels the unit image is shifted to the bottom when drawing
		painSound: SOUND.PAIN,
		painSoundVolume: 0.4,
		painSound2: SOUND.FLESH,
		painSoundVolume2: 1,
		deathSound: SOUND.DEATH,
		isBiological: true,
		canAttackFlying: true,
		cargoUse: 2,
		bodyPower: 0.8,
		attackEffect: "mageAttack"
	},
	
	{
		name: "Priest",
		id_string: "priest",
		hp: 80,
		supply: 3,
		mana: 100,
		startMana: 50,
		manaRegenerationRate: 0.8 / 20, // per tick
		movementSpeed: 2.2 / 20,
		weaponCooldown: 2.0 * 20,
		weaponDelay: 0.2 * 20,
		dmg: 5,
		armor: 0,
		range: 5,
		size: 0.95,		// diameter
		vision: 8,
		projectileSpeed: 10,
		attackLaunchSound: SOUND.MAGE_ATTACK,
		circleSize: 0.43,
		circleOffset: -0.05,
		commands: {
			stop: "stop",
			holdposition: "holdposition",
			attack: "attack",
			move: "move",
			moveto: "moveto",
			amove: "amove",
			summonhealingward: "summonhealingward",
			invisibilityspell: "invisibilityspell"
		},
		buildTime: 32 * 20,
		cost: 150,
		healthbarOffset: 1.2,
		healthbarWidth: 0.7,
		img: "priest",
		description: "Priests can cast several spells.",
		tabPriority: 14,
		drawOffsetY: 9, // how many pixels the unit image is shifted to the bottom when drawing
		painSound: SOUND.PAIN,
		painSoundVolume: 0.4,
		painSound2: SOUND.FLESH,
		painSoundVolume2: 1,
		deathSound: SOUND.DEATH,
		isBiological: true,
		canAttackFlying: true,
		cargoUse: 2,
		bodyPower: 0.8,
		attackEffect: "mageAttack"
	},
	
	{
		name: "Catapult",
		id_string: "catapult",
		hp: 150,
		supply: 4,
		movementSpeed: 1.65 / 20,
		weaponCooldown: 3.0 * 20,
		weaponDelay: 0.65 * 20,
		dmg: 35,
		armor: 1,
		range: 10,
		minRange: 4,
		aoeRadius: 0.45,
		size: 1.7,		// diameter
		vision: 8,
		projectileSpeed: 7,
		attackLaunchSound: SOUND.CATA_LAUNCH,
		circleSize: 0.96,
		circleOffset: 0.0,
		commands: {
			stop: "stop",
			holdposition: "holdposition",
			attack: "attack",
			move: "move",
			moveto: "moveto",
			amove: "amove",
			attackground: "attackground"
		},
		buildTime: 36 * 20,
		isHeatSeeking: false,
		cost: 150,
		healthbarOffset: 1.3,
		healthbarWidth: 1,
		img: "catapult",
		description: "Catapults have a high shooting range, but are pretty slow. They are perfect to break Towers. Catapults have a minimum fire range of 4.",
		tabPriority: 9,
		drawOffsetY: 13, // how many pixels the unit image is shifted to the bottom when drawing
		painSound: SOUND.CATA_HIT,
		painSoundVolume: 1,
		deathSound: SOUND.CATA_DEATH,
		bodyPower: 2.0,
		power: 2.0,
		isMechanical: true,
		dustCreationChance: 2 / 20, // high of chance, that one dust particle is created per tick
		cargoUse: 4,
		attackEffect: "launchedRock"
	},
	
	{
		name: "Dragon",
		id_string: "dragon",
		hp: 200,
		hpRegenerationRate: 0.8 / 20, // per tick
		supply: 6,
		movementSpeed: 3.7 / 20,
		weaponCooldown: 1.65 * 20,
		weaponDelay: 0.05 * 20,
		dmg: 10,
		armor: 0,
		range: 5,
		aoeRadius: 0.2,
		size: 2.9,		// diameter	
		vision: 10,
		projectileSpeed: 6,
		attackLaunchSound: SOUND.DRAGON_FIRE,
		circleSize: 1.8,
		circleOffset: -3,
		commands: {
			stop: "stop",
			holdposition: "holdposition",
			attack: "attack",
			move: "move",
			moveto: "moveto",
			amove: "amove"
		},
		buildTime: 45 * 20,
		cost: 285,
		healthbarOffset: 5.5,
		healthbarWidth: 1.6,
		selectionOffsetY: 3,
		img: "dragon",
		description: "Dragons are big, flying units.",
		tabPriority: 4,
		drawOffsetY: 34, // how many pixels the unit image is shifted to the bottom when drawing
		painSound: SOUND.FLESH,
		painSoundVolume: 1,
		deathSound: SOUND.DRAGON_DEATH,
		yesSound: SOUND.DRAGON_YES,
		yesSoundVolume: 1,
		readySound: SOUND.DRAGON_SPAWN,
		readySoundVolume: 1,
		dustCreationChance: -1 / 20, // high of chance, that one dust particle is created per tick
		flying: true,
		isBiological: true,
		visionHeightBonus: 2,
		animSpeed: 3,
		projectileStartHeight: 3,
		oscillationAmplitude: 0.15,
		canAttackFlying: true,
		height: 3.3, // when this units gets shot, this value is used to determinate where the projectile graphic hits
		acceleration: 0.03,
		angularVelocity: 0.2,
		removeAfterDeadAnimation: true,
		shootingReveals: true,
		causesFlameDeath: true,
		attackEffect: "dragonAttack"
	},
	
	{
		name: "Wolf",
		id_string: "wolf",
		hp: 80,
		hpRegenerationRate: 0.5 / 20, // per tick
		supply: 2,
		movementSpeed: 3.3 / 20,
		weaponCooldown: 1.15 * 20,
		weaponDelay: 0.25 * 20,
		dmg: 5,
		armor: 0,
		range: 0.2,
		size: 0.95,		// diameter
		vision: 8,
		circleSize: 0.53,
		circleOffset: -0.1,
		commands: {
			stop: "stop",
			holdposition: "holdposition",
			attack: "attack",
			move: "move",
			moveto: "moveto",
			amove: "amove"
		},
		buildTime: 16 * 20,
		cost: 45,
		healthbarOffset: 1.4,
		healthbarWidth: 0.7,
		img: "wolf",
		description: "Wolves are fast melee units.",
		tabPriority: 7,
		drawOffsetY: 7, // how much the unit image is shifted to the bottom when drawing
		meleeHitSound: SOUND.WOLF_HIT, // sound that is played, when this unit melee-hits another unit
		meleeHitVolume: 0.7,
		painSound: SOUND.WOLF_PAIN,
		painSoundVolume: 0.8,
		painSound2: SOUND.FLESH,
		painSoundVolume2: 1,
		yesSound: SOUND.WOLF_YES,
		yesSoundVolume: 1,
		deathSound: SOUND.WOLF_DEATH,
		readySound: SOUND.WOLF_READY,
		readySoundVolume: 1,
		isBiological: true,
		bodyPower: 0.5,
		cargoUse: 1
	},
	
	{
		name: "Airship",
		id_string: "airship",
		hp: 140,
		supply: 2,
		movementSpeed: 3.5 / 20,
		weaponCooldown: 1.65 * 20,
		weaponDelay: 0.05 * 20,
		dmg: 0,
		armor: 0,
		range: 0,
		size: 4.1,		// diameter
		vision: 10,
		projectileSpeed: 6,
		attackLaunchSound: SOUND.DRAGON_FIRE,
		circleSize: 2.0,
		circleOffset: -3,
		commands: {
			stop: "stop",
			holdposition: "holdposition",
			move: "move",
			moveto: "moveto",
			loadin: "loadin",
			unload: "unload",
			directunload: "directunload"
		},
		buildTime: 32 * 20,
		cost: 140,
		healthbarOffset: 6.3,
		healthbarWidth: 1.6,
		selectionOffsetY: 3,
		img: "airship",
		description: "Airships can transport your ground units.",
		tabPriority: 1,
		drawOffsetY: 34, // how many pixels the unit image is shifted to the bottom when drawing
		painSound: SOUND.CATA_HIT,
		painSoundVolume: 1,
		deathSound: SOUND.CATA_DEATH,
		dustCreationChance: -1 / 20, // high of chance, that one dust particle is created per tick
		flying: true,
		isMechanical: true,
		visionHeightBonus: 2,
		animSpeed: 2,
		oscillationAmplitude: 0.07,
		height: 3.3, // when this units gets shot, this value is used to determinate where the projectile graphic hits
		acceleration: 0.03,
		angularVelocity: 0.25,
		removeAfterDeadAnimation: true,
		cargoSpace: 10,
		deathAnimationSpeed: 0.3,
		isPassive: true
	},
	
	{
		name: "Werewolf",
		id_string: "werewolf",
		hp: 220,
		supply: 6,
		hpRegenerationRate: 0.9 / 20,
		movementSpeed: 2.2 / 20,
		weaponCooldown: 1.5 * 20,
		weaponDelay: 0.5 * 20,
		dmg: 20,
		armor: 3,
		range: 0.55,
		size: 1.95,		// diameter
		vision: 8,
		circleSize: 0.93,
		circleOffset: 0,
		commands: {
			stop: "stop",
			holdposition: "holdposition",
			attack: "attack",
			move: "move",
			moveto: "moveto",
			amove: "amove",
			smash: "smash"
		},
		buildTime: 40 * 20,
		cost: 250,
		healthbarOffset: 2.6,
		healthbarWidth: 1.0,
		img: "werewolf",
		description: "Werewolfs are very strong melee units.",
		tabPriority: 8,
		drawOffsetY: 21.0, // how many pixels the unit image is shifted to the bottom when drawing
		painSound: SOUND.WOLF_PAIN,
		painSoundVolume: 0.5,
		painSound2: SOUND.FLESH,
		painSoundVolume2: 1,
		meleeHitSound: SOUND.STRONG_HIT, // sound that is played, when this unit melee-hits another unit
		meleeHitVolume: 1.0,
		yesSound: SOUND.BEAST_YES,
		yesSoundVolume: 1,
		deathSound: SOUND.BEAST_DIE,
		readySound: SOUND.BEAST_READY,
		readySoundVolume: 1,
		isBiological: true,
		cargoUse: 4,
		animSpeed: 3,
		bodyPower: 2.5,
		deathAnimationSpeed: 0.2,
		// idleFrames: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 2, 2],
		power: 2.0
	},
	
	{
		name: "Ballista",
		id_string: "ballista",
		hp: 150,
		supply: 4,
		movementSpeed: 2.0 / 20,
		weaponCooldown: 3.0 * 20,
		weaponDelay: 0.3 * 20,
		dmg: 30,
		armor: 2,
		range: 7.5,
		size: 1.7,		// diameter
		vision: 8,
		projectileSpeed: 14,
		attackLaunchSound: SOUND.CATA_LAUNCH,
		circleSize: 1.1,
		circleOffset: 0.0,
		commands: {
			stop: "stop",
			holdposition: "holdposition",
			attack: "attack",
			move: "move",
			moveto: "moveto",
			amove: "amove"
		},
		buildTime: 32 * 20,
		cost: 150,
		healthbarOffset: 1.8,
		healthbarWidth: 1,
		img: "ballista",
		description: "Ballistas are slow but strong anti air units.",
		tabPriority: 3,
		drawOffsetY: 20, // how many pixels the unit image is shifted to the bottom when drawing
		painSound: SOUND.CATA_HIT,
		painSoundVolume: 1,
		deathSound: SOUND.CATA_DEATH,
		bodyPower: 2.0,
		isMechanical: true,
		dustCreationChance: 2 / 20, // high of chance, that one dust particle is created per tick
		cargoUse: 4,
		canAttackFlying: true,
		canAttackGround: false,
		attackEffect: "ballista",
		projectileStartHeight: 1,
		power: 2.0
	},
	
	{
		name: "Shadow Wolf",
		id_string: "shadowwolf",
		hp: 85,
		hpRegenerationRate: 0.035, // per tick
		supply: 3,
		movementSpeed: 3.0 / 20,
		weaponCooldown: 0.9 * 20,
		weaponDelay: 0.2 * 20,
		dmg: 11,
		armor: 0,
		range: 0.2,
		size: 0.95,		// diameter
		vision: 8,
		circleSize: 0.53,
		circleOffset: -0.1,
		commands: {
			stop: "stop",
			holdposition: "holdposition",
			attack: "attack",
			move: "move",
			moveto: "moveto",
			amove: "amove",
			teleport: "teleport"
		},
		buildTime: 24 * 20,
		cost: 80,
		healthbarOffset: 1.4,
		healthbarWidth: 0.7,
		img: "wolf",
		description: "Wolves are fast melee units.",
		tabPriority: 7,
		drawOffsetY: 7, // how much the unit image is shifted to the bottom when drawing
		meleeHitSound: SOUND.WOLF_HIT, // sound that is played, when this unit melee-hits another unit
		meleeHitVolume: 0.7,
		painSound: SOUND.WOLF_PAIN,
		painSoundVolume: 0.8,
		painSound2: SOUND.FLESH,
		painSoundVolume2: 1	,
		yesSound: SOUND.WOLF_YES,
		yesSoundVolume: 1,
		deathSound: SOUND.WOLF_DEATH,
		readySound: SOUND.WOLF_READY,
		readySoundVolume: 1,
		isBiological: true,
		isInvisible: true,
		cargoUse: 1
	},
	
	{
		name: "Skeleton",
		id_string: "skeleton",
		hp: 115,
		supply: 0,
		movementSpeed: 2.0 / 20,
		weaponCooldown: 1.25 * 20,
		weaponDelay: 0.25 * 20,
		dmg: 9,
		armor: 0,
		range: 0.2,
		size: 0.95,		// diameter
		vision: 8,
		circleSize: 0.43,
		circleOffset: 0.125,
		commands: {
			stop: "stop",
			holdposition: "holdposition",
			attack: "attack",
			move: "move",
			moveto: "moveto",
			amove: "amove"
		},
		buildTime: 23 * 20,
		cost: 0,
		healthbarOffset: 1.0,
		healthbarWidth: 0.7,
		img: "skeleton",
		description: "Skeletons are basic melee combat units. They are undead, that means they take damage from healing spells.",
		tabPriority: 7,
		drawOffsetY: 6, // how many pixels the unit image is shifted to the bottom when drawing
		meleeHitSound: SOUND.SWORD, // sound that is played, when this unit melee-hits another unit
		meleeHitVolume: 1,
		painSound: SOUND.SKELETON_PAIN,
		painSoundVolume: 0.5,
		painSound2: SOUND.FLESH,
		painSoundVolume2: 1,
		yesSound: SOUND.SKELETON_YES,
		yesSoundVolume: 0.8,
		deathSound: SOUND.SKELETON_SPAWN,
		readySound: SOUND.SKELETON_SPAWN,
		isBiological: true,
		cargoUse: 2,
		lifetime: 35 * 20,
		isUndead: true,
		summonTime: 2 * 20
	},
	
	{
		name: "Bird",
		id_string: "bird",
		hp: 40,
		supply: 1,
		movementSpeed: 3.5 / 20,
		armor: 0,
		size: 0.95,		// diameter
		vision: 9,
		circleSize: 0.6,
		circleOffset: -2.9,
		commands: {
			stop: "stop",
			holdposition: "holdposition",
			move: "move",
			moveto: "moveto"
		},
		buildTime: 35 * 20,
		cost: 85,
		healthbarOffset: 3.8,
		healthbarWidth: 0.8,
		selectionOffsetY: 3,
		img: "bird",
		description: "Birds are small, unarmed units that can be used for scouting.",
		tabPriority: 4,
		drawOffsetY: 10, // how many pixels the unit image is shifted to the bottom when drawing
		painSound: SOUND.FLESH,
		painSoundVolume: 0.7,
		deathSound: SOUND.BIRD_DEATH,
		yesSound: SOUND.BIRD_YES,
		yesSoundVolume: 1,
		readySound: SOUND.BIRD_SPAWN,
		readySoundVolume: 1,
		dustCreationChance: -1 / 20, // high of chance, that one dust particle is created per tick
		flying: true,
		isBiological: true,
		visionHeightBonus: 1,
		animSpeed: 3,
		oscillationAmplitude: 0.05,
		height: 3.3, // when this units gets shot, this value is used to determinate where the projectile graphic hits
		acceleration: 0.03,
		angularVelocity: 0.2,
		removeAfterDeadAnimation: true,
		deathAnimationSpeed: 0.5,
		bodyPower: 0.25,
		slamSound: SOUND.BIRD_SLAM
	},
	
	{
		name: "Healing Ward",
		id_string: "healingward",
		hp: 95,
		supply: 0,
		movementSpeed: 0,
		armor: 1,
		size: 0.85,
		vision: 7,
		circleSize: 0.6,
		circleOffset: 0,
		commands: {},
		buildTime: 45 * 20,
		cost: 0,
		healthbarOffset: 1.75,
		healthbarWidth: 0.7,
		img: "totem",
		description: "Healing Wards heal nearby allied non-undead units and damage enemy undead units.",
		tabPriority: 2,
		drawOffsetY: 7.5,
		painSound: SOUND.CATA_HIT,
		painSoundVolume: 1,
		deathSound: SOUND.CATA_DEATH,
		dustCreationChance: -1 / 20, // hight of chance, that one dust particle is created per tick
		animSpeed: 5,
		deathAnimationSpeed: 0.3,
		spawnModifiers: ["healaura", "healauradmg"],
		lifetime: 30 * 20,
		attackPrio: 6,
		idleFrames: [0, 1, 2, 3, 2, 1],
		summonTime: 0.8 * 20,
		noMoveWhenHit: true,
		power: 2.0
	},
	
	{
		name: "Slowing Field",
		id_string: "slowingfield",
		hp: 999999,
		supply: 0,
		movementSpeed: 0,
		armor: 1,
		size: 0.85,
		vision: -1,
		circleSize: 0.6,
		circleOffset: 0,
		commands: {},
		buildTime: 45 * 20,
		cost: 0,
		healthbarOffset: 1.75,
		healthbarWidth: 0.7,
		img: "totem",
		description: "Creates an aura that slows down the movement speed of ground units.",
		tabPriority: 2,
		drawOffsetY: 7.5,
		dustCreationChance: -1 / 20, // hight of chance, that one dust particle is created per tick
		animSpeed: 5,
		isInvincible: true,
		noShow: true,
		noCollision: true,
		deathAnimationSpeed: 0.3,
		spawnModifiers: ["slowfield"],
		lifetime: 25 * 20,
		attackPrio: 6,
		idleFrames: [0, 1, 2, 3, 2, 1],
		summonTime: 0.8 * 20,
		noMoveWhenHit: true,
		power: 2.0
	}/*,
	
	{
		name: "Hero",
		id_string: "hero",
		hp: 115,
		supply: 0,
		movementSpeed: 1.8 / 20,
		weaponCooldown: 1.25 * 20,
		weaponDelay: 0.25 * 20,
		dmg: 9,
		armor: 0,
		range: 0.2,
		size: 0.95,		// diameter
		vision: 8,
		circleSize: 0.43,
		circleOffset: 0.125,
		commands: {
			stop: "stop",
			holdposition: "holdposition",
			attack: "attack",
			move: "move",
			moveto: "moveto",
			amove: "amove",
			fire: "fire",
			summontest: "summontest"
		},
		buildTime: 23 * 20,
		cost: 0,
		healthbarOffset: 1.0,
		healthbarWidth: 0.7,
		img: "skeleton",
		description: "Skeletons are basic melee combat units. They are undead, that means they take damage from healing spells.",
		tabPriority: 7,
		drawOffsetY: 6, // how many pixels the unit image is shifted to the bottom when drawing
		meleeHitSound: SOUND.SWORD, // sound that is played, when this unit melee-hits another unit
		meleeHitVolume: 1,
		painSound: SOUND.SKELETON_PAIN,
		painSoundVolume: 0.5,
		painSound2: SOUND.FLESH,
		painSoundVolume2: 1,
		yesSound: SOUND.SKELETON_YES,
		yesSoundVolume: 0.8,
		deathSound: SOUND.SKELETON_SPAWN,
		readySound: SOUND.SKELETON_SPAWN,
		isBiological: true,
		experienceLevels: [1, 2, 3, 4, 5, 6, 7],
		cargoUse: 2,
		mana: 200,
		startMana: 200
	}*/
	
];
	
	





// Buildings
var basicBuildingTypes = [
	
	{
		name: "Castle",
		id_string: "castle",
		hp: 1400,
		supplyProvided: 10,
		size: 4,
		weaponCooldown: 1 * 20,
		weaponDelay: 1 * 20,
		dmg: 0,
		armor: 1,
		range: 0,
		vision: 10,
		circleSize: 2.65,
		circleOffset: 0.625,
		commands: {
			trainworker: "trainworker",
			upgradetofortress: "upgradetofortress",
			trainbird: "trainbird"
		},
		buildTime: 54 * 20,
		cost: 350,
		healthbarOffset: 3.25,
		healthbarWidth: 2.5,
		img: "castle",
		description: "The Castle is your main building. It can train workers and is used to return gathered gold.",
		timeToMine: 2, // how many ticks workers stay to get / deliver gold
		projectileLen: 0.22, // Fields
		tabPriority: 10,
		takesGold: true,
		preventsReveal: true,
		clickSound: SOUND.CC,
		clickSoundVolume: 1,
		canHaveWaypoint: true
	},

	{
		name: "Barracks",
		id_string: "barracks",
		hp: 750,
		size: 3,
		weaponCooldown: 1 * 20,
		weaponDelay: 1 * 20,
		dmg: 0,
		armor: 1,
		range: 0,
		vision: 8,
		circleSize: 2.4,
		circleOffset: 0.25,
		commands: {
			trainsoldier: "trainsoldier",
			trainarcher: "trainarcher"
		},
		buildTime: 40 * 20,
		cost: 150,
		healthbarOffset: 3.7,
		healthbarWidth: 2.0,
		img: "barracks",
		description: "The Barracks can train Soldiers and Archers.",
		tabPriority: 7,
		preventsReveal: false,
		clickSound: SOUND.RAX,
		clickSoundVolume: 0.8,
		canHaveWaypoint: true
	},

	{
		name: "Watchtower",
		id_string: "watchtower",
		hp: 400,
		size: 2,
		weaponCooldown: 1.6 * 20,
		weaponDelay: 0.3 * 20,
		dmg: 15,
		armor: 1,
		range: 7,
		vision: 12,
		projectileSpeed: 14,
		projectileStartHeight: 1.75,
		attackLaunchSound: SOUND.SWING,
		circleSize: 1.45,
		circleOffset: 0.312,
		commands: {
			stop: "stop",
			attack: "attack",
			researchdetection: "researchdetection"
		},
		buildTime: 36 * 20,
		cost: 125,
		costIncrease: 25,
		costIncreaseGroup: ["watchtower", "watchtower2"],
		healthbarOffset: 3.69,
		healthbarWidth: 1.56,
		img: "watchtower",
		description: "The Watchtower is a defensive structure, which shoots arrows at enemy units in range. Watchtowers get more expensive the more you have.",
		projectileLen: 0.22, // Fields
		tabPriority: 2,
		attackEffect: "arrow",
		canAttackFlying: true,
		hasDetection: false,
		preventsReveal: false,
		attackPrio: 10
	},
	
	{
		name: "Watchtower (detection)",
		id_string: "watchtower2",
		hp: 450,
		size: 2,
		weaponCooldown: 1.6 * 20,
		weaponDelay: 0.3 * 20,
		dmg: 15,
		armor: 1,
		range: 7,
		vision: 12,
		projectileSpeed: 14,
		projectileStartHeight: 1.75,
		attackLaunchSound: SOUND.SWING,
		circleSize: 1.45,
		circleOffset: 0.312,
		commands: {
			stop: "stop",
			attack: "attack"
		},
		buildTime: 27 * 20,
		cost: 50,
		healthbarOffset: 3.69,
		healthbarWidth: 1.56,
		img: "watchtower",
		description: "The Watchtower is a defensive structure, which shoots arrows at enemy units in range. Watchtowers get more expensive the more you have. Watchtowers have detection, that means they can see enemy invisible units.",
		projectileLen: 0.22, // Fields
		tabPriority: 2,
		attackEffect: "arrow",
		canAttackFlying: true,
		hasDetection: true,
		preventsReveal: false,
		attackPrio: 10
	},
	
	{
		name: "House",
		id_string: "house",
		hp: 550,
		supplyProvided: 10,
		size: 3,
		weaponCooldown: 1.8 * 20,
		weaponDelay: 1 * 20,
		dmg: 0,
		armor: 1,
		range: 0,
		vision: 8,
		circleSize: 2.4,
		circleOffset: 0.25,
		commands: {},
		buildTime: 32 * 20,
		cost: 125,
		healthbarOffset: 3.4,
		healthbarWidth: 2.1,
		img: "house",
		description: "A house increases your max population by 10. You also need at least one House to construct a Barracks.",
		tabPriority: 1,
		preventsReveal: false,
		clickSound: SOUND.HOUSE,
		clickSoundVolume: 1
	},
	/*
	{
		name: "Medicus",
		id_string: "medicus",
		hp: 600,
		supplyProvided: 10,
		size: 3,
		weaponCooldown: 1.8 * 20,
		weaponDelay: 0.3 * 20,
		dmg: 0,
		armor: 1,
		range: 0,
		vision: 8,
		circleSize: 2.4,
		circleOffset: 0.25,
		buildTime: 35 * 20,
		cost: 200,
		healthbarOffset: 3.4,
		healthbarWidth: 2.1,
		img: "house",
		commands: {
			medicheal: "medicheal"
		},
		description: "A house increases your max population by 10. You also need at least one House to construct a Barracks.",
		tabPriority: 1,
		preventsReveal: false,
		mana: 200,
		startMana: 200,
		manaRegenerationRate: 2 / 20
	},
	*/
	{
		name: "Goldmine",
		id_string: "goldmine",
		hp: 40000,
		size: 3,
		weaponCooldown: 1 * 20,
		weaponDelay: 1 * 20,
		dmg: 0,
		armor: 10,
		range: 0,
		vision: 0,
		circleSize: 2.12,
		circleOffset: 0.17,
		commands: {},
		buildTime: 30 * 20,
		cost: 250,
		healthbarOffset: 2.15,
		healthbarWidth: 2.03,
		img: "mine",
		description: "The Goldmine contains gold for players to gather. You can gather it with your workers. The more workers are working on a mine, the less eficient they will work. If you have more mines, its better to spread you workers across them.",
		isInvincible: true,
		startGold: 5000,
		maxWorkers: 6,
		miningEfficiencyCoefficient: 0.5,
		minMiningRate: 0.25,
		timeToMine: 32,
		alwaysNeutral: true,
		goldPerDelivery: 5,
		preventsReveal: false
	},
	
	{
		name: "Mages Guild",
		id_string: "magesguild",
		hp: 600,
		size: 3,
		weaponCooldown: 1 * 20,
		weaponDelay: 1 * 20,
		dmg: 0,
		armor: 1,
		range: 0,
		vision: 8,
		circleSize: 2.1,
		circleOffset: 0.2,
		commands: {
			researchfireball: "researchfireball",
			trainmage: "trainmage",
		},
		buildTime: 54 * 20,
		cost: 150,
		healthbarOffset: 3.45,
		healthbarWidth: 2.04,
		img: "mages_guild",
		description: "The Mages Guild allows you to train Mages and research spells. Mages are strong, but vulnerable units. Researching spells will become more expensive the more spells you research.",
		tabPriority: 6,
		preventsReveal: false,
		clickSound: SOUND.MAGES_GUILD,
		clickSoundVolume: 0.9,
		canHaveWaypoint: true
	},
	
	{
		name: "Workshop",
		id_string: "workshop",
		hp: 800,
		size: 4,
		weaponCooldown: 1 * 20,
		weaponDelay: 1 * 20,
		dmg: 0,
		armor: 1,
		range: 0,
		vision: 8,
		circleSize: 3,
		circleOffset: 0.4,
		commands: {
			constructcatapult: "constructcatapult"
		},
		buildTime: 63 * 20,
		cost: 150,
		healthbarOffset: 3.6,
		healthbarWidth: 2.7,
		img: "workshop",
		busySmokeEffectLocationX: 0.5,
		busySmokeEffectLocationY: 3,
		busySmokeEffectLocationZ: 5.7,
		description: "The Workshop allows you to build Catapults. Catapults are slow units, that can break Towers.",
		tabPriority: 5,
		preventsReveal: false,
		clickSound: SOUND.WORKSHOP,
		clickSoundVolume: 1,
		canHaveWaypoint: true
	},
	
	{
		name: "Forge",
		id_string: "forge",
		hp: 500,
		size: 4,
		weaponCooldown: 1 * 20,
		weaponDelay: 1 * 20,
		dmg: 0,
		armor: 1,
		range: 0,
		vision: 8,
		circleSize: 3,
		circleOffset: 0.2,
		commands: {
			attackupgrade: "attackupgrade",
			armorupgrade: "armorupgrade",
			speedupgrade: "speedupgrade",
			mechattackupgrade: "mechattackupgrade",
			mecharmorupgrade: "mecharmorupgrade",
			mechspeedupgrade: "mechspeedupgrade",
			mechrangeupgrade: "mechrangeupgrade",
			rangeupgrade: "rangeupgrade"
		},
		buildTime: 50 * 20,
		cost: 150,
		healthbarOffset: 3,
		healthbarWidth: 2.7,
		img: "forge",
		busySmokeEffectLocationX: -1.3,
		busySmokeEffectLocationY: 3,
		busySmokeEffectLocationZ: 5.0,
		description: "The Forge provides you with the ability to research upgrades. Upgrades improve the stats of your human units like damage or armor.",
		tabPriority: 3,
		preventsReveal: false,
		clickSound: SOUND.FORGE,
		clickSoundVolume: 0.75
	},
	
	{
		name: "Start Location",
		id_string: "startlocation",
		hp: 400,
		size: 4,
		weaponCooldown: 1 * 20,
		supplyProvided: 10,
		weaponDelay: 1 * 20,
		dmg: 0,
		armor: 1,
		range: 0,
		vision: 8,
		circleSize: 3,
		circleOffset: 0.2,
		commands: {},
		buildTime: 55 * 20,
		cost: 150,
		healthbarOffset: 3,
		healthbarWidth: 2.7,
		img: "start_location",
		description: "The Start Location marks where a player starts. When the game begins, a Castle and 6 Workers will be created at this position.",
		tabPriority: 3,
		isInvincible: true,
		limit: 1,
		takesGold: true,
		preventsReveal: true
	},
	
	{
		name: "Fortress",
		id_string: "fortress",
		hp: 1800,
		supplyProvided: 10,
		size: 4,
		weaponCooldown: 2 * 20,
		weaponDelay: 1 * 20,
		dmg: 0,
		armor: 2,
		range: 0,
		projectileSpeed: 14,
		projectileStartHeight: 1.75,
		attackLaunchSound: SOUND.SWING,
		vision: 10,
		circleSize: 2.65,
		circleOffset: 0.625,
		commands: {
			trainworker: "trainworker",
			trainbird: "trainbird"
		},
		buildTime: 72 * 20,
		cost: 100,
		healthbarOffset: 4.25,
		healthbarWidth: 2.5,
		img: "fortress",
		description: "The Fortress is an advanced version of the Castle. It allows you to build a Dragons Lair.",
		timeToMine: 2, // how many ticks workers stay to get / deliver gold
		projectileLen: 0.22, // Fields
		tabPriority: 10,
		attackEffect: "arrow",
		takesGold: true,
		preventsReveal: true,
		clickSound: SOUND.CC,
		clickSoundVolume: 1,
		canHaveWaypoint: true
	},
	
	{
		name: "Dragons Lair",
		id_string: "dragonslair",
		hp: 600,
		size: 3,
		weaponCooldown: 1 * 20,
		weaponDelay: 1 * 20,
		dmg: 0,
		armor: 1,
		range: 0,
		vision: 8,
		circleSize: 2.5,
		circleOffset: 0.15,
		commands: {
			traindragon: "traindragon"
		},
		buildTime: 72 * 20,
		cost: 200,
		healthbarOffset: 4.65,
		healthbarWidth: 2.5,
		img: "dragons_lair",
		description: "The Dragons Lair allows you to train Dragons.",
		tabPriority: 10,
		preventsReveal: false,
		clickSound: SOUND.DRAGONS_LAIR,
		clickSoundVolume: 0.85,
		canHaveWaypoint: true
	},
	
	{
		name: "Wolves Den",
		id_string: "wolvesden",
		hp: 600,
		size: 3,
		weaponCooldown: 1 * 20,
		weaponDelay: 1 * 20,
		dmg: 0,
		armor: 1,
		range: 0,
		vision: 8,
		circleSize: 2.3,
		circleOffset: 0.125,
		commands: {
			trainwolf: "trainwolf",
			upgradetowerewolvesden: "upgradetowerewolvesden"
		},
		buildTime: 40 * 20,
		cost: 100,
		healthbarOffset: 2.95,
		healthbarWidth: 2.5,
		img: "wolves_den",
		description: "The Wolves Den allows you to train Wolves.",
		tabPriority: 12,
		preventsReveal: false,
		clickSound: SOUND.W_DEN,
		clickSoundVolume: 1,
		canHaveWaypoint: true
	},
	
	{
		name: "Animal Testing Lab",
		id_string: "animaltestinglab",
		hp: 550,
		size: 4,
		weaponCooldown: 1 * 20,
		weaponDelay: 1 * 20,
		dmg: 0,
		armor: 1,
		range: 0,
		vision: 8,
		circleSize: 3.4,
		circleOffset: 0.125,
		commands: {
			beastattackupgrade: "beastattackupgrade",
			beastdefenseupgrade: "beastdefenseupgrade",
			beastspeedupgrade: "beastspeedupgrade",
			beastrangeupgrade: "beastrangeupgrade"
		},
		buildTime: 54 * 20,
		cost: 150,
		healthbarOffset: 3.75,
		healthbarWidth: 3.1,
		img: "animal_testing_lab",
		description: "The Animal Testing Lab allows you to research upgrades for your beasts.",
		tabPriority: 11,
		preventsReveal: false,
		clickSound: SOUND.LAB,
		clickSoundVolume: 1
	},
	
	{
		name: "Advanced Workshop",
		id_string: "advancedworkshop",
		hp: 650,
		size: 4,
		weaponCooldown: 1 * 20,
		weaponDelay: 1 * 20,
		dmg: 0,
		armor: 1,
		range: 0,
		vision: 8,
		circleSize: 3.4,
		circleOffset: 0.125,
		commands: {
			constructballista: "constructballista",
			constructairship: "constructairship",
			ballistaexplosives: "ballistaexplosives",
			researchtelescope: "researchtelescope"
		},
		buildTime: 63 * 20,
		cost: 150,
		healthbarOffset: 3.75,
		healthbarWidth: 3.1,
		img: "adv_workshop",
		description: "The Advanced Workshop allows you to build airships and Ballistas.",
		tabPriority: 12,
		preventsReveal: false,
		clickSound: SOUND.A_WS,
		clickSoundVolume: 1,
		canHaveWaypoint: true
	},
	
	{
		name: "Werewolves Den",
		id_string: "werewolvesden",
		hp: 750,
		size: 3,
		weaponCooldown: 1 * 20,
		weaponDelay: 1 * 20,
		dmg: 0,
		armor: 2,
		range: 0,
		vision: 8,
		circleSize: 2.3,
		circleOffset: 0.125,
		commands: {
			trainwolf: "trainwolf",
			trainwerewolf: "trainwerewolf"
		},
		buildTime: 100 * 20,
		cost: 250,
		healthbarOffset: 3.95,
		healthbarWidth: 2.5,
		img: "werewolves_den",
		description: "The Werewolves Den allows you to train Wolves and Werewolves.",
		tabPriority: 13,
		preventsReveal: false,
		clickSound: SOUND.WW_DEN,
		clickSoundVolume: 1,
		canHaveWaypoint: true
	},
	
	{
		name: "Church",
		id_string: "church",
		hp: 700,
		size: 4,
		weaponCooldown: 1 * 20,
		weaponDelay: 1 * 20,
		dmg: 0,
		armor: 1,
		range: 0,
		vision: 8,
		circleSize: 3.3,
		circleOffset: 0.125,
		commands: {
			researchsummonhealingward: "researchsummonhealingward",
			researchinvisibility: "researchinvisibility",
			trainpriest: "trainpriest"
		},
		buildTime: 54 * 20,
		cost: 150,
		healthbarOffset: 4.7,
		healthbarWidth: 2.5,
		img: "church",
		description: "The Church allows you to train Priests and research spells. Priests are strong, but vulnerable units. Researching spells will become more expensive the more spells you research.",
		tabPriority: 12,
		preventsReveal: false,
		clickSound: SOUND.CHURCH,
		clickSoundVolume: 1,
		canHaveWaypoint: true
	}
];








// Tiles
var tileTypes = [
	
	new TileType({
		name: "Tree 1",
		img: {x: 164, y: 41, w: 28, h: 50},
		sizeX: 1,
		sizeY: 1,
		isTree: true,
		blocking: true
	}),
	
	new TileType({
		name: "Tree 2",
		img: {x: 0, y: 91, w: 28, h: 50},
		sizeX: 1,
		sizeY: 1,
		isTree: true,
		blocking: true
	}),
	
	new TileType({
		name: "Tree 3",
		img: {x: 68, y: 91, w: 28, h: 50},
		sizeX: 1,
		sizeY: 1,
		blocking: true
	}),
	
	new TileType({
		name: "Tree 4",
		img: {x: 136, y: 91, w: 28, h: 50},
		sizeX: 1,
		sizeY: 1,
		isTree: true,
		blocking: true
	}),
	
	new TileType({
		name: "Tree 5",
		img: {x: 108, y: 207, w: 17, h: 30},
		sizeX: 1,
		sizeY: 1,
		isTree: true,
		blocking: true
	}),
	
	new TileType({
		name: "Tree 6",
		img: {x: 132, y: 188, w: 38, h: 50},
		sizeX: 2,
		sizeY: 2,
		isTree: true,
		blocking: true
	}),
	
	new TileType({
		name: "Tree 7",
		img: {x: 174, y: 188, w: 35, h: 50},
		sizeX: 2,
		sizeY: 2,
		isTree: true,
		blocking: true
	}),
	
	new TileType({
		name: "Tree 8",
		img: {x: 188, y: 244, w: 64, h: 64},
		sizeX: 3,
		sizeY: 3,
		isTree: true,
		blocking: true
	}),
	
	new TileType({
		name: "Tree 9",
		img: {x: 3, y: 300, w: 42, h: 50},
		sizeX: 2,
		sizeY: 2,
		isTree: true,
		blocking: true
	}),
	
	new TileType({
		name: "Tree 10",
		img: {x: 39, y: 248, w: 52, h: 50},
		sizeX: 2,
		sizeY: 2,
		isTree: true,
		blocking: true
	}),
	
	new TileType({
		name: "Tree 11",
		img: {x: 48, y: 301, w: 52, h: 45},
		sizeX: 2,
		sizeY: 2,
		blocking: true
	}),
	
	new TileType({
		name: "Tree 12",
		img: {x: 105, y: 303, w: 42, h: 50},
		sizeX: 2,
		sizeY: 2,
		isTree: true,
		blocking: true
	}),
	
	new TileType({
		name: "Tree 13",
		img: {x: 150, y: 313, w: 66, h: 65},
		sizeX: 3,
		sizeY: 3,
		isTree: true,
		blocking: true
	}),
	
	new TileType({
		name: "Cactus",
		img: {x: 284, y: 27, w: 18, h: 26},
		sizeX: 1,
		sizeY: 1,
		blocking: true
	}),
	
	new TileType({
		name: "Cactus 2",
		img: {x: 284, y: 55, w: 18, h: 26},
		sizeX: 1,
		sizeY: 1,
		blocking: true
	}),
	
	new TileType({
		name: "Cactus 3",
		img: {x: 362, y: 119, w: 37, h: 45},
		sizeX: 2,
		sizeY: 2,
		blocking: true
	}),
	
	new TileType({
		name: "Grave Stone 1",
		img: {x: 795, y: 275, w: 20, h: 30},
		sizeX: 1,
		sizeY: 1,
		blocking: true,
		noRandomOffset: true
	}),
	
	new TileType({
		name: "Grave Stone 2",
		img: {x: 817, y: 276, w: 20, h: 29},
		sizeX: 1,
		sizeY: 1,
		blocking: true,
		noRandomOffset: true
	}),
	
	new TileType({
		name: "Grave Stone 3",
		img: {x: 839, y: 276, w: 20, h: 29},
		sizeX: 1,
		sizeY: 1,
		blocking: true,
		noRandomOffset: true
	}),
	
	new TileType({
		name: "Grave Stone 4",
		img: {x: 861, y: 286, w: 18, h: 19},
		sizeX: 1,
		sizeY: 1,
		blocking: true,
		noRandomOffset: true
	}),
	
	new TileType({
		name: "Grave Stone 5",
		img: {x: 787, y: 306, w: 54, h: 45},
		sizeX: 3,
		sizeY: 1,
		blocking: true,
		noRandomOffset: true
	}),
	
	new TileType({
		name: "Grave Stone 6",
		img: {x: 843, y: 322, w: 68, h: 29},
		sizeX: 4,
		sizeY: 1,
		blocking: true,
		noRandomOffset: true
	}),
	
	new TileType({
		name: "Grave Stone 7",
		img: {x: 916, y: 317, w: 38, h: 59},
		sizeX: 2,
		sizeY: 1,
		blocking: true,
		noRandomOffset: true
	}),
	
	new TileType({
		name: "Egypt Tile 1",
		img: {x: 251, y: 25, w: 28, h: 56},
		sizeX: 1,
		sizeY: 1,
		blocking: true
	}),
	
	new TileType({
		name: "Palm",
		img: {x: 306, y: 23, w: 57, h: 71},
		sizeX: 1,
		sizeY: 1,
		isTree: true,
		blocking: true
	}),
	
	new TileType({
		name: "Tree 14",
		img: {x: 45, y: 348, w: 26, h: 25},
		sizeX: 1,
		sizeY: 1,
		isTree: true,
		blocking: true
	}),
	
	new TileType({
		name: "Tree 15",
		img: {x: 491, y: 58, w: 23, h: 60},
		sizeX: 1,
		sizeY: 1,
		isTree: true,
		blocking: true
	}),
	
	new TileType({
		name: "Stone 1",
		img: {x: 0, y: 35, w: 28, h: 50},
		sizeX: 1,
		sizeY: 1,
		blocking: true
	}),
	
	new TileType({
		name: "Stone 2",
		img: {x: 28, y: 32, w: 40, h: 60},
		sizeX: 2,
		sizeY: 2,
		blocking: true
	}),
	
	new TileType({
		name: "Stone 3",
		img: {x: 68, y: 35, w: 28, h: 50},
		sizeX: 1,
		sizeY: 1,
		blocking: true
	}),
	
	new TileType({
		name: "Stone 4",
		img: {x: 96, y: 35, w: 40, h: 60},
		sizeX: 2,
		sizeY: 2,
		blocking: true
	}),
	
	new TileType({
		name: "Stone 5",
		img: {x: 136, y: 32, w: 28, h: 50},
		sizeX: 1,
		sizeY: 1,
		blocking: true
	}),
	
	new TileType({
		name: "Stone 10",
		img: {x: 44, y: 376, w: 18, h: 20},
		sizeX: 1,
		sizeY: 1,
		blocking: true
	}),
	
	new TileType({
		name: "Stone 16",
		img: {x: 94, y: 252, w: 36, h: 45},
		sizeX: 2,
		sizeY: 2,
		blocking: true
	}),
	
	new TileType({
		name: "Stone 17",
		img: {x: 130, y: 252, w: 40, h: 45},
		sizeX: 2,
		sizeY: 2,
		blocking: true
	}),
	
	new TileType({
		name: "Stone 18",
		img: {x: 567, y: 50, w: 26, h: 31},
		sizeX: 1,
		sizeY: 1,
		blocking: true
	}),
	
	new TileType({
		name: "Wall",
		img: {x: 192, y: 2, w: 60, h: 78},
		sizeX: 2,
		sizeY: 2,
		blocking: true,
		noRandomOffset: true
	}),
	
	new TileType({
		name: "Wall 2",
		img: {x: 192, y: 80, w: 60, h: 80},
		sizeX: 2,
		sizeY: 2,
		blocking: true,
		noRandomOffset: true
	}),
	
	new TileType({
		name: "Wall 3",
		img: {x: 0, y: 160, w: 60, h: 80},
		sizeX: 2,
		sizeY: 2,
		blocking: true,
		noRandomOffset: true
	}),
	
	new TileType({
		name: "Wall 4",
		img: {x: 60, y: 160, w: 28, h: 50},
		sizeX: 1,
		sizeY: 1,
		blocking: true,
		noRandomOffset: true
	}),
	
	new TileType({
		name: "Wall 5",
		img: {x: 2, y: 354, w: 40, h: 56},
		sizeX: 2,
		sizeY: 2,
		blocking: true,
		noRandomOffset: true
	}),
	
	new TileType({
		name: "Wall 6",
		img: {x: 518, y: 54, w: 21, h: 63},
		sizeX: 1,
		sizeY: 3,
		blocking: true,
		noRandomOffset: true
	}),
	
	new TileType({
		name: "Wall 7",
		img: {x: 542, y: 54, w: 21, h: 63},
		sizeX: 1,
		sizeY: 3,
		blocking: true,
		noRandomOffset: true
	}),
	
	new TileType({
		name: "Wall 8",
		img: {x: 490, y: 121, w: 53, h: 23},
		sizeX: 3,
		sizeY: 1,
		blocking: true,
		noRandomOffset: true
	}),
	
	new TileType({
		name: "Wall 9",
		img: {x: 491, y: 147, w: 37, h: 45},
		sizeX: 2,
		sizeY: 2,
		blocking: true,
		noRandomOffset: true
	}),
	
	new TileType({
		name: "Invisible Pathing Blocker",
		img: {x: 875, y: 0, w: 16, h: 16},
		imgEditor: {x: 858, y: 0, w: 16, h: 16},
		sizeX: 1,
		sizeY: 1,
		blocking: true,
	}),
	
	new TileType({
		name: "Invisible Pathing Blocker 2x2",
		img: {x: 892, y: 0, w: 32, h: 32},
		imgEditor: {x: 858, y: 17, w: 32, h: 32},
		sizeX: 2,
		sizeY: 2,
		blocking: true,
	}),
	
	new TileType({
		name: "Flower 2",
		img: {x: 0, y: 0, w: 11, h: 12},
		sizeX: 1,
		sizeY: 1,
		blocking: false,
		ignoreGrid: true,
		isGround: true
	}),
	
	new TileType({
		name: "Flower 3",
		img: {x: 11, y: 0, w: 7, h: 6},
		sizeX: 1,
		sizeY: 1,
		blocking: false,
		ignoreGrid: true,
		isGround: true
	}),
	
	new TileType({
		name: "Flower 4",
		img: {x: 18, y: 0, w: 11, h: 12},
		sizeX: 1,
		sizeY: 1,
		blocking: false,
		ignoreGrid: true,
		isGround: true
	}),
	
	new TileType({
		name: "Flower 5",
		img: {x: 29, y: 0, w: 12, h: 11},
		sizeX: 1,
		sizeY: 1,
		blocking: false,
		ignoreGrid: true,
		isGround: true
	}),
	
	new TileType({
		name: "Stone 6",
		img: {x: 181, y: 16, w: 6, h: 6},
		sizeX: 1,
		sizeY: 1,
		blocking: false,
		ignoreGrid: true,
		isGround: true
	}),
	
	new TileType({
		name: "Stone 7",
		img: {x: 164, y: 35, w: 6, h: 6},
		sizeX: 1,
		sizeY: 1,
		blocking: false,
		ignoreGrid: true,
		isGround: true
	}),
	
	new TileType({
		name: "Stone 8",
		img: {x: 170, y: 35, w: 10, h: 6},
		sizeX: 1,
		sizeY: 1,
		blocking: false,
		ignoreGrid: true,
		isGround: true
	}),
	
	new TileType({
		name: "Stone 9",
		img: {x: 180, y: 35, w: 10, h: 6},
		sizeX: 1,
		sizeY: 1,
		blocking: false,
		ignoreGrid: true,
		isGround: true
	}),
	
	new TileType({
		name: "Grass d 5",
		img: {x: 41, y: 0, w: 21, h: 15},
		sizeX: 1,
		sizeY: 1,
		blocking: false,
		ignoreGrid: true,
		isGround: true
	}),
	
	new TileType({
		name: "Grass d 6",
		img: {x: 62, y: 0, w: 12, h: 10},
		sizeX: 1,
		sizeY: 1,
		blocking: false,
		ignoreGrid: true,
		isGround: true
	}),
	
	new TileType({
		name: "Grass d 7",
		img: {x: 74, y: 0, w: 6, h: 9},
		sizeX: 1,
		sizeY: 1,
		blocking: false,
		ignoreGrid: true,
		isGround: true
	}),
	
	new TileType({
		name: "Grass d 8",
		img: {x: 80, y: 0, w: 6, h: 9},
		sizeX: 1,
		sizeY: 1,
		blocking: false,
		ignoreGrid: true,
		isGround: true
	}),
	
	new TileType({
		name: "Grass d 9",
		img: {x: 86, y: 0, w: 6, h: 9},
		sizeX: 1,
		sizeY: 1,
		blocking: false,
		ignoreGrid: true,
		isGround: true
	}),
	
	new TileType({
		name: "Leaf 1",
		img: {x: 176, y: 16, w: 5, h: 7},
		sizeX: 1,
		sizeY: 1,
		blocking: false,
		ignoreGrid: true,
		isGround: true
	}),
	
	new TileType({
		name: "Leaf 2",
		img: {x: 188, y: 0, w: 4, h: 7},
		sizeX: 1,
		sizeY: 1,
		blocking: false,
		ignoreGrid: true,
		isGround: true
	}),
	
	new TileType({
		name: "Plant 1",
		img: {x: 176, y: 23, w: 13, h: 12},
		sizeX: 1,
		sizeY: 1,
		blocking: false,
		ignoreGrid: true,
		isGround: true
	}),
	
	new TileType({
		name: "Wood 1",
		img: {x: 88, y: 160, w: 26, h: 15},
		sizeX: 1,
		sizeY: 1,
		blocking: false,
		ignoreGrid: true,
		isGround: true
	}),
	
	
	// Grounds
	new TileType({
		name: "Grass 1",
		img: {x: 92, y: 0, w: 16, h: 16},
		sizeX: 1,
		sizeY: 1,
		blocking: false,
		isDefault: true,
		isGround: true
	}),
	
	new TileType({
		name: "Grass 2",
		img: {x: 108, y: 0, w: 16, h: 16},
		sizeX: 1,
		sizeY: 1,
		blocking: false,
		isDefault: true,
		isGround: true
	}),
	
	new TileType({
		name: "Grass 3",
		img: {x: 124, y: 0, w: 16, h: 16},
		sizeX: 1,
		sizeY: 1,
		blocking: false,
		isDefault: true,
		isGround: true
	}),
	
	new TileType({
		name: "Grass 4",
		img: {x: 140, y: 0, w: 16, h: 16},
		sizeX: 1,
		sizeY: 1,
		blocking: false,
		isDefault: true,
		isGround: true
	}),
	
	new TileType({
		name: "Grass 5",
		img: {x: 156, y: 0, w: 16, h: 16},
		sizeX: 1,
		sizeY: 1,
		blocking: false,
		isDefault: true,
		isGround: true
	}),
	
	new TileType({
		name: "Grass 21",
		img: {x: 295, y: 0, w: 17, h: 19},
		sizeX: 1,
		sizeY: 1,
		blocking: false,
		ignoreGrid: true,
		isGround: true
	}),
	
	new TileType({
		name: "Grass 22",
		img: {x: 252, y: 0, w: 34, h: 16},
		sizeX: 1,
		sizeY: 1,
		blocking: false,
		ignoreGrid: true,
		isGround: true
	}),
	
	new TileType({
		name: "Water P Big",
		img: {x: 622, y: 0, w: 58, h: 47},
		sizeX: 3,
		sizeY: 3,
		blocking: false,
		ignoreGrid: true,
		isGround: true
	}),
	
	new TileType({
		name: "Water P Small",
		img: {x: 568, y: 83, w: 18, h: 18},
		sizeX: 1,
		sizeY: 1,
		blocking: false,
		ignoreGrid: true,
		isGround: true
	}),
	
	new TileType({
		name: "Water P Big Dark",
		img: {x: 695, y: 51, w: 58, h: 47},
		sizeX: 3,
		sizeY: 3,
		blocking: false,
		ignoreGrid: true,
		isGround: true
	}),
	
	new TileType({
		name: "Water P Small Dark",
		img: {x: 568, y: 104, w: 18, h: 18},
		sizeX: 1,
		sizeY: 1,
		blocking: false,
		ignoreGrid: true,
		isGround: true
	}),
	
	new TileType({
		name: "Ground n 1",
		img: {x: 32, y: 16, w: 16, h: 16},
		sizeX: 1,
		sizeY: 1,
		blocking: false,
		isDefault: true,
		isGround: true
	}),
	
	new TileType({
		name: "Ground n 2",
		img: {x: 48, y: 16, w: 16, h: 16},
		sizeX: 1,
		sizeY: 1,
		blocking: false,
		isDefault: true,
		isGround: true
	}),
	
	new TileType({
		name: "Ground n 3",
		img: {x: 64, y: 16, w: 16, h: 16},
		sizeX: 1,
		sizeY: 1,
		blocking: false,
		isDefault: true,
		isGround: true
	}),
	
	new TileType({
		name: "Ground n 4",
		img: {x: 80, y: 16, w: 16, h: 16},
		sizeX: 1,
		sizeY: 1,
		blocking: false,
		isDefault: true,
		isGround: true
	}),
	
	new TileType({
		name: "Ground n 5",
		img: {x: 96, y: 16, w: 16, h: 16},
		sizeX: 1,
		sizeY: 1,
		blocking: false,
		isDefault: true,
		isGround: true
	}),
	
	new TileType({
		name: "Ground n 6",
		img: {x: 112, y: 16, w: 16, h: 16},
		sizeX: 1,
		sizeY: 1,
		blocking: false,
		isDefault: true,
		isGround: true
	}),
	
	new TileType({
		name: "Ground n 7",
		img: {x: 128, y: 16, w: 16, h: 16},
		sizeX: 1,
		sizeY: 1,
		blocking: false,
		isDefault: true,
		isGround: true
	}),
	
	new TileType({
		name: "Ground n 8",
		img: {x: 144, y: 16, w: 16, h: 16},
		sizeX: 1,
		sizeY: 1,
		blocking: false,
		isDefault: true,
		isGround: true
	}),
	
	new TileType({
		name: "Ground n 9",
		img: {x: 32, y: 16, w: 16, h: 16},
		sizeX: 1,
		sizeY: 1,
		blocking: false,
		isDefault: true,
		isGround: true
	}),
	
	
	new TileType({
		name: "Ground n 10",
		img: {x: 160, y: 16, w: 16, h: 16},
		sizeX: 1,
		sizeY: 1,
		blocking: false,
		isGround: true,
		ignoreGrid: true
	}),
	
	
	new TileType({
		name: "Ground e 1",
		img: {x: 32, y: 16, w: 16, h: 16},
		sizeX: 1,
		sizeY: 1,
		blocking: false,
		isDefault: true,
		isGround: true
	}),
	
	new TileType({
		name: "Ground e 2",
		img: {x: 48, y: 16, w: 16, h: 16},
		sizeX: 1,
		sizeY: 1,
		blocking: false,
		isDefault: true,
		isGround: true
	}),
	
	new TileType({
		name: "Ground e 3",
		img: {x: 64, y: 16, w: 16, h: 16},
		sizeX: 1,
		sizeY: 1,
		blocking: false,
		isDefault: true,
		isGround: true
	}),
	
	new TileType({
		name: "Snow 1",
		img: {x: 0, y: 245, w: 16, h: 16},
		sizeX: 1,
		sizeY: 1,
		blocking: false,
		isDefault: true,
		isGround: true
	}),
	
	new TileType({
		name: "Snow 2",
		img: {x: 16, y: 245, w: 16, h: 16},
		sizeX: 1,
		sizeY: 1,
		blocking: false,
		isDefault: true,
		isGround: true
	}),
	
	new TileType({
		name: "Snow 3",
		img: {x: 0, y: 261, w: 16, h: 16},
		sizeX: 1,
		sizeY: 1,
		blocking: false,
		isDefault: true,
		isGround: true
	}),
	
	new TileType({
		name: "Snow 4",
		img: {x: 16, y: 261, w: 16, h: 16},
		sizeX: 1,
		sizeY: 1,
		blocking: false,
		isDefault: true,
		isGround: true
	}),
	
	new TileType({
		name: "Egypt Ground 1",
		img: {x: 484, y: 477, w: 16, h: 16},
		sizeX: 1,
		sizeY: 1,
		blocking: false,
		isDefault: true,
		isGround: true
	}),
	
	new TileType({
		name: "Egypt Ground 2",
		img: {x: 500, y: 477, w: 16, h: 16},
		sizeX: 1,
		sizeY: 1,
		blocking: false,
		isDefault: true,
		isGround: true
	}),
	
	new TileType({
		name: "Egypt Ground 3",
		img: {x: 516, y: 477, w: 16, h: 16},
		sizeX: 1,
		sizeY: 1,
		blocking: false,
		isDefault: true,
		isGround: true
	}),
	
	new TileType({
		name: "Egypt Ground 4",
		img: {x: 532, y: 477, w: 16, h: 16},
		sizeX: 1,
		sizeY: 1,
		blocking: false,
		isDefault: true,
		isGround: true
	}),
	
	new TileType({
		name: "Egypt Ground 5",
		img: {x: 548, y: 477, w: 16, h: 16},
		sizeX: 1,
		sizeY: 1,
		blocking: false,
		isDefault: true,
		isGround: true
	}),
	
	new TileType({
		name: "Egypt Ground 6",
		img: {x: 484, y: 477, w: 16, h: 16},
		sizeX: 1,
		sizeY: 1,
		blocking: false,
		isDefault: true,
		isGround: true
	}),
	
	new TileType({
		name: "Grave Ground 1",
		img: {x: 484 + 380, y: 477, w: 16, h: 16},
		sizeX: 1,
		sizeY: 1,
		blocking: false,
		isDefault: true,
		isGround: true
	}),
	
	new TileType({
		name: "Grave Ground 2",
		img: {x: 500 + 380, y: 477 + 4, w: 16, h: 16},
		sizeX: 1,
		sizeY: 1,
		blocking: false,
		isDefault: true,
		isGround: true
	}),
	
	new TileType({
		name: "Grave Ground 3",
		img: {x: 516 + 380, y: 477 + 4, w: 16, h: 16},
		sizeX: 1,
		sizeY: 1,
		blocking: false,
		isDefault: true,
		isGround: true
	}),
	
	new TileType({
		name: "Grave Ground 4",
		img: {x: 532 + 380, y: 477, w: 16, h: 16},
		sizeX: 1,
		sizeY: 1,
		blocking: false,
		isDefault: true,
		isGround: true
	}),
	
	new TileType({
		name: "Grave Ground 5",
		img: {x: 548 + 380, y: 477 + 4, w: 16, h: 16},
		sizeX: 1,
		sizeY: 1,
		blocking: false,
		isDefault: true,
		isGround: true
	}),
	
	new TileType({
		name: "Grave Ground 6",
		img: {x: 484 + 380, y: 477, w: 16, h: 16},
		sizeX: 1,
		sizeY: 1,
		blocking: false,
		isDefault: true,
		isGround: true
	}),
	
	new TileType({
		name: "Dirt 1",
		img: {x: 235, y: 166, w: 16, h: 16},
		sizeX: 1,
		sizeY: 1,
		blocking: false,
		isGround: true,
		ignoreGrid: true,
		isTexture: true
	}),
	
	new TileType({
		name: "Dirt 2",
		img: {x: 241, y: 184, w: 10, h: 9},
		sizeX: 1,
		sizeY: 1,
		blocking: false,
		isGround: true,
		ignoreGrid: true,
		isTexture: true
	}),
	
	new TileType({
		name: "Dirt 3",
		img: {x: 240, y: 195, w: 11, h: 10},
		sizeX: 1,
		sizeY: 1,
		blocking: false,
		isGround: true,
		ignoreGrid: true,
		isTexture: true
	}),
	
	new TileType({
		name: "Dirt 4",
		img: {x: 236, y: 206, w: 15, h: 15},
		sizeX: 1,
		sizeY: 1,
		blocking: false,
		isGround: true,
		ignoreGrid: true,
		isTexture: true
	}),
	
	new TileType({
		name: "Dirt 5",
		img: {x: 235, y: 223, w: 16, h: 16},
		sizeX: 1,
		sizeY: 1,
		blocking: false,
		isGround: true,	
		ignoreGrid: true,
		isTexture: true
	}),
	
	new TileType({
		name: "Dirt 6",
		img: {x: 339, y: 0, w: 14, h: 16},
		sizeX: 1,
		sizeY: 1,
		blocking: false,
		isGround: true,	
		ignoreGrid: true,
		isTexture: true
	}),
	
	new TileType({
		name: "Dirt 7",
		img: {x: 355, y: 0, w: 13, h: 17},
		sizeX: 1,
		sizeY: 1,
		blocking: false,
		isGround: true,	
		ignoreGrid: true,
		isTexture: true
	}),
	
	new TileType({
		name: "Dirt 8",
		img: {x: 369, y: 0, w: 18, h: 14},
		sizeX: 1,
		sizeY: 1,
		blocking: false,
		isGround: true,	
		ignoreGrid: true,
		isTexture: true
	}),
	
	new TileType({
		name: "Dirt 9",
		img: {x: 387, y: 0, w: 19, h: 11},
		sizeX: 1,
		sizeY: 1,
		blocking: false,
		isGround: true,	
		ignoreGrid: true,
		isTexture: true
	}),
	
	new TileType({
		name: "Big Dirt 1",
		img: {x: 412, y: 1, w: 54, h: 54},
		sizeX: 3,
		sizeY: 3,
		blocking: false,
		isGround: true,	
		ignoreGrid: true,
		isTexture: true
	}),
	
	new TileType({
		name: "Big Dirt 2",
		img: {x: 467, y: 0, w: 55, h: 54},
		sizeX: 3,
		sizeY: 3,
		blocking: false,
		isGround: true,	
		ignoreGrid: true,
		isTexture: true
	}),
	
	new TileType({
		name: "Big Dirt 3",
		img: {x: 374, y: 56, w: 54, h: 56},
		sizeX: 3,
		sizeY: 3,
		blocking: false,
		isGround: true,	
		ignoreGrid: true,
		isTexture: true
	}),
	
	new TileType({
		name: "Big Dirt 4",
		img: {x: 431, y: 57, w: 54, h: 55},
		sizeX: 3,
		sizeY: 3,
		blocking: false,
		isGround: true,	
		ignoreGrid: true,
		isTexture: true
	}),
	
	new TileType({
		name: "Big Dirt 5",
		img: {x: 423, y: 114, w: 64, h: 63},
		sizeX: 3,
		sizeY: 3,
		blocking: false,
		isGround: true,	
		ignoreGrid: true,
		isTexture: true
	}),
	
	new TileType({
		name: "Big Dirt 6",
		img: {x: 422, y: 178, w: 64, h: 62},
		sizeX: 3,
		sizeY: 3,
		blocking: false,
		isGround: true,	
		ignoreGrid: true,
		isTexture: true
	}),
	
	new TileType({
		name: "Snow Ground 1",
		img: {x: 760, y: 0, w: 71, h: 63},
		sizeX: 4,
		sizeY: 4,
		blocking: false,
		isGround: true,	
		ignoreGrid: true,
		isTexture: true
	}),
	
	new TileType({
		name: "Snow Ground 2",
		img: {x: 835, y: 0, w: 20, h: 16},
		sizeX: 1,
		sizeY: 1,
		blocking: false,
		isGround: true,	
		ignoreGrid: true,
		isTexture: true
	}),
	
	new TileType({
		name: "Stone Tile 1",
		img: {x: 683, y: 0, w: 14, h: 14},
		sizeX: 1,
		sizeY: 1,
		blocking: false,
		isGround: true,	
		ignoreGrid: true,
		isTexture: true
	}),
	
	new TileType({
		name: "Stone Tile 2",
		img: {x: 697, y: 0, w: 14, h: 14},
		sizeX: 1,
		sizeY: 1,
		blocking: false,
		isGround: true,	
		ignoreGrid: true,
		isTexture: true
	}),
	
	new TileType({
		name: "Stone Tile 3",
		img: {x: 683, y: 14, w: 30, h: 30},
		sizeX: 2,
		sizeY: 2,
		blocking: false,
		isGround: true,	
		ignoreGrid: true,
		isTexture: true
	}),
	
	new TileType({
		name: "Stone Tile 4",
		img: {x: 713, y: 0, w: 46, h: 46},
		sizeX: 3,
		sizeY: 3,
		blocking: false,
		isGround: true,	
		ignoreGrid: true,
		isTexture: true
	}),
	
	new TileType({
		name: "Stone Tile 5",
		img: {x: 596, y: 50, w: 94, h: 94},
		sizeX: 6,
		sizeY: 6,
		blocking: false,
		isGround: true,	
		ignoreGrid: true,
		isTexture: true
	})
	
];




// Cliffs
var cliffs = [
	
	new TileType({
		name: "North",
		img: {x: 2, y: 418, w: 22, h: 40},
		sizeX: 1,
		sizeY: 1,
		blocking: true,
		isCliff: true,
		minimap_color: "rgb(72, 60, 56)"
	}),
	
	new TileType({
		name: "West",
		img: {x: 24, y: 418, w: 20, h: 40},
		sizeX: 1,
		sizeY: 1,
		blocking: true,
		isCliff: true,
		minimap_color: "rgb(72, 60, 56)"
	}),
	
	new TileType({
		name: "East",
		img: {x: 44, y: 418, w: 16, h: 40},
		sizeX: 1,
		sizeY: 1,
		blocking: true,
		isCliff: true,
		minimap_color: "rgb(72, 60, 56)"
	}),
	
	new TileType({
		name: "South",
		img: {x: 62, y: 418, w: 20, h: 40},
		sizeX: 1,
		sizeY: 1,
		blocking: true,
		isCliff: true,
		minimap_color: "rgb(88, 80, 68)"
	}),
	
	new TileType({
		name: "SW",
		img: {x: 85, y: 416, w: 22, h: 42},
		sizeX: 1,
		sizeY: 1,
		blocking: true,
		isCliff: true,
		minimap_color: "rgb(72, 60, 56)"
	}),
	
	new TileType({
		name: "SE",
		img: {x: 110, y: 416, w: 22, h: 42},
		sizeX: 1,
		sizeY: 1,
		blocking: true,
		isCliff: true,
		minimap_color: "rgb(72, 60, 56)"
	}),
	
	new TileType({
		name: "NW",
		img: {x: 135, y: 418, w: 20, h: 40},
		sizeX: 1,
		sizeY: 1,
		blocking: true,
		isCliff: true,
		minimap_color: "rgb(72, 60, 56)"
	}),
	
	new TileType({
		name: "NE",
		img: {x: 157, y: 418, w: 20, h: 40},
		sizeX: 1,
		sizeY: 1,
		blocking: true,
		isCliff: true,
		minimap_color: "rgb(72, 60, 56)"
	}),
	
	new TileType({
		name: "SW2",
		img: {x: 2, y: 460, w: 20, h: 40},
		sizeX: 1,
		sizeY: 1,
		blocking: true,
		isCliff: true,
		minimap_color: "rgb(72, 60, 56)"
	}),
	
	new TileType({
		name: "SE2",
		img: {x: 25, y: 460, w: 20, h: 40},
		sizeX: 1,
		sizeY: 1,
		blocking: true,
		isCliff: true,
		minimap_color: "rgb(72, 60, 56)"
	}),
	
	new TileType({
		name: "NW2",
		img: {x: 53, y: 460, w: 20, h: 40},
		sizeX: 1,
		sizeY: 1,
		blocking: true,
		isCliff: true,
		minimap_color: "rgb(72, 60, 56)"
	}),
	
	new TileType({
		name: "NE2",
		img: {x: 75, y: 460, w: 20, h: 40},
		sizeX: 1,
		sizeY: 1,
		blocking: true,
		isCliff: true,
		minimap_color: "rgb(72, 60, 56)"
	}),
	
	new TileType({
		name: "Universal",
		img: {x: 372, y: 168, w: 22, h: 46},
		sizeX: 1,
		sizeY: 1,
		blocking: true,
		isCliff: true,
		minimap_color: "rgb(72, 60, 56)"
	})
	
];

// Cliffs Winter
var cliffs_winter = [
	
	new TileType({
		name: "North",
		img: {x: 2, y: 418, w: 22, h: 40},
		sizeX: 1,
		sizeY: 1,
		blocking: true,
		isCliff: true
	}),
	
	new TileType({
		name: "West",
		img: {x: 24, y: 418, w: 20, h: 40},
		sizeX: 1,
		sizeY: 1,
		blocking: true,
		isCliff: true
	}),
	
	new TileType({
		name: "East",
		img: {x: 44, y: 418, w: 16, h: 40},
		sizeX: 1,
		sizeY: 1,
		blocking: true,
		isCliff: true
	}),
	
	new TileType({
		name: "South",
		img: {x: 98, y: 460, w: 20, h: 40},
		sizeX: 1,
		sizeY: 1,
		blocking: true,
		isCliff: true
	}),
	
	new TileType({
		name: "SW",
		img: {x: 85, y: 416, w: 22, h: 42},
		sizeX: 1,
		sizeY: 1,
		blocking: true,
		isCliff: true
	}),
	
	new TileType({
		name: "SE",
		img: {x: 110, y: 416, w: 22, h: 42},
		sizeX: 1,
		sizeY: 1,
		blocking: true,
		isCliff: true
	}),
	
	new TileType({
		name: "NW",
		img: {x: 162, y: 456, w: 16, h: 40},
		sizeX: 1,
		sizeY: 1,
		blocking: true,
		isCliff: true
	}),
	
	new TileType({
		name: "NE",
		img: {x: 180, y: 456, w: 16, h: 40},
		sizeX: 1,
		sizeY: 1,
		blocking: true,
		isCliff: true
	}),
	
	new TileType({
		name: "SW2",
		img: {x: 2, y: 460, w: 20, h: 40},
		sizeX: 1,
		sizeY: 1,
		blocking: true,
		isCliff: true
	}),
	
	new TileType({
		name: "SE2",
		img: {x: 25, y: 460, w: 20, h: 40},
		sizeX: 1,
		sizeY: 1,
		blocking: true,
		isCliff: true
	}),
	
	new TileType({
		name: "NW2",
		img: {x: 120, y: 460, w: 20, h: 40},
		sizeX: 1,
		sizeY: 1,
		blocking: true,
		isCliff: true
	}),
	
	new TileType({
		name: "NE2",
		img: {x: 142, y: 460, w: 20, h: 40},
		sizeX: 1,
		sizeY: 1,
		blocking: true,
		isCliff: true
	}),
	
	new TileType({
		name: "Universal",
		img: {x: 347, y: 168, w: 22, h: 46},
		sizeX: 1,
		sizeY: 1,
		blocking: true,
		isCliff: true
	})
	
];

var egypt_cliffs = [
	
	new TileType({
		name: "North",
		img: {x: 390, y: 418, w: 22, h: 40},
		sizeX: 1,
		sizeY: 1,
		blocking: true,
		isCliff: true,
		minimap_color: "rgb(72, 60, 56)"
	}),
	
	new TileType({
		name: "West",
		img: {x: 411, y: 413, w: 22, h: 47},
		sizeX: 1,
		sizeY: 1,
		blocking: true,
		isCliff: true,
		minimap_color: "rgb(72, 60, 56)"
	}),
	
	new TileType({
		name: "East",
		img: {x: 433, y: 413, w: 16, h: 47},
		sizeX: 1,
		sizeY: 1,
		blocking: true,
		isCliff: true,
		minimap_color: "rgb(72, 60, 56)"
	}),
	
	new TileType({
		name: "South",
		img: {x: 450, y: 418, w: 20, h: 40},
		sizeX: 1,
		sizeY: 1,
		blocking: true,
		isCliff: true,
		minimap_color: "rgb(88, 80, 68)"
	}),
	
	new TileType({
		name: "SW",
		img: {x: 473, y: 416, w: 22, h: 42},
		sizeX: 1,
		sizeY: 1,
		blocking: true,
		isCliff: true,
		minimap_color: "rgb(72, 60, 56)"
	}),
	
	new TileType({
		name: "SE",
		img: {x: 498, y: 416, w: 22, h: 42},
		sizeX: 1,
		sizeY: 1,
		blocking: true,
		isCliff: true,
		minimap_color: "rgb(72, 60, 56)"
	}),
	
	new TileType({
		name: "NW",
		img: {x: 523, y: 418, w: 20, h: 40},
		sizeX: 1,
		sizeY: 1,
		blocking: true,
		isCliff: true,
		minimap_color: "rgb(72, 60, 56)"
	}),
	
	new TileType({
		name: "NE",
		img: {x: 544, y: 418, w: 22, h: 40},
		sizeX: 1,
		sizeY: 1,
		blocking: true,
		isCliff: true,
		minimap_color: "rgb(72, 60, 56)"
	}),
	
	new TileType({
		name: "SW2",
		img: {x: 390, y: 460, w: 20, h: 40},
		sizeX: 1,
		sizeY: 1,
		blocking: true,
		isCliff: true,
		minimap_color: "rgb(72, 60, 56)"
	}),
	
	new TileType({
		name: "SE2",
		img: {x: 413, y: 460, w: 20, h: 40},
		sizeX: 1,
		sizeY: 1,
		blocking: true,
		isCliff: true,
		minimap_color: "rgb(72, 60, 56)"
	}),
	
	new TileType({
		name: "NW2",
		img: {x: 439, y: 460, w: 20, h: 40},
		sizeX: 1,
		sizeY: 1,
		blocking: true,
		isCliff: true,
		minimap_color: "rgb(72, 60, 56)"
	}),
	
	new TileType({
		name: "NE2",
		img: {x: 463, y: 460, w: 20, h: 40},
		sizeX: 1,
		sizeY: 1,
		blocking: true,
		isCliff: true,
		minimap_color: "rgb(72, 60, 56)"
	}),
	
	new TileType({
		name: "Universal",
		img: {x: 397, y: 168, w: 22, h: 46},
		sizeX: 1,
		sizeY: 1,
		blocking: true,
		isCliff: true,
		minimap_color: "rgb(72, 60, 56)"
	})
	
];

var grave_cliffs = [
	
	new TileType({
		name: "North",
		img: {x: 390 + 380, y: 418, w: 22, h: 40},
		sizeX: 1,
		sizeY: 1,
		blocking: true,
		isCliff: true,
		minimap_color: "rgb(72, 60, 56)"
	}),
	
	new TileType({
		name: "West",
		img: {x: 409 + 380, y: 413, w: 24, h: 47},
		sizeX: 1,
		sizeY: 1,
		blocking: true,
		isCliff: true,
		minimap_color: "rgb(72, 60, 56)"
	}),
	
	new TileType({
		name: "East",
		img: {x: 434 + 380, y: 413, w: 18, h: 47},
		sizeX: 1,
		sizeY: 1,
		blocking: true,
		isCliff: true,
		minimap_color: "rgb(72, 60, 56)"
	}),
	
	new TileType({
		name: "South",
		img: {x: 453 + 380, y: 418, w: 20, h: 40},
		sizeX: 1,
		sizeY: 1,
		blocking: true,
		isCliff: true,
		minimap_color: "rgb(88, 80, 68)"
	}),
	
	new TileType({
		name: "SW",
		img: {x: 473 + 380, y: 416, w: 22, h: 42},
		sizeX: 1,
		sizeY: 1,
		blocking: true,
		isCliff: true,
		minimap_color: "rgb(72, 60, 56)"
	}),
	
	new TileType({
		name: "SE",
		img: {x: 496 + 380, y: 416, w: 25, h: 42},
		sizeX: 1,
		sizeY: 1,
		blocking: true,
		isCliff: true,
		minimap_color: "rgb(72, 60, 56)"
	}),
	
	new TileType({
		name: "NW",
		img: {x: 523 + 380, y: 418, w: 20, h: 40},
		sizeX: 1,
		sizeY: 1,
		blocking: true,
		isCliff: true,
		minimap_color: "rgb(72, 60, 56)"
	}),
	
	new TileType({
		name: "NE",
		img: {x: 543 + 380, y: 418, w: 24, h: 40},
		sizeX: 1,
		sizeY: 1,
		blocking: true,
		isCliff: true,
		minimap_color: "rgb(72, 60, 56)"
	}),
	
	new TileType({
		name: "SW2",
		img: {x: 390 + 380, y: 460, w: 20, h: 40},
		sizeX: 1,
		sizeY: 1,
		blocking: true,
		isCliff: true,
		minimap_color: "rgb(72, 60, 56)"
	}),
	
	new TileType({
		name: "SE2",
		img: {x: 413 + 380, y: 460, w: 20, h: 40},
		sizeX: 1,
		sizeY: 1,
		blocking: true,
		isCliff: true,
		minimap_color: "rgb(72, 60, 56)"
	}),
	
	new TileType({
		name: "NW2",
		img: {x: 439 + 380, y: 460, w: 20, h: 40},
		sizeX: 1,
		sizeY: 1,
		blocking: true,
		isCliff: true,
		minimap_color: "rgb(72, 60, 56)"
	}),
	
	new TileType({
		name: "NE2",
		img: {x: 463 + 380, y: 460, w: 20, h: 40},
		sizeX: 1,
		sizeY: 1,
		blocking: true,
		isCliff: true,
		minimap_color: "rgb(72, 60, 56)"
	}),
	
	new TileType({
		name: "Universal",
		img: {x: 397 + 380, y: 168, w: 22, h: 46},
		sizeX: 1,
		sizeY: 1,
		blocking: true,
		isCliff: true,
		minimap_color: "rgb(72, 60, 56)"
	})
	
];

var ramp_tiles = [
	
	new TileType({
		name: "South West",
		img: {x: 194, y: 422, w: 22, h: 76},
		sizeX: 1,
		sizeY: 3,
		blocking: true,
		isCliff: true,
		isRamp: true
	}),
	
	new TileType({
		name: "South East",
		img: {x: 238, y: 422, w: 24, h: 76},
		sizeX: 1,
		sizeY: 3,
		blocking: true,
		isCliff: true,
		isRamp: true
	}),
	
	new TileType({
		name: "South Floor",
		img: {x: 217, y: 420, w: 16, h: 78},
		sizeX: 1,
		sizeY: 3,
		blocking: false,
		ignoreGrid: true,
		isGround: true,
		isCliff: true,
		isRamp: true
	}),
	
	new TileType({
		name: "South Floor 2",
		img: {x: 220, y: 341, w: 16, h: 78},
		sizeX: 1,
		sizeY: 3,
		blocking: false,
		ignoreGrid: true,
		isGround: true,
		isCliff: true,
		isRamp: true
	}),
	
	new TileType({
		name: "South Floor 3",
		img: {x: 237, y: 341, w: 16, h: 78},
		sizeX: 1,
		sizeY: 3,
		blocking: false,
		ignoreGrid: true,
		isGround: true,
		isCliff: true,
		isRamp: true
	}),
	
	new TileType({
		name: "West Top",
		img: {x: 265, y: 445, w: 54, h: 47},
		sizeX: 3,
		sizeY: 1,
		blocking: true,
		isCliff: true,
		isRamp: true
	}),
	
	new TileType({
		name: "West Bottom",
		img: {x: 324, y: 448, w: 52, h: 46},
		sizeX: 3,
		sizeY: 1,
		blocking: true,
		isCliff: true,
		isRamp: true
	}),
	
	new TileType({
		name: "West Floor",
		img: {x: 267, y: 393, w: 55, h: 52},
		sizeX: 3,
		sizeY: 1,
		blocking: false,
		ignoreGrid: true,
		isGround: true,
		isCliff: true,
		isRamp: true
	}),
	
	new TileType({
		name: "West Floor 2",
		img: {x: 323, y: 393, w: 55, h: 52},
		sizeX: 3,
		sizeY: 1,
		blocking: false,
		ignoreGrid: true,
		isGround: true,
		isCliff: true,
		isRamp: true
	}),
	
	new TileType({
		name: "West Floor 3",
		img: {x: 267, y: 327, w: 55, h: 52},
		sizeX: 3,
		sizeY: 1,
		blocking: false,
		ignoreGrid: true,
		isGround: true,
		isCliff: true,
		isRamp: true
	}),
	
	new TileType({
		name: "East Top",
		img: {x: 342, y: 275, w: 54, h: 45},
		sizeX: 3,
		sizeY: 1,
		blocking: true,
		isCliff: true,
		isRamp: true
	}),
	
	new TileType({
		name: "East Bottom",
		img: {x: 285, y: 279, w: 52, h: 43},
		sizeX: 3,
		sizeY: 1,
		blocking: true,
		isCliff: true,
		isRamp: true
	}),
	
	new TileType({
		name: "East Floor",
		img: {x: 334, y: 327, w: 50, h: 53},
		sizeX: 3,
		sizeY: 1,
		blocking: false,
		ignoreGrid: true,
		isGround: true,
		isCliff: true,
		isRamp: true
	}),
	
	new TileType({
		name: "East Floor 2",
		img: {x: 284, y: 221, w: 50, h: 53},
		sizeX: 3,
		sizeY: 1,
		blocking: false,
		ignoreGrid: true,
		isGround: true,
		isCliff: true,
		isRamp: true
	}),
	
	new TileType({
		name: "East Floor 3",
		img: {x: 339, y: 221, w: 50, h: 53},
		sizeX: 3,
		sizeY: 1,
		blocking: false,
		ignoreGrid: true,
		isGround: true,
		isCliff: true,
		isRamp: true
	}),
	
	new TileType({
		name: "North Left",
		img: {x: 72, y: 359, w: 23, h: 51},
		sizeX: 1,
		sizeY: 3,
		blocking: true,
		isCliff: true,
		isRamp: true
	}),
	
	new TileType({
		name: "North Right",
		img: {x: 104, y: 359, w: 23, h: 51},
		sizeX: 1,
		sizeY: 3,
		blocking: true,
		isCliff: true,
		isRamp: true
	}),
	
	new TileType({
		name: "North Floor",
		img: {x: 127, y: 360, w: 16, h: 23},
		sizeX: 1,
		sizeY: 3,
		blocking: false,
		ignoreGrid: true,
		isGround: true,
		isCliff: true,
		isRamp: true
	}),
	
	new TileType({
		name: "North Floor 2",
		img: {x: 127, y: 386, w: 16, h: 23},
		sizeX: 1,
		sizeY: 3,
		blocking: false,
		ignoreGrid: true,
		isGround: true,
		isCliff: true,
		isRamp: true
	}),
	
	new TileType({
		name: "North Floor 3",
		img: {x: 144, y: 386, w: 16, h: 23},
		sizeX: 1,
		sizeY: 3,
		blocking: false,
		ignoreGrid: true,
		isGround: true,
		isCliff: true,
		isRamp: true
	})
	
];

var ramp_tiles_egypt = [
	
	new TileType({
		name: "South West",
		img: {x: 582, y: 422, w: 22, h: 76},
		sizeX: 1,
		sizeY: 3,
		blocking: true,
		isCliff: true,
		isRamp: true
	}),
	
	new TileType({
		name: "South East",
		img: {x: 626, y: 422, w: 24, h: 76},
		sizeX: 1,
		sizeY: 3,
		blocking: true,
		isCliff: true,
		isRamp: true
	}),
	
	new TileType({
		name: "South Floor",
		img: {x: 603, y: 420, w: 16, h: 78},
		sizeX: 1,
		sizeY: 3,
		blocking: false,
		ignoreGrid: true,
		isGround: true,
		isCliff: true,
		isRamp: true
	}),
	
	new TileType({
		name: "South Floor 2",
		img: {x: 608, y: 341, w: 16, h: 78},
		sizeX: 1,
		sizeY: 3,
		blocking: false,
		ignoreGrid: true,
		isGround: true,
		isCliff: true,
		isRamp: true
	}),
	
	new TileType({
		name: "South Floor 3",
		img: {x: 625, y: 341, w: 16, h: 78},
		sizeX: 1,
		sizeY: 3,
		blocking: false,
		ignoreGrid: true,
		isGround: true,
		isCliff: true,
		isRamp: true
	}),
	
	new TileType({
		name: "West Top",
		img: {x: 653, y: 445, w: 54, h: 47},
		sizeX: 3,
		sizeY: 1,
		blocking: true,
		isCliff: true,
		isRamp: true
	}),
	
	new TileType({
		name: "West Bottom",
		img: {x: 712, y: 448, w: 52, h: 47},
		sizeX: 3,
		sizeY: 1,
		blocking: true,
		isCliff: true,
		isRamp: true
	}),
	
	new TileType({
		name: "West Floor",
		img: {x: 655, y: 393, w: 55, h: 52},
		sizeX: 3,
		sizeY: 1,
		blocking: false,
		ignoreGrid: true,
		isGround: true,
		isCliff: true,
		isRamp: true
	}),
	
	new TileType({
		name: "West Floor 2",
		img: {x: 711, y: 393, w: 55, h: 52},
		sizeX: 3,
		sizeY: 1,
		blocking: false,
		ignoreGrid: true,
		isGround: true,
		isCliff: true,
		isRamp: true
	}),
	
	new TileType({
		name: "West Floor 3",
		img: {x: 655, y: 327, w: 55, h: 52},
		sizeX: 3,
		sizeY: 1,
		blocking: false,
		ignoreGrid: true,
		isGround: true,
		isCliff: true,
		isRamp: true
	}),
	
	new TileType({
		name: "East Top",
		img: {x: 730, y: 275, w: 54, h: 45},
		sizeX: 3,
		sizeY: 1,
		blocking: true,
		isCliff: true,
		isRamp: true
	}),
	
	new TileType({
		name: "East Bottom",
		img: {x: 673, y: 279, w: 52, h: 43},
		sizeX: 3,
		sizeY: 1,
		blocking: true,
		isCliff: true,
		isRamp: true
	}),
	
	new TileType({
		name: "East Floor",
		img: {x: 722, y: 327, w: 50, h: 53},
		sizeX: 3,
		sizeY: 1,
		blocking: false,
		ignoreGrid: true,
		isGround: true,
		isCliff: true,
		isRamp: true
	}),
	
	new TileType({
		name: "East Floor 2",
		img: {x: 672, y: 221, w: 50, h: 53},
		sizeX: 3,
		sizeY: 1,
		blocking: false,
		ignoreGrid: true,
		isGround: true,
		isCliff: true,
		isRamp: true
	}),
	
	new TileType({
		name: "East Floor 3",
		img: {x: 727, y: 221, w: 50, h: 53},
		sizeX: 3,
		sizeY: 1,
		blocking: false,
		ignoreGrid: true,
		isGround: true,
		isCliff: true,
		isRamp: true
	}),
	
	new TileType({
		name: "North Left",
		img: {x: 460, y: 359, w: 23, h: 51},
		sizeX: 1,
		sizeY: 3,
		blocking: true,
		isCliff: true,
		isRamp: true
	}),
	
	new TileType({
		name: "North Right",
		img: {x: 492, y: 359, w: 21, h: 51},
		sizeX: 1,
		sizeY: 3,
		blocking: true,
		isCliff: true,
		isRamp: true
	}),
	
	new TileType({
		name: "North Floor",
		img: {x: 513, y: 360, w: 16, h: 23},
		sizeX: 1,
		sizeY: 3,
		blocking: false,
		ignoreGrid: true,
		isGround: true,
		isCliff: true,
		isRamp: true
	}),
	
	new TileType({
		name: "North Floor 2",
		img: {x: 513, y: 386, w: 16, h: 23},
		sizeX: 1,
		sizeY: 3,
		blocking: false,
		ignoreGrid: true,
		isGround: true,
		isCliff: true,
		isRamp: true
	}),
	
	new TileType({
		name: "North Floor 3",
		img: {x: 530, y: 386, w: 16, h: 23},
		sizeX: 1,
		sizeY: 3,
		blocking: false,
		ignoreGrid: true,
		isGround: true,
		isCliff: true,
		isRamp: true
	})
	
];

var ramp_tiles_grave = [
	
	new TileType({
		name: "South West",
		img: {x: 582 + 380, y: 422, w: 22, h: 76},
		sizeX: 1,
		sizeY: 3,
		blocking: true,
		isCliff: true,
		isRamp: true
	}),
	
	new TileType({
		name: "South East",
		img: {x: 626 + 380, y: 422, w: 24, h: 76},
		sizeX: 1,
		sizeY: 3,
		blocking: true,
		isCliff: true,
		isRamp: true
	}),
	
	new TileType({
		name: "South Floor",
		img: {x: 603 + 380, y: 420, w: 16, h: 78},
		sizeX: 1,
		sizeY: 3,
		blocking: false,
		ignoreGrid: true,
		isGround: true,
		isCliff: true,
		isRamp: true
	}),
	
	new TileType({
		name: "South Floor 2",
		img: {x: 608 + 380, y: 341, w: 16, h: 78},
		sizeX: 1,
		sizeY: 3,
		blocking: false,
		ignoreGrid: true,
		isGround: true,
		isCliff: true,
		isRamp: true
	}),
	
	new TileType({
		name: "South Floor 3",
		img: {x: 625 + 380, y: 341, w: 16, h: 78},
		sizeX: 1,
		sizeY: 3,
		blocking: false,
		ignoreGrid: true,
		isGround: true,
		isCliff: true,
		isRamp: true
	}),
	
	new TileType({
		name: "West Top",
		img: {x: 653 + 380, y: 445, w: 54, h: 47},
		sizeX: 3,
		sizeY: 1,
		blocking: true,
		isCliff: true,
		isRamp: true
	}),
	
	new TileType({
		name: "West Bottom",
		img: {x: 712 + 380, y: 448, w: 52, h: 47},
		sizeX: 3,
		sizeY: 1,
		blocking: true,
		isCliff: true,
		isRamp: true
	}),
	
	new TileType({
		name: "West Floor",
		img: {x: 655 + 380, y: 393, w: 55, h: 52},
		sizeX: 3,
		sizeY: 1,
		blocking: false,
		ignoreGrid: true,
		isGround: true,
		isCliff: true,
		isRamp: true
	}),
	
	new TileType({
		name: "West Floor 2",
		img: {x: 711 + 380, y: 393, w: 55, h: 52},
		sizeX: 3,
		sizeY: 1,
		blocking: false,
		ignoreGrid: true,
		isGround: true,
		isCliff: true,
		isRamp: true
	}),
	
	new TileType({
		name: "West Floor 3",
		img: {x: 655 + 380, y: 327, w: 55, h: 52},
		sizeX: 3,
		sizeY: 1,
		blocking: false,
		ignoreGrid: true,
		isGround: true,
		isCliff: true,
		isRamp: true
	}),
	
	new TileType({
		name: "East Top",
		img: {x: 730 + 380, y: 275, w: 54, h: 45},
		sizeX: 3,
		sizeY: 1,
		blocking: true,
		isCliff: true,
		isRamp: true
	}),
	
	new TileType({
		name: "East Bottom",
		img: {x: 673 + 380, y: 279, w: 52, h: 43},
		sizeX: 3,
		sizeY: 1,
		blocking: true,
		isCliff: true,
		isRamp: true
	}),
	
	new TileType({
		name: "East Floor",
		img: {x: 722 + 380, y: 327, w: 50, h: 53},
		sizeX: 3,
		sizeY: 1,
		blocking: false,
		ignoreGrid: true,
		isGround: true,
		isCliff: true,
		isRamp: true
	}),
	
	new TileType({
		name: "East Floor 2",
		img: {x: 672 + 380, y: 221, w: 50, h: 53},
		sizeX: 3,
		sizeY: 1,
		blocking: false,
		ignoreGrid: true,
		isGround: true,
		isCliff: true,
		isRamp: true
	}),
	
	new TileType({
		name: "East Floor 3",
		img: {x: 727 + 380, y: 221, w: 50, h: 53},
		sizeX: 3,
		sizeY: 1,
		blocking: false,
		ignoreGrid: true,
		isGround: true,
		isCliff: true,
		isRamp: true
	}),
	
	new TileType({
		name: "North Left",
		img: {x: 460 + 380, y: 359, w: 23, h: 51},
		sizeX: 1,
		sizeY: 3,
		blocking: true,
		isCliff: true,
		isRamp: true
	}),
	
	new TileType({
		name: "North Right",
		img: {x: 492 + 380, y: 359, w: 21, h: 51},
		sizeX: 1,
		sizeY: 3,
		blocking: true,
		isCliff: true,
		isRamp: true
	}),
	
	new TileType({
		name: "North Floor",
		img: {x: 513 + 380, y: 360, w: 16, h: 23},
		sizeX: 1,
		sizeY: 3,
		blocking: false,
		ignoreGrid: true,
		isGround: true,
		isCliff: true,
		isRamp: true
	}),
	
	new TileType({
		name: "North Floor 2",
		img: {x: 513 + 380, y: 386, w: 16, h: 23},
		sizeX: 1,
		sizeY: 3,
		blocking: false,
		ignoreGrid: true,
		isGround: true,
		isCliff: true,
		isRamp: true
	}),
	
	new TileType({
		name: "North Floor 3",
		img: {x: 530 + 380, y: 386, w: 16, h: 23},
		sizeX: 1,
		sizeY: 3,
		blocking: false,
		ignoreGrid: true,
		isGround: true,
		isCliff: true,
		isRamp: true
	})
	
];






// Upgrades
var basicUpgrades = [
	
	{
		name: "Damage",
		id_string: "upgattack",
		cost: 140,
		buildTime: 90 * 20,
		maxLevel: 5,
		effectsTypes: [
			"worker",
			"soldier",
			"archer",
			"mage",
			"priest",
			"upgattack",
			"upgattack",
			"upgspeed",
			"upgspeed",
			"upgarmor",
			"upgarmor",
			"upgrange",
			"upgrange"
		],
		effectsFields: [
			"dmg",
			"dmg",
			"dmg",
			"dmg",
			"dmg",
			"buildTime",
			"cost",
			"buildTime",
			"cost",
			"buildTime",
			"cost",
			"buildTime",
			"cost"
		],
		effectsModifications: [
			1,
			1,
			1,
			1,
			1,
			20 * 20,
			60,
			20 * 20,
			60,
			20 * 20,
			60,
			20 * 20,
			60
		],
		effectsModsMultiplier: [
			1,
			1,
			1,
			1,
			1,
			1,
			1,
			1,
			1,
			1,
			1,
			1,
			1
		],
		description: "Increases the attack damage of your human units.",
		image: "attackUpg"
	},
	
	{
		name: "Armor",
		id_string: "upgarmor",
		cost: 140,
		buildTime: 90 * 20,
		maxLevel: 5,
		effectsTypes: [
			"worker",
			"soldier",
			"archer",
			"mage",
			"priest",
			"upgattack",
			"upgattack",
			"upgspeed",
			"upgspeed",
			"upgarmor",
			"upgarmor",
			"upgrange",
			"upgrange"
		],
		effectsFields: [
			"armor",
			"armor",
			"armor",
			"armor",
			"armor",
			"buildTime",
			"cost",
			"buildTime",
			"cost",
			"buildTime",
			"cost",
			"buildTime",
			"cost"
		],
		effectsModifications: [
			1,
			1,
			1,
			1,
			1,
			20 * 20,
			60,
			20 * 20,
			60,
			20 * 20,
			60,
			20 * 20,
			60
		],
		effectsModsMultiplier: [
			1,
			1,
			1,
			1,
			1,
			1,
			1,
			1,
			1,
			1,
			1,
			1,
			1
		],
		description: "Increases the armor of your human units.",
		image: "armorUpg"
	},
	
	{
		name: "Research Fireball",
		id_string: "upgfireball",
		cost: 100,
		buildTime: 72 * 20,
		maxLevel: 1,
		description: "Allows your Mages to cast Fireball.",
		isUpgrade: true,
		effectsTypes: [
			"upgslowfield",
			"upgskeleton"
		],
		effectsFields: [
			"cost",
			"cost"
		],
		effectsModifications: [
			200,
			200
		],
		effectsModsMultiplier: [
			1,
			1
		],
		image: "flamestrike"
	},
	
	{
		name: "Research Heal",
		id_string: "upgheal",
		cost: 100,
		buildTime: 72 * 20,
		maxLevel: 1,
		description: "Allows your Priests to cast Heal.",
		effectsTypes: [
			"upginvis",
			"upghealingward"
		],
		effectsFields: [
			"cost",
			"cost"
		],
		effectsModifications: [
			200,
			200
		],
		effectsModsMultiplier: [
			1,
			1
		],
		image: "heal"
	},
	
	{
		name: "Beast Attack",
		id_string: "upgbeastattack",
		cost: 140,
		buildTime: 90 * 20,
		maxLevel: 5,
		effectsTypes: [
			"dragon",
			"wolf",
			"werewolf",
			"upgbeastattack",
			"upgbeastattack",
			"upgbeastspeed",
			"upgbeastspeed",
			"upgbeastdefense",
			"upgbeastdefense",
			"upgbeastrange",
			"upgbeastrange"
		],
		effectsFields: [
			"dmg",
			"dmg",
			"dmg",
			"buildTime",
			"cost",
			"buildTime",
			"cost",
			"buildTime",
			"cost",
			"buildTime",
			"cost"
		],
		effectsModifications: [
			1,
			1,
			2,
			20 * 20,
			60,
			20 * 20,
			60,
			20 * 20,
			60,
			20 * 20,
			60
		],
		effectsModsMultiplier: [
			1,
			1,
			1,
			1,
			1,
			1,
			1,
			1,
			1,
			1,
			1
		],
		description: "Increases the attack damage of your beast units.",
		image: "dragonAttUpg"
	},
	
	{
		name: "Beast Defense",
		id_string: "upgbeastdefense",
		cost: 140,
		buildTime: 90 * 20,
		maxLevel: 5,
		effectsTypes: [
			"dragon",
			"wolf",
			"werewolf",
			"upgbeastattack",
			"upgbeastattack",
			"upgbeastspeed",
			"upgbeastspeed",
			"upgbeastdefense",
			"upgbeastdefense",
			"upgbeastrange",
			"upgbeastrange"
		],
		effectsFields: [
			"armor",
			"armor",
			"armor",
			"buildTime",
			"cost",
			"buildTime",
			"cost",
			"buildTime",
			"cost",
			"buildTime",
			"cost"
		],
		effectsModifications: [
			1,
			1,
			1,
			20 * 20,
			60,
			20 * 20,
			60,
			20 * 20,
			60,
			20 * 20,
			60
		],
		effectsModsMultiplier: [
			1,
			1,
			1,
			1,
			1,
			1,
			1,
			1,
			1,
			1,
			1
		],
		description: "Increases the armor of your beast units.",
		image: "dragonDefUpg"
	},
	
	{
		name: "Tower Upgrade",
		id_string: "upgtower",
		cost: 225,
		buildTime: 54 * 20,
		maxLevel: 1,
		effectsTypes: [
			"watchtower",
			"watchtower",
			"watchtower",
			"watchtower2",
			"watchtower2",
			"watchtower2"
		],
		effectsFields: [
			"armor",
			"dmg",
			"range",
			"armor",
			"dmg",
			"range"
		],
		effectsModifications: [
			2,
			2,
			1,
			2,
			2,
			1
		],
		effectsModsMultiplier: [
			1,
			1,
			1,
			1,
			1,
			1
		],
		description: "Increases the armor, damage and range of your towers.",
		image: "towerUpg"
	},
	
	{
		name: "Speed",
		id_string: "upgspeed",
		cost: 140,
		buildTime: 90 * 20,
		maxLevel: 5,
		effectsTypes: [
			"soldier",
			"archer",
			"mage",
			"priest",
			"upgattack",
			"upgattack",
			"upgspeed",
			"upgspeed",
			"upgarmor",
			"upgarmor",
			"upgrange",
			"upgrange"
		],
		effectsFields: [
			"movementSpeed",
			"movementSpeed",
			"movementSpeed",
			"movementSpeed",
			"buildTime",
			"cost",
			"buildTime",
			"cost",
			"buildTime",
			"cost",
			"buildTime",
			"cost"
		],
		effectsModifications: [
			0.25 / 20,
			0.25 / 20,
			0.2 / 20,
			0.2 / 20,
			20 * 20,
			60,
			20 * 20,
			60,
			20 * 20,
			60,
			20 * 20,
			60
		],
		effectsModsMultiplier: [
			1,
			1,
			1,
			1,
			1,
			1,
			1,
			1,
			1,
			1,
			1,
			1
		],
		description: "Increases the movement speed of your human units.",
		image: "speedUpg"
	},
	
	{
		name: "Beast Speed",
		id_string: "upgbeastspeed",
		cost: 140,
		buildTime: 90 * 20,
		maxLevel: 5,
		effectsTypes: [
			"dragon",
			"wolf",
			"werewolf",
			"upgbeastattack",
			"upgbeastattack",
			"upgbeastspeed",
			"upgbeastspeed",
			"upgbeastdefense",
			"upgbeastdefense",
			"upgbeastrange",
			"upgbeastrange"
		],
		effectsFields: [
			"movementSpeed",
			"movementSpeed",
			"movementSpeed",
			"buildTime",
			"cost",
			"buildTime",
			"cost",
			"buildTime",
			"cost",
			"buildTime",
			"cost"
		],
		effectsModifications: [
			0.3 / 20,
			0.3 / 20,
			0.25 / 20,
			20 * 20,
			60,
			20 * 20,
			60,
			20 * 20,
			60,
			20 * 20,
			60
		],
		effectsModsMultiplier: [
			1,
			1,
			1,
			1,
			1,
			1,
			1,
			1,
			1,
			1,
			1
		],
		description: "Increases the movement speed of your beast units.",
		image: "beastSpeedUpg"
	},
	
	{
		name: "Mech Attack",
		id_string: "upgmechattack",
		cost: 125,
		buildTime: 90 * 20,
		maxLevel: 5,
		effectsTypes: [
			"catapult",
			"ballista",
			"upgmechattack",
			"upgmechattack",
			"upgmechdefense",
			"upgmechdefense",
			"upgmechspeed",
			"upgmechspeed",
			"upgmechrange",
			"upgmechrange"
		],
		effectsFields: [
			"dmg",
			"dmg",
			"buildTime",
			"cost",
			"buildTime",
			"cost",
			"buildTime",
			"cost",
			"buildTime",
			"cost"
		],
		effectsModifications: [
			4,
			3,
			20 * 20,
			50,
			20 * 20,
			50,
			20 * 20,
			50,
			20 * 20,
			50
		],
		effectsModsMultiplier: [
			1,
			1,
			1,
			1,
			1,
			1,
			1,
			1,
			1,
			1
		],
		description: "Increases the attack dmg of your mechanical units.",
		image: "mechAttUpg"
	},
	
	{
		name: "Mech Defense",
		id_string: "upgmechdefense",
		cost: 125,
		buildTime: 90 * 20,
		maxLevel: 5,
		effectsTypes: [
			"catapult",
			"airship",
			"ballista",
			"upgmechattack",
			"upgmechattack",
			"upgmechdefense",
			"upgmechdefense",
			"upgmechspeed",
			"upgmechspeed",
			"upgmechrange",
			"upgmechrange"
		],
		effectsFields: [
			"armor",
			"armor",
			"armor",
			"buildTime",
			"cost",
			"buildTime",
			"cost",
			"buildTime",
			"cost",
			"buildTime",
			"cost"
		],
		effectsModifications: [
			1,
			1,
			1,
			20 * 20,
			50,
			20 * 20,
			50,
			20 * 20,
			50,
			20 * 20,
			50
		],
		effectsModsMultiplier: [
			1,
			1,
			1,
			1,
			1,
			1,
			1,
			1,
			1,
			1,
			1
		],
		description: "Increases the armor of your mechanical units.",
		image: "mechDefUpg"
	},
	
	{
		name: "Mech Speed",
		id_string: "upgmechspeed",
		cost: 125,
		buildTime: 90 * 20,
		maxLevel: 5,
		effectsTypes: [
			"catapult",
			"airship",
			"ballista",
			"upgmechattack",
			"upgmechattack",
			"upgmechdefense",
			"upgmechdefense",
			"upgmechspeed",
			"upgmechspeed",
			"upgmechrange",
			"upgmechrange"
		],
		effectsFields: [
			"movementSpeed",
			"movementSpeed",
			"movementSpeed",
			"buildTime",
			"cost",
			"buildTime",
			"cost",
			"buildTime",
			"cost",
			"buildTime",
			"cost"
		],
		effectsModifications: [
			0.15 / 20,
			0.25 / 20,
			0.15 / 20,
			20 * 20,
			50,
			20 * 20,
			50,
			20 * 20,
			50,
			20 * 20,
			50
		],
		effectsModsMultiplier: [
			1,
			1,
			1,
			1,
			1,
			1,
			1,
			1,
			1,
			1,
			1
		],
		description: "Increases the movement speed of your mechanical units.",
		image: "mechSpeedUpg"
	},
	
	{
		name: "Ballista Black Powder",
		id_string: "upgballistaexplosives",
		cost: 100,
		buildTime: 45 * 20,
		maxLevel: 1,
		effectsTypes: [
			"ballista"
		],
		effectsFields: [
			"aoeRadius"
		],
		effectsModifications: [
			1.4
		],
		effectsModifications: [
			1
		],
		description: "Adds splash damage to the ballista.",
		image: "flakUpg"
	},
	
	{
		name: "Research Shockwave",
		id_string: "upgshockwave",
		cost: 100,
		buildTime: 90 * 20,
		maxLevel: 1,
		description: "Allows your Mages to cast Shockwave.",
		effectsTypes: [
			"upgheal",
			"upgfireball"
		],
		effectsFields: [
			"cost",
			"cost"
		],
		effectsModifications: [
			200,
			200
		],
		effectsModsMultiplier: [
			1,
			1
		],
		image: "shockwave"
	},
	
	{
		name: "Mech Range",
		id_string: "upgmechrange",
		cost: 125,
		buildTime: 90 * 20,
		maxLevel: 5,
		effectsTypes: [
			"catapult",
			"ballista",
			"upgmechattack",
			"upgmechattack",
			"upgmechdefense",
			"upgmechdefense",
			"upgmechspeed",
			"upgmechspeed",
			"upgmechrange",
			"upgmechrange"
		],
		effectsFields: [
			"range",
			"range",
			"buildTime",
			"cost",
			"buildTime",
			"cost",
			"buildTime",
			"cost",
			"buildTime",
			"cost"
		],
		effectsModifications: [
			1,
			1,
			20 * 20,
			50,
			20 * 20,
			50,
			20 * 20,
			50,
			20 * 20,
			50
		],
		effectsModsMultiplier: [
			1,
			1,
			1,
			1,
			1,
			1,
			1,
			1,
			1,
			1
		],
		description: "Increases the range of your ranged mechanical units. Has no influence on melee units.",
		image: "mechRangeUpg"
	},
	
	{
		name: "Range",
		id_string: "upgrange",
		cost: 140,
		buildTime: 90 * 20,
		maxLevel: 5,
		effectsTypes: [
			"archer",
			"mage",
			"priest",
			"upgattack",
			"upgattack",
			"upgspeed",
			"upgspeed",
			"upgarmor",
			"upgarmor",
			"upgrange",
			"upgrange"
		],
		effectsFields: [
			"range",
			"range",
			"range",
			"buildTime",
			"cost",
			"buildTime",
			"cost",
			"buildTime",
			"cost",
			"buildTime",
			"cost"
		],
		effectsModifications: [
			1,
			1,
			1,
			20 * 20,
			60,
			20 * 20,
			60,
			20 * 20,
			60,
			20 * 20,
			60
		],
		effectsModsMultiplier: [
			1,
			1,
			1,
			1,
			1,
			1,
			1,
			1,
			1,
			1,
			1
		],
		description: "Increases the range of your ranged human units. Has no influence on melee units.",
		image: "rangeUpg"
	},
	
	{
		name: "Beast Range",
		id_string: "upgbeastrange",
		cost: 140,
		buildTime: 90 * 20,
		maxLevel: 5,
		effectsTypes: [
			"dragon",
			"upgbeastattack",
			"upgbeastattack",
			"upgbeastspeed",
			"upgbeastspeed",
			"upgbeastdefense",
			"upgbeastdefense",
			"upgbeastrange",
			"upgbeastrange"
		],
		effectsFields: [
			"range",
			"buildTime",
			"cost",
			"buildTime",
			"cost",
			"buildTime",
			"cost",
			"buildTime",
			"cost"
		],
		effectsModifications: [
			1,
			20 * 20,
			60,
			20 * 20,
			60,
			20 * 20,
			60,
			20 * 20,
			60
		],
		effectsModsMultiplier: [
			1,
			1,
			1,
			1,
			1,
			1,
			1,
			1,
			1
		],
		description: "Increases the range of your ranged beast units. Has no influence on melee units.",
		image: "beastRangeUpg"
	},
	
	{
		name: "Research Invisibility",
		id_string: "upginvis",
		cost: 100,
		buildTime: 72 * 20,
		maxLevel: 1,
		description: "Allows your Priests to cast Invisibility.",
		effectsTypes: [
			"upgheal",
			"upghealingward"
		],
		effectsFields: [
			"cost",
			"cost"
		],
		effectsModifications: [
			200,
			200
		],
		effectsModsMultiplier: [
			1,
			1
		],
		image: "invisibility"
	},
	
	{
		name: "Research Summon Skeleton",
		id_string: "upgskeleton",
		cost: 100,
		buildTime: 72 * 20,
		maxLevel: 1,
		description: "Allows your Mages to summon skeletons.",
		effectsTypes: [
			"upgslowfield",
			"upgfireball"
		],
		effectsFields: [
			"cost",
			"cost"
		],
		effectsModifications: [
			200,
			200
		],
		effectsModsMultiplier: [
			1,
			1
		],
		image: "skeleton"
	},
	
	{
		name: "Research Summon Healing Ward",
		id_string: "upghealingward",
		cost: 100,
		buildTime: 72 * 20,
		maxLevel: 1,
		description: "Allows your Priests to summon a Healing Ward.",
		effectsTypes: [
			"upgheal",
			"upginvis"
		],
		effectsFields: [
			"cost",
			"cost"
		],
		effectsModifications: [
			200,
			200
		],
		effectsModsMultiplier: [
			1,
			1
		],
		image: "heal"
	},
	
	{
		name: "Research Slow Field",
		id_string: "upgslowfield",
		cost: 100,
		buildTime: 72 * 20,
		maxLevel: 1,
		description: "Allows your Mages to create a Slow Field.",
		effectsTypes: [
			"upgfireball",
			"upgskeleton"
		],
		effectsFields: [
			"cost",
			"cost"
		],
		effectsModifications: [
			200,
			200
		],
		effectsModsMultiplier: [
			1,
			1
		],
		image: "slowfield"
	},
	
	{
		name: "Airship Telescope Extension",
		id_string: "upgtelescope",
		cost: 100,
		buildTime: 54 * 20,
		maxLevel: 1,
		description: "Allows your Airships to see invisible units.",
		effectsTypes: [
			"airship"
		],
		effectsFields: [
			"hasDetection"
		],
		effectsModifications: [
			1
		],
		effectsModsMultiplier: [
			1
		],
		image: "telescope"
	}
	
];






// Commands
var basicCommands = [
	
	{
		type: COMMAND.MAKEUNIT,
		unitType: "worker",
		isInstant: true,
		image: "worker",
		hotkey: KEY.E,
		name: "Train Worker",
		id_string: "trainworker",
		description: "Cost: getField(worker.cost) Gold#BRSupply: getField(worker.supply)#BRDuration: getField(worker.buildTime) sec#BRgetField(worker.description)",
		interfacePosX: 0,
		interfacePosY: 0,
		commandCard: 0
	},
	
	{
		type: COMMAND.MAKEUNIT,
		unitType: "soldier",
		isInstant: true,
		image: "soldier",
		hotkey: KEY.Q,
		name: "Train Soldier",
		id_string: "trainsoldier",
		description: "Cost: getField(soldier.cost) Gold#BRSupply: getField(soldier.supply)#BRDuration: getField(soldier.buildTime) sec#BRgetField(soldier.description)",
		interfacePosX: 0,
		interfacePosY: 0,
		commandCard: 0
	},
	
	{
		type: COMMAND.MAKEUNIT,
		unitType: "archer",
		isInstant: true,
		image: "archer",
		hotkey: KEY.W,
		name: "Train Archer",
		id_string: "trainarcher",
		description: "Cost: getField(archer.cost) Gold#BRSupply: getField(archer.supply)#BRDuration: getField(archer.buildTime) sec#BRgetField(archer.description)",
		interfacePosX: 1,
		interfacePosY: 0,
		commandCard: 0
	},
	
	{
		type: COMMAND.MAKEBUILDING,
		unitType: "castle",
		image: "castle",
		hotkey: KEY.Q,
		name: "Build Castle",
		id_string: "buildcastle",
		description: "Cost: getField(castle.cost) Gold#BRDuration: getField(castle.buildTime) sec#BRgetField(castle.description)",
		targetIsPoint: true,
		commandCard: 1,
		interfacePosX: 0,
		interfacePosY: 0
	},
	
	{
		type: COMMAND.MAKEBUILDING,
		unitType: "barracks",
		image: "barracks",
		hotkey: KEY.A,
		name: "Build Barracks",
		id_string: "buildbarracks",
		requirementType: ["house"],
		requirementLevel: [1],
		requirementText: ["Requires a House"],
		description: "Cost: getField(barracks.cost) Gold#BRDuration: getField(barracks.buildTime) sec#BRgetField(barracks.description)",
		targetIsPoint: true,
		commandCard: 1,
		interfacePosX: 0,
		interfacePosY: 1
	},
	
	{
		type: COMMAND.MAKEBUILDING,
		unitType: "watchtower",
		image: "watchtower",
		hotkey: KEY.W,
		name: "Build Watchtower",
		id_string: "buildwatchtower",
		description: "Cost: getField(watchtower.cost) Gold#BRDuration: getField(watchtower.buildTime) sec#BRgetField(watchtower.description)",
		targetIsPoint: true,
		commandCard: 1,
		interfacePosX: 1,
		interfacePosY: 0
	},
	
	{
		type: COMMAND.MAKEBUILDING,
		unitType: "house",
		image: "house",
		hotkey: KEY.E,
		name: "Build House",
		id_string: "buildhouse",
		description: "Cost: getField(house.cost) Gold#BRDuration: getField(house.buildTime) sec#BRgetField(house.description)",
		targetIsPoint: true,
		commandCard: 1,
		interfacePosX: 2,
		interfacePosY: 0
	},
	
	{
		type: COMMAND.IDLE,
		isInstant: true,
		image: "stop",
		hotkey: KEY.S,
		name: "Stop",
		id_string: "stop",
		description: "Stop and cancel any existing orders.",
		interfacePosX: 3,
		interfacePosY: 0,
		commandCard: 0
	},
	
	{
		type: COMMAND.HOLDPOSITION,
		isInstant: true,
		image: "holdposition",
		hotkey: KEY.D,
		name: "Hold Position",
		id_string: "holdposition",
		description: "The unit will stop and not move whatsoever.",
		interfacePosX: 4,
		interfacePosY: 0,
		commandCard: 0
	},
	
	{
		type: COMMAND.ATTACK,
		image: "attack",
		hotkey: KEY.A,
		name: "Attack",
		id_string: "attack",
		description: "Order attack an enemy unit to attack it directly or order attack at a point to order your unit(s) to move there and attacking any enemy during its way.",
		targetIsUnit: true,
		interfacePosX: 2,
		interfacePosY: 0,
		commandCard: 0,
		cursor: "url(imgs/cursor-attack.cur)"
	},
	
	{
		type: COMMAND.CANCEL,
		isInstant: true,
		image: "cancel",
		hotkey: KEY.R,
		name: "Cancel",
		id_string: "cancel",
		description: "Cancel the current order.",
		interfacePosX: 4,
		interfacePosY: 0,
		commandCard: 0
	},
	
	{
		type: COMMAND.MOVE,
		name: "Move",
		id_string: "move",
		targetIsPoint: true
	},
	
	{
		type: COMMAND.MOVETO,
		name: "Moveto",
		id_string: "moveto",
		targetIsUnit: true,
		range: [0.2]
	},
	
	{
		type: COMMAND.MINE,
		name: "Mine",
		id_string: "mine",
		targetIsUnit: true,
		range: [0.2]
	},
	
	{
		type: COMMAND.REPAIR,
		name: "Repair",
		id_string: "repair",
		image: "repair",
		description: "Repair a building or a mechanical unit.",
		targetIsUnit: true,
		range: [0],
		hotkey: KEY.E,
		interfacePosX: 4,
		interfacePosY: 1,
		commandCard: 0,
		targetRequirements1: [targetRequirements.isBuilding, targetRequirements.isMechanical],
		hasAutocast: true,
		autocastConditions: "hp < type.hp - 1 && owner == this.owner && isUnderConstruction != 1"
	},
	
	{
		type: COMMAND.AMOVE,
		name: "AMove",
		id_string: "amove",
		targetIsPoint: true
	},
	
	{
		type: COMMAND.MAKEBUILDING,
		name: "Makebuilding",
		id_string: "makebuilding"
	},
	
	{
		type: COMMAND.MAKEUNIT,
		unitType: "mage",
		isInstant: true,
		image: "mage",
		hotkey: KEY.A,
		name: "Train Mage",
		id_string: "trainmage",
		description: "Cost: getField(mage.cost) Gold#BRSupply: getField(mage.supply)#BRDuration: getField(mage.buildTime) sec#BRgetField(mage.description)",
		interfacePosX: 0,
		interfacePosY: 1,
		commandCard: 0
	},
	
	{
		type: COMMAND.MAKEUNIT,
		unitType: "priest",
		isInstant: true,
		image: "priest",
		hotkey: KEY.A,
		name: "Train Priest",
		id_string: "trainpriest",
		description: "Cost: getField(priest.cost) Gold#BRSupply: getField(priest.supply)#BRDuration: getField(priest.buildTime) sec#BRgetField(priest.description)",
		interfacePosX: 0,
		interfacePosY: 1,
		commandCard: 0
	},
	
	{
		type: COMMAND.MAKEBUILDING,
		unitType: "magesguild",
		image: "mages_guild",
		hotkey: KEY.S,
		name: "Build Mages Guild",
		id_string: "buildmagesguild",
		description: "Cost: getField(magesguild.cost) Gold#BRDuration: getField(magesguild.buildTime) sec#BRgetField(magesguild.description)",
		targetIsPoint: true,
		commandCard: 1,
		interfacePosX: 1,
		interfacePosY: 1
	},
	
	{
		type: COMMAND.UNIVERSAL,
		image: "flamestrike",
		hotkey: KEY.Q,
		name: "Flamestrike",
		id_string: "flamestrike",
		targetIsPoint: true,
		manaCost: [50],
		aoeRadius: [1.75],
		damage: [20],
		projectileSpeed: [6],
		duration: 0,
		range: [6],
		description: "Casts a flamestrike at a target location, dealing getField(shockwave.damage) damage to nearby units and throwing them back.",
		interfacePosX: 2,
		interfacePosY: 1,
		commandCard: 0,
		cursor: "url(imgs/blank-pixel.cur)",
		useAoeCursor: true,
		castingDelay: 0.05 * 20,
		cooldown: 0.3 * 20,
		launchSound: SOUND.FLAMESTRIKE_LAUNCH,
		attackEffect: "flamestrike",
		bounceDistMax: 6,
		bounceDistMin: 3,
		bouncePower: 1.5
	},
	
	{
		type: COMMAND.MAKEUNIT,
		unitType: "catapult",
		isInstant: true,
		image: "catapult",
		hotkey: KEY.Q,
		name: "Construct Catapult",
		id_string: "constructcatapult",
		description: "Cost: getField(catapult.cost) Gold#BRSupply: getField(catapult.supply)#BRDuration: getField(catapult.buildTime) sec#BRgetField(catapult.description)",
		interfacePosX: 0,
		interfacePosY: 0,
		commandCard: 0
	},
	
	{
		type: COMMAND.MAKEBUILDING,
		unitType: "workshop",
		image: "workshop",
		hotkey: KEY.D,
		name: "Build Workshop",
		id_string: "buildworkshop",
		description: "Cost: getField(workshop.cost) Gold#BRDuration: getField(workshop.buildTime) sec#BRgetField(workshop.description)",
		targetIsPoint: true,
		interfacePosX: 2,
		interfacePosY: 1,
		commandCard: 1
	},
	
	{
		type: COMMAND.MAKEBUILDING,
		unitType: "forge",
		image: "forge",
		hotkey: KEY.R,
		name: "Build Forge",
		id_string: "buildforge",
		description: "Cost: getField(forge.cost) Gold#BRDuration: getField(forge.buildTime) sec#BRgetField(forge.description)",
		targetIsPoint: true,
		interfacePosX: 3,
		interfacePosY: 0,
		commandCard: 1
	},
	
	{
		type: COMMAND.SWITCH_CC,
		image: "hammer",
		hotkey: KEY.Q,
		name: "Buildings",
		id_string: "buildings",
		description: "Construct Buildings",
		interfacePosX: 0,
		interfacePosY: 0,
		commandCard: 0,
		targetCC: 1
	},
	
	{
		type: COMMAND.UPGRADE,
		upgrade: "upgattack",
		isInstant: true,
		image: "attackUpg",
		hotkey: KEY.Q,
		name: "Attack Upgrade",
		id_string: "attackupgrade",
		description: "Level add(getUpgradeLevel(upgattack), upgradeCountInResearch(upgattack), 1)#BRCost: getField(upgattack.cost) Gold#BRDuration: getField(upgattack.buildTime) sec#BRgetField(upgattack.description)",
		interfacePosX: 0,
		interfacePosY: 0,
		commandCard: 0
	},
	
	{
		type: COMMAND.UPGRADE,
		upgrade: "upgarmor",
		isInstant: true,
		image: "armorUpg",
		hotkey: KEY.W,
		name: "Armor Upgrade",
		id_string: "armorupgrade",
		description: "Level add(getUpgradeLevel(upgarmor), upgradeCountInResearch(upgarmor), 1)#BRCost: getField(upgarmor.cost) Gold#BRDuration: getField(upgarmor.buildTime) sec#BRgetField(upgarmor.description)",
		interfacePosX: 1,
		interfacePosY: 0,
		commandCard: 0
	},
	
	{
		type: COMMAND.UNIVERSAL,
		image: "heal",
		hotkey: KEY.W,
		name: "Heal",
		id_string: "heal",
		targetRequirements1: [targetRequirements.isBiological],
		targetIsUnit: true,
		attackEffect: "heal",
		manaCost: [25],
		range: [8],
		projectileSpeed: [0],
		damage: [-75],
		description: "Heals a target unit by mul(getField(heal.damage), -1) HP",
		interfacePosX: 1,
		interfacePosY: 1,
		commandCard: 0,
		castingDelay: 0.05 * 20,
		cooldown: 0.4 * 20,
		launchSound: SOUND.HEAL,
		cursor: "url(imgs/cursor-heal.cur)"
	},
	
	{
		type: COMMAND.UPGRADE,
		upgrade: "upgfireball",
		isInstant: true,
		image: "flamestrike",
		hotkey: KEY.Q,
		name: "Research Fireball",
		id_string: "researchfireball",
		description: "Cost: getField(upgfireball.cost) Gold#BRDuration: getField(upgfireball.buildTime) sec#BRgetField(upgfireball.description)",
		interfacePosX: 0,
		interfacePosY: 0,
		commandCard: 0
	},
	
	{
		type: COMMAND.UPGRADE,
		upgrade: "upgslowfield",
		isInstant: true,
		image: "slowfield",
		hotkey: KEY.W,
		name: "Research Slow Field",
		id_string: "researchslowfield",
		description: "Cost: getField(upgslowfield.cost) Gold#BRDuration: getField(upgslowfield.buildTime) sec#BRgetField(upgslowfield.description)",
		interfacePosX: 1,
		interfacePosY: 0,
		commandCard: 0
	},
	
	{
		type: COMMAND.UPGRADE,
		upgrade: "upgheal",
		isInstant: true,
		image: "heal",
		hotkey: KEY.W,
		name: "Research Heal",
		id_string: "researchheal",
		description: "Cost: getField(upgheal.cost) Gold#BRDuration: getField(upgheal.buildTime) sec#BRgetField(upgheal.description)",
		interfacePosX: 1,
		interfacePosY: 0,
		commandCard: 0
	},
	
	{
		type: COMMAND.BUILDING_UPGRADE,
		isInstant: true,
		image: "fortress",
		hotkey: KEY.A,
		improvedBuilding: "fortress",
		name: "Upgrade To Fortress",
		id_string: "upgradetofortress",
		description: "Cost: getField(fortress.cost) Gold#BRDuration: getField(fortress.buildTime) sec#BRgetField(fortress.description)",
		interfacePosX: 0,
		interfacePosY: 1,
		commandCard: 0
	},
	
	{
		type: COMMAND.BUILDING_UPGRADE,
		isInstant: true,
		image: "eye",
		hotkey: KEY.Q,
		improvedBuilding: "watchtower2",
		name: "Research Detection",
		id_string: "researchdetection",
		description: "Cost: getField(watchtower2.cost) Gold#BRDuration: getField(watchtower2.buildTime) sec#BRgetField(watchtower2.description)",
		interfacePosX: 0,
		interfacePosY: 0,
		commandCard: 0
	},
	
	{
		type: COMMAND.MAKEBUILDING,
		unitType: "dragonslair",
		image: "dragons_lair",
		hotkey: KEY.F,
		name: "Build Dragons Lair",
		id_string: "builddragonslair",
		description: "Cost: getField(dragonslair.cost) Gold#BRDuration: getField(dragonslair.buildTime) sec#BRgetField(dragonslair.description)",
		requirementText: ["Requires a Fortress"],
		requirementType: ["fortress"],
		requirementLevel: [1],
		targetIsPoint: true,
		commandCard: 1,
		interfacePosX: 3,
		interfacePosY: 1
	},
	
	{
		type: COMMAND.MAKEUNIT,
		unitType: "dragon",
		isInstant: true,
		image: "dragon",
		hotkey: KEY.Q,
		name: "Train Dragon",
		id_string: "traindragon",
		description: "Cost: getField(dragon.cost) Gold#BRSupply: getField(dragon.supply)#BRDuration: getField(dragon.buildTime) sec#BRgetField(dragon.description)",
		interfacePosX: 0,
		interfacePosY: 0,
		commandCard: 0
	},
	
	{
		type: COMMAND.UPGRADE,
		upgrade: "upgbeastattack",
		isInstant: true,
		image: "dragonAttUpg",
		hotkey: KEY.Q,
		name: "Beast Attack Upgrade",
		id_string: "beastattackupgrade",
		description: "Level add(getUpgradeLevel(upgbeastattack), upgradeCountInResearch(upgbeastattack), 1)#BRCost: getField(upgbeastattack.cost) Gold#BRDuration: getField(upgbeastattack.buildTime) sec#BRgetField(upgbeastattack.description)",
		interfacePosX: 0,
		interfacePosY: 0,
		commandCard: 0
	},
	
	{
		type: COMMAND.UPGRADE,
		upgrade: "upgbeastdefense",
		isInstant: true,
		image: "dragonDefUpg",
		hotkey: KEY.W,
		name: "Beast Defense Upgrade",
		id_string: "beastdefenseupgrade",
		description: "Level add(getUpgradeLevel(upgbeastdefense), upgradeCountInResearch(upgbeastdefense), 1)#BRCost: getField(upgbeastdefense.cost) Gold#BRDuration: getField(upgbeastdefense.buildTime) sec#BRgetField(upgbeastdefense.description)",
		interfacePosX: 1,
		interfacePosY: 0,
		commandCard: 0
	},
	
	{
		type: COMMAND.MAKEUNIT,
		unitType: "wolf",
		isInstant: true,
		image: "wolf",
		hotkey: KEY.Q,
		name: "Train Wolf",
		id_string: "trainwolf",
		description: "Cost: getField(wolf.cost) Gold#BRSupply: getField(wolf.supply)#BRDuration: getField(wolf.buildTime) sec#BRgetField(wolf.description)",
		interfacePosX: 0,
		interfacePosY: 0,
		commandCard: 0
	},
	
	{
		type: COMMAND.MAKEBUILDING,
		unitType: "wolvesden",
		image: "wolves_den",
		hotkey: KEY.T,
		name: "Build Wolves Den",
		id_string: "buildwolvesden",
		description: "Cost: getField(wolvesden.cost) Gold#BRDuration: getField(wolvesden.buildTime) sec#BRgetField(wolvesden.description)",
		requirementText: ["Requires a House"],
		requirementType: ["house"],
		requirementLevel: [1],
		targetIsPoint: true,
		commandCard: 1,
		interfacePosX: 4,
		interfacePosY: 0
	},
	
	{
		type: COMMAND.MAKEBUILDING,
		unitType: "animaltestinglab",
		image: "animal_testing_lab",
		hotkey: KEY.W,
		name: "Build Animal Testing Lab",
		id_string: "buildanimaltestinglab",
		description: "Cost: getField(animaltestinglab.cost) Gold#BRDuration: getField(animaltestinglab.buildTime) sec#BRgetField(animaltestinglab.description)",
		targetIsPoint: true,
		commandCard: 2,
		interfacePosX: 1,
		interfacePosY: 0,
	},
	
	{
		type: COMMAND.LOAD,
		image: "load",
		hotkey: KEY.Q,
		name: "Load in",
		id_string: "loadin",
		description: "Load units in",
		targetIsUnit: true,
		commandCard: 0,
		interfacePosX: 0,
		interfacePosY: 1
	},
	
	{
		type: COMMAND.UNLOAD,
		image: "unload",
		hotkey: KEY.W,
		name: "Unload",
		id_string: "unload",
		description: "Unload units",
		targetIsPoint: true,
		commandCard: 0,
		interfacePosX: 1,
		interfacePosY: 1
	},
	
	{
		type: COMMAND.MAKEBUILDING,
		unitType: "advancedworkshop",
		image: "adv_workshop",
		hotkey: KEY.Q,
		name: "Build Advanced Workshop",
		id_string: "buildadvancedworkshop",
		description: "Cost: getField(advancedworkshop.cost) Gold#BRDuration: getField(advancedworkshop.buildTime) sec#BRgetField(advancedworkshop.description)",
		targetIsPoint: true,
		commandCard: 2,
		interfacePosX: 0,
		interfacePosY: 0
	},
	
	{
		type: COMMAND.SWITCH_CC,
		image: "hammer",
		hotkey: KEY.W,
		name: "Buildings",
		id_string: "buildings2",
		description: "Construct additional Buildings",
		interfacePosX: 1,
		interfacePosY: 0,
		commandCard: 0,
		targetCC: 2
	},
	
	{
		type: COMMAND.MAKEUNIT,
		unitType: "airship",
		isInstant: true,
		image: "airship",
		hotkey: KEY.Q,
		name: "Construct Airship",
		id_string: "constructairship",
		description: "Cost: getField(airship.cost) Gold#BRSupply: getField(airship.supply)#BRDuration: getField(airship.buildTime) sec#BRgetField(airship.description)",
		interfacePosX: 0,
		interfacePosY: 0,
		commandCard: 0
	},
	
	{
		type: COMMAND.UPGRADE,
		upgrade: "upgtower",
		isInstant: true,
		image: "towerUpg",
		hotkey: KEY.W,
		name: "Tower Upgrade",
		id_string: "towerupgrade",
		description: "Cost: getField(upgtower.cost) Gold#BRDuration: getField(upgtower.buildTime) sec#BRgetField(upgtower.description)",
		interfacePosX: 1,
		interfacePosY: 0,
		commandCard: 0
	},
	
	{
		type: COMMAND.UNLOAD2,
		name: "Direct Unload",
		id_string: "directunload",
		targetIsInt: true
	},
	
	{
		type: COMMAND.ATTACK_GROUND,
		hotkey: KEY.Q,
		name: "Attack Ground",
		id_string: "attackground",
		targetIsPoint: true,
		image: "groundAttack",
		interfacePosX: 0,
		interfacePosY: 0,
		commandCard: 0,
		description: "Fire at a certion point",
		cursor: "url(imgs/blank-pixel.cur)",
		useAoeCursor: true,
		aoeRadius: [0.45]
	},
	
	{
		type: COMMAND.UNIVERSAL,
		name: "Smash",
		id_string: "smash",
		image: "smash",
		hotkey: KEY.Q,
		isInstant: true,
		interfacePosX: 0,
		interfacePosY: 0,
		commandCard: 0,
		description: "Perform a round house hit, dealing damage and smashing back small nearby units (only hits enemy units)",
		aoeRadius: [3.5],
		damage: [20],
		hitsFriendly: false,
		cooldown2: 15 * 20,
		animationName: "special1",
		castingDelay: 0.75 * 20,
		cooldown: 1.8 * 20,
		hitsSelf: false,
		launchSound: SOUND.ROUNDHOUSE,
		soundPerHit: SOUND.BIGHIT,
		bounceDistMax: 6.5,
		bounceDistMin: 4,
		bouncePower: 1.5,
		attackEffect: "smoke",
		targetFiltersExclude: ["flying"]
	},
	
	{
		type: COMMAND.UPGRADE,
		upgrade: "upgspeed",
		isInstant: true,
		image: "speedUpg",
		hotkey: KEY.E,
		name: "Speed Upgrade",
		id_string: "speedupgrade",
		description: "Level add(getUpgradeLevel(upgspeed), upgradeCountInResearch(upgspeed), 1)#BRCost: getField(upgspeed.cost) Gold#BRDuration: getField(upgspeed.buildTime) sec#BRgetField(upgspeed.description)",
		interfacePosX: 2,
		interfacePosY: 0,
		commandCard: 0
	},
	
	{
		type: COMMAND.UPGRADE,
		upgrade: "upgbeastspeed",
		isInstant: true,
		image: "beastSpeedUpg",
		hotkey: KEY.E,
		name: "Beast Speed Upgrade",
		id_string: "beastspeedupgrade",
		description: "Level add(getUpgradeLevel(upgbeastspeed), upgradeCountInResearch(upgbeastspeed), 1)#BRCost: getField(upgbeastspeed.cost) Gold#BRDuration: getField(upgbeastspeed.buildTime) sec#BRgetField(upgbeastspeed.description)",
		interfacePosX: 2,
		interfacePosY: 0,
		commandCard: 0
	},
	
	{
		type: COMMAND.BUILDING_UPGRADE,
		isInstant: true,
		image: "werewolves_den",
		hotkey: KEY.A,
		improvedBuilding: "werewolvesden",
		name: "Upgrade To Werewolves Den",
		id_string: "upgradetowerewolvesden",
		description: "Cost: getField(werewolvesden.cost) Gold#BRDuration: getField(werewolvesden.buildTime) sec#BRgetField(werewolvesden.description)",
		interfacePosX: 0,
		interfacePosY: 1,
		commandCard: 0
	},
	
	{
		type: COMMAND.MAKEUNIT,
		unitType: "werewolf",
		isInstant: true,
		image: "werewolf",
		hotkey: KEY.W,
		name: "Train Werewolf",
		id_string: "trainwerewolf",
		description: "Cost: getField(werewolf.cost) Gold#BRSupply: getField(werewolf.supply)#BRDuration: getField(werewolf.buildTime) sec#BRgetField(werewolf.description)",
		interfacePosX: 1,
		interfacePosY: 0,
		commandCard: 0
	},
	
	{
		type: COMMAND.MAKEUNIT,
		unitType: "ballista",
		isInstant: true,
		image: "ballista",
		hotkey: KEY.W,
		name: "Construct Ballista",
		id_string: "constructballista",
		description: "Cost: getField(ballista.cost) Gold#BRSupply: getField(ballista.supply)#BRDuration: getField(ballista.buildTime) sec#BRgetField(ballista.description)",
		interfacePosX: 1,
		interfacePosY: 0,
		commandCard: 0
	},
	
	{
		type: COMMAND.UPGRADE,
		upgrade: "upgmechattack",
		isInstant: true,
		image: "mechAttUpg",
		hotkey: KEY.A,
		name: "Mech Attack Upgrade",
		id_string: "mechattackupgrade",
		description: "Level add(getUpgradeLevel(upgmechattack), upgradeCountInResearch(upgmechattack), 1)#BRCost: getField(upgmechattack.cost) Gold#BRDuration: getField(upgmechattack.buildTime) sec#BRgetField(upgmechattack.description)",
		interfacePosX: 0,
		interfacePosY: 1,
		commandCard: 0
	},
	
	{
		type: COMMAND.UPGRADE,
		upgrade: "upgmechdefense",
		isInstant: true,
		image: "mechDefUpg",
		hotkey: KEY.S,
		name: "Mech Armor Upgrade",
		id_string: "mecharmorupgrade",
		description: "Level add(getUpgradeLevel(upgmechdefense), upgradeCountInResearch(upgmechdefense), 1)#BRCost: getField(upgmechdefense.cost) Gold#BRDuration: getField(upgmechdefense.buildTime) sec#BRgetField(upgmechdefense.description)",
		interfacePosX: 1,
		interfacePosY: 1,
		commandCard: 0
	},
	
	{
		type: COMMAND.UPGRADE,
		upgrade: "upgmechspeed",
		isInstant: true,
		image: "mechSpeedUpg",
		hotkey: KEY.D,
		name: "Mech Speed Upgrade",
		id_string: "mechspeedupgrade",
		description: "Level add(getUpgradeLevel(upgmechspeed), upgradeCountInResearch(upgmechspeed), 1)#BRCost: getField(upgmechspeed.cost) Gold#BRDuration: getField(upgmechspeed.buildTime) sec#BRgetField(upgmechspeed.description)",
		interfacePosX: 2,
		interfacePosY: 1,
		commandCard: 0
	},
	
	{
		type: COMMAND.UPGRADE,
		upgrade: "upgballistaexplosives",
		isInstant: true,
		image: "flakUpg",
		hotkey: KEY.S,
		name: "Ballista Black Powder",
		id_string: "ballistaexplosives",
		description: "Cost: getField(upgballistaexplosives.cost) Gold#BRDuration: getField(upgballistaexplosives.buildTime) sec#BRgetField(upgballistaexplosives.description)",
		interfacePosX: 1,
		interfacePosY: 1,
		commandCard: 0
	},
	
	{
		type: COMMAND.UNIVERSAL,
		name: "Fireball",
		id_string: "fireball",
		requirementText: ["This spell needs to be researched first."],
		requirementType: ["upgfireball"],
		requirementLevel: [1],
		description: "Casts a fireball at a target location, dealing damage to all units in the way.",
		targetIsPoint: true,
		manaCost: [50],
		image: "flamestrike",
		attackEffect: "flamestrike",
		hotkey: KEY.Q,
		projectileAoeRadius: [1.0],
		projectileDamage: [2.5],
		projectileSpeed: [5],
		maximizeRangeWhenCasting: true,
		range: [13],
		effectScale: 2,
		interfacePosX: 0,
		interfacePosY: 1,
		commandCard: 0,
		castingDelay: 0.05 * 20,
		cooldown: 0.3 * 20,
		cooldown2: 3.0 * 20,
		launchSound: SOUND.FLAMESTRIKE_LAUNCH,
		causesFlameDeath: true,
		cursor: "url(imgs/cursor-attack.cur)",
		targetFiltersExclude: ["flying"]
	},
	
	{
		type: COMMAND.UPGRADE,
		upgrade: "upgshockwave",
		isInstant: true,
		image: "shockwave",
		hotkey: KEY.E,
		name: "Research Shockwave",
		id_string: "researchshockwave",
		description: "Cost: getField(upgshockwave.cost) Gold#BRDuration: getField(upgshockwave.buildTime) sec#BRgetField(upgshockwave.description)",
		interfacePosX: 2,
		interfacePosY: 0,
		commandCard: 0
	},
	
	{
		type: COMMAND.SWITCH_CC,
		image: "cancel",
		hotkey: KEY.G,
		name: "Back",
		id_string: "back",
		description: "Back to main menu",
		interfacePosX: 4,
		interfacePosY: 1,
		commandCard: 1,
		targetCC: 0
	},
	
	{
		type: COMMAND.SWITCH_CC,
		image: "cancel",
		hotkey: KEY.G,
		name: "Back",
		id_string: "back2",
		description: "Back to main menu",
		interfacePosX: 4,
		interfacePosY: 1,
		commandCard: 2,
		targetCC: 0
	},
	
	{
		type: COMMAND.UPGRADE,
		upgrade: "upgrange",
		isInstant: true,
		image: "rangeUpg",
		hotkey: KEY.T,
		name: "Range Upgrade",
		id_string: "rangeupgrade",
		description: "Level add(getUpgradeLevel(upgrange), upgradeCountInResearch(upgrange), 1)#BRCost: getField(upgrange.cost) Gold#BRDuration: getField(upgrange.buildTime) sec#BRgetField(upgrange.description)",
		interfacePosX: 3,
		interfacePosY: 0,
		commandCard: 0
	},
	
	{
		type: COMMAND.UPGRADE,
		upgrade: "upgbeastrange",
		isInstant: true,
		image: "beastRangeUpg",
		hotkey: KEY.T,
		name: "Beast Range Upgrade",
		id_string: "beastrangeupgrade",
		description: "Level add(getUpgradeLevel(upgbeastrange), upgradeCountInResearch(upgbeastrange), 1)#BRCost: getField(upgbeastrange.cost) Gold#BRDuration: getField(upgbeastrange.buildTime) sec#BRgetField(upgbeastrange.description)",
		interfacePosX: 3,
		interfacePosY: 0,
		commandCard: 0
	},
	
	{
		type: COMMAND.UPGRADE,
		upgrade: "upgmechrange",
		isInstant: true,
		image: "mechRangeUpg",
		hotkey: KEY.F,
		name: "Mech Range Upgrade",
		id_string: "mechrangeupgrade",
		description: "Level add(getUpgradeLevel(upgmechrange), upgradeCountInResearch(upgmechrange), 1)#BRCost: getField(upgmechrange.cost) Gold#BRDuration: getField(upgmechrange.buildTime) sec#BRgetField(upgmechrange.description)",
		interfacePosX: 3,
		interfacePosY: 1,
		commandCard: 0
	},
	
	{
		type: COMMAND.UNIVERSAL,
		name: "Dmg Buff",
		id_string: "dmgbuffability",
		image: "worker",
		hotkey: KEY.Q,
		targetIsPoint: true,
		interfacePosX: 0,
		interfacePosY: 1,
		commandCard: 0,
		range: [8],
		description: "Gives a dmg buff",
		aoeRadius: [3.5],
		cooldown2: 10 * 20,
		castingDelay: 1.0 * 20,
		cooldown: 1.8 * 20,
		launchSound: SOUND.ROUNDHOUSE,
		modifiers: ["dmgbuff"]
	},
	
	{
		type: COMMAND.UNIVERSAL,
		name: "Invisibility",
		id_string: "invisibilityspell",
		image: "invisibility",
		hotkey: KEY.Q,
		targetIsUnit: true,
		interfacePosX: 0,
		interfacePosY: 1,
		commandCard: 0,
		range: [9],
		description: "Makes target unit or building invisible and gives a small damage buff",
		castingDelay: 0.05 * 20,
		cooldown: 0.5 * 20,
		manaCost: [50],
		requirementText: ["This spell needs to be researched first."],
		requirementType: ["upginvis"],
		requirementLevel: [1],
		launchSound: SOUND.ROUNDHOUSE,
		modifiers: ["invisibility"],
		attackEffect: "smoke"
	},
	
	{
		type: COMMAND.UNIVERSAL,
		name: "Summon Skeleton",
		id_string: "summonskeleton",
		image: "skeleton",
		hotkey: KEY.W,
		targetIsPoint: true,
		interfacePosX: 1,
		interfacePosY: 1,
		commandCard: 0,
		range: [6],
		description: "Summons a skeleton that has a limited lifetime",
		castingDelay: 0.05 * 20,
		cooldown: 0.5 * 20,
		manaCost: [50],
		requirementText: ["This spell needs to be researched first."],
		requirementType: ["upgskeleton"],
		requirementLevel: [1],
		launchSound: SOUND.ROUNDHOUSE,
		summonedUnits: ["skeleton"],
		attackEffect: "smoke",
		requiresVision: true
	},
	
	{
		type: COMMAND.MAKEBUILDING,
		unitType: "church",
		image: "church",
		hotkey: KEY.E,
		name: "Build Church",
		id_string: "buildchurch",
		description: "Cost: getField(church.cost) Gold#BRDuration: getField(church.buildTime) sec#BRgetField(church.description)",
		targetIsPoint: true,
		commandCard: 2,
		interfacePosX: 2,
		interfacePosY: 0
	},
	
	{
		type: COMMAND.UPGRADE,
		upgrade: "upginvis",
		isInstant: true,
		image: "invisibility",
		hotkey: KEY.Q,
		name: "Research Invisibility",
		id_string: "researchinvisibility",
		description: "Cost: getField(upginvis.cost) Gold#BRDuration: getField(upginvis.buildTime) sec#BRgetField(upginvis.description)",
		interfacePosX: 0,
		interfacePosY: 0,
		commandCard: 0
	},
	
	{
		type: COMMAND.UPGRADE,
		upgrade: "upgskeleton",
		isInstant: true,
		image: "skeleton",
		hotkey: KEY.W,
		name: "Research Summon Skeleton",
		id_string: "researchsummonskeleton",
		description: "Cost: getField(upgskeleton.cost) Gold#BRDuration: getField(upgskeleton.buildTime) sec#BRgetField(upgskeleton.description)",
		interfacePosX: 1,
		interfacePosY: 0,
		commandCard: 0
	},
	
	{
		type: COMMAND.UPGRADE,
		upgrade: "upghealingward",
		isInstant: true,
		image: "heal",
		hotkey: KEY.W,
		name: "Research Summon Healing Ward",
		id_string: "researchsummonhealingward",
		description: "Cost: getField(upghealingward.cost) Gold#BRDuration: getField(upghealingward.buildTime) sec#BRgetField(upghealingward.description)",
		interfacePosX: 1,
		interfacePosY: 0,
		commandCard: 0
	},
	
	{
		type: COMMAND.UPGRADE,
		upgrade: "upgtelescope",
		isInstant: true,
		image: "telescope",
		hotkey: KEY.A,
		name: "Airship Telescope Extension",
		id_string: "researchtelescope",
		description: "Cost: getField(upgtelescope.cost) Gold#BRDuration: getField(upgtelescope.buildTime) sec#BRgetField(upgtelescope.description)",
		interfacePosX: 0,
		interfacePosY: 1,
		commandCard: 0
	},
	
	{
		type: COMMAND.DANCE,
		isInstant: true,
		name: "Dance",
		id_string: "dance",
		dance_img: "dance1",
		chat_str: "/dance",
		hide: true
	},
	
	{
		type: COMMAND.DANCE,
		isInstant: true,
		name: "Dance2",
		id_string: "dance2",
		dance_img: "dance2",
		chat_str: "/dance2",
		hide: true
	},
	
	{
		type: COMMAND.UNIVERSAL,
		name: "Summon Healing Ward",
		id_string: "summonhealingward",
		image: "heal",
		hotkey: KEY.W,
		targetIsPoint: true,
		interfacePosX: 1,
		interfacePosY: 1,
		commandCard: 0,
		range: [6],
		description: "Summons a healing ward that heals nearby allied non-undead units and damages enemy undead units",
		castingDelay: 0.05 * 20,
		cooldown: 0.5 * 20,
		manaCost: [60],
		requirementText: ["This spell needs to be researched first."],
		requirementType: ["upghealingward"],
		requirementLevel: [1],
		launchSound: SOUND.WARP,
		summonedUnits: ["healingward"],
		attackEffect: "smoke",
		aoeRadius: [4.6],
		useAoeCursor: true,
		requiresVision: true
	},
	
	{
		type: COMMAND.UNIVERSAL,
		name: "Slow Field",
		id_string: "summonslowfield",
		image: "slowfield",
		hotkey: KEY.W,
		targetIsPoint: true,
		interfacePosX: 1,
		interfacePosY: 1,
		commandCard: 0,
		range: [7],
		description: "Summons a slow field that slows nearby ground units.",
		castingDelay: 0.05 * 20,
		cooldown: 0.5 * 2,
		manaCost: [60],
		launchSound: SOUND.WARP,
		summonedUnits: ["slowingfield"],
		attackEffect: "smoke",
		useAoeCursor: true,
		aoeRadius: [5.1],
		requiresVision: true
	},
	
	{
		type: COMMAND.MAKEUNIT,
		unitType: "bird",
		isInstant: true,
		image: "bird",
		hotkey: KEY.S,
		name: "Train Bird",
		id_string: "trainbird",
		description: "Cost: getField(bird.cost) Gold#BRSupply: getField(bird.supply)#BRDuration: getField(bird.buildTime) sec#BRgetField(bird.description)",
		interfacePosX: 1,
		interfacePosY: 1,
		commandCard: 0
	},
	
	{
		type: COMMAND.UNIVERSAL,
		name: "Fire",
		id_string: "fire",
		image: "heal",
		hotkey: KEY.Q,
		learnHotkey: KEY.W,
		targetIsUnit: true,
		interfacePosX: 0,
		interfacePosY: 1,
		commandCard: 0,
		learnCommandCard: 0,
		learnInterfacePosX: 1,
		learnInterfacePosY: 1,
		requiredLevels: [1, 3, 5],
		range: [2, 6, 10],
		damage: [10, 50, 400],
		description: "Summons a healing ward that heals nearby allied non-undead units and damages enemy undead units",
		castingDelay: 0.05 * 20,
		cooldown: 0.5 * 20,
		manaCost: [10, 20, 30],
		launchSound: SOUND.WARP,
		attackEffect: "smoke",
		requiresVision: true
	},
	
	{
		type: COMMAND.TELEPORT,
		name: "Teleport",
		id_string: "teleport",
		image: "teleport",
		hotkey: KEY.Q,
		interfacePosX: 0,
		interfacePosY: 1,
		commandCard: 0,
		range: [7],
		description: "Teleports this unit over a short distance",
		castingDelay: 0.05 * 20,
		cooldown: 0.5 * 20,
		manaCost: [0],
		launchSound: SOUND.WARP,
		attackEffect: "smoke",
		requiresVision: true
	}
	
];


// Modifiers
var basicModifiers = [
	
	{
		name: "InvisibilityBuff",
		id_string: "invisibility",
		image: "invisibility",
		description: "This unit is invisible#BRLasts getField(invisibility.duration) sec",
		duration: 60 * 20,
		fields: ["isInvisible", "dmg"],
		modifications: [1, 2],
		modificationsMultiplier: [1, 1],
		modificationsRate: [0, 0]
	},
	
	{
		name: "dmgBuff",
		id_string: "dmgbuff",
		image: "attackUpg",
		description: "This unit gets a dmg buff#BRLasts getField(dmgbuff.duration) sec",
		duration: 20 * 20,
		fields: ["dmg"],
		modifications: [5],
		modificationsMultiplier: [1],
		modificationsRate: [0]
	},
	
	{
		name: "Healed",
		id_string: "healed",
		image: "heal",
		description: "This unit is getting healed",
		duration: 2 * 20,
		fields: ["hpRegenerationRate"],
		modifications: [4 / 20],
		modificationsMultiplier: [1],
		modificationsRate: [0]
	},
	
	{
		name: "Damaged",
		id_string: "healeddmg",
		image: "skeleton",
		description: "This unit is getting damaged",
		duration: 2 * 20,
		fields: ["hpRegenerationRate"],
		modifications: [-4 / 20],
		modificationsMultiplier: [1],
		modificationsRate: [0]
	},
	
	{
		name: "Heal Aura",
		id_string: "healaura",
		description: "Heals nearby alled non-undead units",
		duration: 0,
		auraModifiers: ["healed"],
		auraRange: [3.5],
		auraTargetFilters: ["isBiological"],
		auraTargetFiltersExclude: ["isUndead"],
		auraHitsFriendly: true,
		auraHitsEnemy: false,
		effects: ['aura'],
		sound: SOUND.AURA_HEAL,
		volume: 0.2
	},
	
	{
		name: "Heal Aura Dmg",
		id_string: "healauradmg",
		description: "Heals nearby enemy undead units",
		duration: 0,
		auraModifiers: ["healeddmg"],
		auraHitsFriendly: false,
		auraHitsEnemy: true,
		auraRange: [3.5],
		auraTargetFilters: ["isBiological", "isUndead"]
	},
	
	{
		name: "Slow Field",
		id_string: "slowfield",
		description: "Slows nearby enemy units.",
		duration: 0,
		auraModifiers: ["slowed"],
		auraHitsFriendly: false,
		auraHitsEnemy: true,
		effects: ['aura'],
		auraColorRed: 70,
		auraColorGreen: 100,
		auraColorBlue: 190,
		auraColorAlpha: 0.2,
		particleMode: 2,
		density: 40,
		auraRange: [4.0]
	},
	
	{
		name: "Slowed",
		id_string: "slowed",
		image: "heal",
		description: "This unit is getting slowed",
		duration: 1.1 * 20,
		fields: ["movementSpeed"],
		modifications: [0],
		modificationsMultiplier: [0.5],
		modificationsRate: [0]
	}
	
];














// set custom hotkeys from cookie
if(!IS_LOGIC)
{
	hotkeyStr = getCookieValue(document.cookie, "hotkeys").split("#");
	for(var i = 0; i < hotkeyStr.length; i++)
	{
		var arr = hotkeyStr[i].split(":");
		
		if(basicCommands[arr[0]])
		{
			basicCommands[arr[0]].originalHotkey = basicCommands[arr[0]].hotkey;
			basicCommands[arr[0]].hotkey = arr[1];
		}
	}
}






// cliff data
var cliffTable = [
	
	{arr: ["*", 1, "*", 0, 0, 0, 0, 0], cliffIndex: 0},
	{arr: ["*", 0, 0, 1, 0, "*", 0, 0], cliffIndex: 1},
	{arr: [0, 0, "*", 0, 1, 0, 0, "*"], cliffIndex: 2},
	{arr: [0, 0, 0, 0, 0, "*", 1, "*"], cliffIndex: 3},
	{arr: [0, 0, 1, 0, 0, 0, 0, 0], cliffIndex: 4},
	{arr: [1, 0, 0, 0, 0, 0, 0, 0], cliffIndex: 5},
	{arr: [0, 0, 0, 0, 0, 0, 0, 1], cliffIndex: 6},
	{arr: [0, 0, 0, 0, 0, 1, 0, 0], cliffIndex: 7},
	{arr: ["*", 1, 1, 0, 1, 0, 0, "*"], cliffIndex: 8},
	{arr: [1, 1, "*", 1, 0, "*", 0, 0], cliffIndex: 9},
	{arr: ["*", 0, 0, 1, 0, 1, 1, "*"], cliffIndex: 10},
	{arr: [0, 0, "*", 0, 1,"*", 1, 1], cliffIndex: 11}
	
];

// 8 nb's
var nbCoords = [
	{x: -1, y: -1},
	{x: 0, y: -1},
	{x: 1, y: -1},
	{x: -1, y: 0},
	{x: 1, y: 0},
	{x: -1, y: 1},
	{x: 0, y: 1},
	{x: 1, y: 1}
];

// 8 nb's with center field
var nbCoords2 = [
	{x: -1, y: -1},
	{x: 0, y: -1},
	{x: 1, y: -1},
	{x: -1, y: 0},
	{x: 0, y: 0},
	{x: 1, y: 0},
	{x: -1, y: 1},
	{x: 0, y: 1},
	{x: 1, y: 1}
];

var bucketTable = {
	"-1-1": {remove: [{x: 1, y: -1}, {x: 1, y: 0}, {x: 1, y: 1}, {x: 0, y: 1}, {x: -1, y: 1}], add: [{x: -1, y: 1}, {x: -1, y: 0}, {x: -1, y: -1}, {x: 0, y: -1}, {x: 1, y: -1}]},
	"0-1": {remove: [{x: -1, y: 1}, {x: 0, y: 1}, {x: 1, y: 1}], add: [{x: -1, y: -1}, {x: 0, y: -1}, {x: 1, y: -1}]},
	"1-1": {remove: [{x: -1, y: -1}, {x: -1, y: 0}, {x: -1, y: 1}, {x: 0, y: 1}, {x: 1, y: 1}], add: [{x: 1, y: 1}, {x: 1, y: 0}, {x: 1, y: -1}, {x: 0, y: -1}, {x: -1, y: -1}]},
	"-10": {remove: [{x: 1, y: -1}, {x: 1, y: 0}, {x: 1, y: 1}], add: [{x: -1, y: -1}, {x: -1, y: 0}, {x: -1, y: 1}]},
	"10": {remove: [{x: -1, y: -1}, {x: -1, y: 0}, {x: -1, y: 1}], add: [{x: 1, y: -1}, {x: 1, y: 0}, {x: 1, y: 1}]},
	"-11": {remove: [{x: 1, y: 1}, {x: 1, y: 0}, {x: 1, y: -1}, {x: 0, y: -1}, {x: -1, y: -1}], add: [{x: -1, y: -1}, {x: -1, y: 0}, {x: -1, y: 1}, {x: 0, y: 1}, {x: 1, y: 1}]},
	"01": {remove: [{x: -1, y: -1}, {x: 0, y: -1}, {x: 1, y: -1}], add: [{x: -1, y: 1}, {x: 0, y: 1}, {x: 1, y: 1}]},
	"11": {remove: [{x: -1, y: 1}, {x: -1, y: 0}, {x: -1, y: -1}, {x: 0, y: -1}, {x: 1, y: -1}], add: [{x: 1, y: -1}, {x: 1, y: 0}, {x: 1, y: 1}, {x: 0, y: 1}, {x: -1, y: 1}]}
};

var reversePairs = [
	[{x: 0, y: -1}, {x: 0, y: 1}],
	[{x: 1, y: 0}, {x: -1, y: 0}]
];

var rampMaps = [
	{h: [1, 1, 1, 0, 0, 0, 0, 0, 0], rampId: 0, clippingPoint: {x: -1, y: 0}},
	{h: [0, 0, 1, 0, 0, 1, 0, 0, 1], rampId: 1, clippingPoint: {x: -2, y: -1}},
	{h: [1, 0, 0, 1, 0, 0, 1, 0, 0], rampId: 2, clippingPoint: {x: 0, y: -1}},
	{h: [0, 0, 0, 0, 0, 0, 1, 1, 1], rampId: 3, clippingPoint: {x: -1, y: -2}}
];

/*
 * Ramps
 * those x, y, addX values and so on work the following: when map is created and ramp field is found, for every cliff there will be
 * x incremented by the x value and y by the y value until reached the last field still contained by the ramp, then once addX and addY will be added
 * and the field that is reached now will be used to place the cliff tile.
 * for the texture: initX and initY will be applied until reached the last field, then the texture will be applied for every loopX and loopY until the last ramp field reached
 */
var ramps = [

	{
		map: [{x: 0, y: 0, cliff: true}, {x: 1, y: 0, cliff: true}, {x: 2, y: 0, cliff: true}, {x: 0, y: 1}, {x: 1, y: 1}, {x: 2, y: 1}, {x: 0, y: 2}, {x: 1, y: 2}, {x: 2, y: 2}],
		vec: {x: 0, y: 1},
		code: "S",
		cliffs: [{x: -1, y: -1, cliff: ramp_tiles[0]}, {x: 1, y: -1, cliff: ramp_tiles[1]}],
		texture: {tiles: [ramp_tiles[2], ramp_tiles[3], ramp_tiles[4]], initX: -1, initY: -1, loopX: 1, loopY: 0, drawX: 0.5, drawY: -0.3},
		noRamps: [{x: -1, y: -1}, {x: 0, y: -1}, {x: 1, y: -1}, {x: 2, y: -1}, {x: 3, y: -1}, {x: -1, y: 3}, {x: 0, y: 3}, {x: 1, y: 3}, {x: 2, y: 3}, {x: 3, y: 3}],
		onlyThisRamp: [{x: -1, y: 0}, {x: -1, y: 1}, {x: -1, y: 2}, {x: 3, y: 0}, {x: 3, y: 1}, {x: 3, y: 2}],
		sameLevel: [{x: 0, y: 3}, {x: 1, y: 3}, {x: 2, y: 3}]
	},
	
	{
		map: [{x: 0, y: 0}, {x: 1, y: 0}, {x: 2, y: 0, cliff: true}, {x: 0, y: 1}, {x: 1, y: 1}, {x: 2, y: 1, cliff: true}, {x: 0, y: 2}, {x: 1, y: 2}, {x: 2, y: 2, cliff: true}],
		vec: {x: -1, y: 0},
		code: "W",
		cliffs: [{x: -1, y: -1, cliff: ramp_tiles[5]}, {x: -1, y: 1, cliff: ramp_tiles[6]}],
		texture: {tiles: [ramp_tiles[7], ramp_tiles[8], ramp_tiles[9]], initX: -1, initY: -1, loopX: 0, loopY: 1, drawX: 0.3, drawY: -0.2},
		noRamps: [{x: -1, y: -1}, {x: -1, y: 0}, {x: -1, y: 1}, {x: -1, y: 2}, {x: -1, y: 3}, {x: 3, y: -1}, {x: 3, y: 0}, {x: 3, y: 1}, {x: 3, y: 2}, {x: 3, y: 3}],
		onlyThisRamp: [{x: 0, y: -1}, {x: 1, y: -1}, {x: 2, y: -1}, {x: 0, y: 3}, {x: 1, y: 3}, {x: 2, y: 3}],
		sameLevel: [{x: -1, y: 0}, {x: -1, y: 1}, {x: -1, y: 2}]
	},
	
	{
		map: [{x: 0, y: 0, cliff: true}, {x: 1, y: 0}, {x: 2, y: 0}, {x: 0, y: 1, cliff: true}, {x: 1, y: 1}, {x: 2, y: 1}, {x: 0, y: 2, cliff: true}, {x: 1, y: 2}, {x: 2, y: 2}],
		vec: {x: 1, y: 0},
		code: "E",
		cliffs: [{x: -1, y: -1, cliff: ramp_tiles[10]}, {x: -1, y: 1, cliff: ramp_tiles[11]}],
		texture: {tiles: [ramp_tiles[12], ramp_tiles[13], ramp_tiles[14]], initX: -1, initY: -1, loopX: 0, loopY: 1, drawX: 0.5, drawY: -0.2},
		noRamps: [{x: -1, y: -1}, {x: -1, y: 0}, {x: -1, y: 1}, {x: -1, y: 2}, {x: -1, y: 3}, {x: 3, y: -1}, {x: 3, y: 0}, {x: 3, y: 1}, {x: 3, y: 2}, {x: 3, y: 3}],
		onlyThisRamp: [{x: 0, y: -1}, {x: 1, y: -1}, {x: 2, y: -1}, {x: 0, y: 3}, {x: 1, y: 3}, {x: 2, y: 3}],
		sameLevel: [{x: 3, y: 0}, {x: 3, y: 1}, {x: 3, y: 2}]
	},
	
	{
		map: [{x: 0, y: 0}, {x: 1, y: 0}, {x: 2, y: 0}, {x: 0, y: 1}, {x: 1, y: 1}, {x: 2, y: 1}, {x: 0, y: 2, cliff: true}, {x: 1, y: 2, cliff: true}, {x: 2, y: 2, cliff: true}],
		vec: {x: 0, y: -1},
		code: "N",
		cliffs: [{x: -1, y: -1, cliff: ramp_tiles[15]}, {x: 1, y: -1, cliff: ramp_tiles[16]}],
		texture: {tiles: [ramp_tiles[17], ramp_tiles[18], ramp_tiles[19]], initX: -1, initY: -1, loopX: 1, loopY: 0, drawX: 0.5, drawY: -0.2},
		noRamps: [{x: -1, y: -1}, {x: 0, y: -1}, {x: 1, y: -1}, {x: 2, y: -1}, {x: 3, y: -1}, {x: -1, y: 3}, {x: 0, y: 3}, {x: 1, y: 3}, {x: 2, y: 3}, {x: 3, y: 3}],
		onlyThisRamp: [{x: -1, y: 0}, {x: -1, y: 1}, {x: -1, y: 2}, {x: 3, y: 0}, {x: 3, y: 1}, {x: 3, y: 2}],
		sameLevel: [{x: 0, y: -1}, {x: 1, y: -1}, {x: 2, y: -1}]
		
	}
	
];

var ramps_egypt = [

	{
		map: [{x: 0, y: 0, cliff: true}, {x: 1, y: 0, cliff: true}, {x: 2, y: 0, cliff: true}, {x: 0, y: 1}, {x: 1, y: 1}, {x: 2, y: 1}, {x: 0, y: 2}, {x: 1, y: 2}, {x: 2, y: 2}],
		vec: {x: 0, y: 1},
		code: "S",
		cliffs: [{x: -1, y: -1, cliff: ramp_tiles_egypt[0]}, {x: 1, y: -1, cliff: ramp_tiles_egypt[1]}],
		texture: {tiles: [ramp_tiles_egypt[2], ramp_tiles_egypt[3], ramp_tiles_egypt[4]], initX: -1, initY: -1, loopX: 1, loopY: 0, drawX: 0.5, drawY: -0.3},
		noRamps: [{x: -1, y: -1}, {x: 0, y: -1}, {x: 1, y: -1}, {x: 2, y: -1}, {x: 3, y: -1}, {x: -1, y: 3}, {x: 0, y: 3}, {x: 1, y: 3}, {x: 2, y: 3}, {x: 3, y: 3}],
		onlyThisRamp: [{x: -1, y: 0}, {x: -1, y: 1}, {x: -1, y: 2}, {x: 3, y: 0}, {x: 3, y: 1}, {x: 3, y: 2}],
		sameLevel: [{x: 0, y: 3}, {x: 1, y: 3}, {x: 2, y: 3}]
	},
	
	{
		map: [{x: 0, y: 0}, {x: 1, y: 0}, {x: 2, y: 0, cliff: true}, {x: 0, y: 1}, {x: 1, y: 1}, {x: 2, y: 1, cliff: true}, {x: 0, y: 2}, {x: 1, y: 2}, {x: 2, y: 2, cliff: true}],
		vec: {x: -1, y: 0},
		code: "W",
		cliffs: [{x: -1, y: -1, cliff: ramp_tiles_egypt[5]}, {x: -1, y: 1, cliff: ramp_tiles_egypt[6]}],
		texture: {tiles: [ramp_tiles_egypt[7], ramp_tiles_egypt[8], ramp_tiles_egypt[9]], initX: -1, initY: -1, loopX: 0, loopY: 1, drawX: 0.3, drawY: -0.2},
		noRamps: [{x: -1, y: -1}, {x: -1, y: 0}, {x: -1, y: 1}, {x: -1, y: 2}, {x: -1, y: 3}, {x: 3, y: -1}, {x: 3, y: 0}, {x: 3, y: 1}, {x: 3, y: 2}, {x: 3, y: 3}],
		onlyThisRamp: [{x: 0, y: -1}, {x: 1, y: -1}, {x: 2, y: -1}, {x: 0, y: 3}, {x: 1, y: 3}, {x: 2, y: 3}],
		sameLevel: [{x: -1, y: 0}, {x: -1, y: 1}, {x: -1, y: 2}]
	},
	
	{
		map: [{x: 0, y: 0, cliff: true}, {x: 1, y: 0}, {x: 2, y: 0}, {x: 0, y: 1, cliff: true}, {x: 1, y: 1}, {x: 2, y: 1}, {x: 0, y: 2, cliff: true}, {x: 1, y: 2}, {x: 2, y: 2}],
		vec: {x: 1, y: 0},
		code: "E",
		cliffs: [{x: -1, y: -1, cliff: ramp_tiles_egypt[10]}, {x: -1, y: 1, cliff: ramp_tiles_egypt[11]}],
		texture: {tiles: [ramp_tiles_egypt[12], ramp_tiles_egypt[13], ramp_tiles_egypt[14]], initX: -1, initY: -1, loopX: 0, loopY: 1, drawX: 0.5, drawY: -0.2},
		noRamps: [{x: -1, y: -1}, {x: -1, y: 0}, {x: -1, y: 1}, {x: -1, y: 2}, {x: -1, y: 3}, {x: 3, y: -1}, {x: 3, y: 0}, {x: 3, y: 1}, {x: 3, y: 2}, {x: 3, y: 3}],
		onlyThisRamp: [{x: 0, y: -1}, {x: 1, y: -1}, {x: 2, y: -1}, {x: 0, y: 3}, {x: 1, y: 3}, {x: 2, y: 3}],
		sameLevel: [{x: 3, y: 0}, {x: 3, y: 1}, {x: 3, y: 2}]
	},
	
	{
		map: [{x: 0, y: 0}, {x: 1, y: 0}, {x: 2, y: 0}, {x: 0, y: 1}, {x: 1, y: 1}, {x: 2, y: 1}, {x: 0, y: 2, cliff: true}, {x: 1, y: 2, cliff: true}, {x: 2, y: 2, cliff: true}],
		vec: {x: 0, y: -1},
		code: "N",
		cliffs: [{x: -1, y: -1, cliff: ramp_tiles_egypt[15]}, {x: 1, y: -1, cliff: ramp_tiles_egypt[16]}],
		texture: {tiles: [ramp_tiles_egypt[17], ramp_tiles_egypt[18], ramp_tiles_egypt[19]], initX: -1, initY: -1, loopX: 1, loopY: 0, drawX: 0.5, drawY: -0.2},
		noRamps: [{x: -1, y: -1}, {x: 0, y: -1}, {x: 1, y: -1}, {x: 2, y: -1}, {x: 3, y: -1}, {x: -1, y: 3}, {x: 0, y: 3}, {x: 1, y: 3}, {x: 2, y: 3}, {x: 3, y: 3}],
		onlyThisRamp: [{x: -1, y: 0}, {x: -1, y: 1}, {x: -1, y: 2}, {x: 3, y: 0}, {x: 3, y: 1}, {x: 3, y: 2}],
		sameLevel: [{x: 0, y: -1}, {x: 1, y: -1}, {x: 2, y: -1}]
	}
	
];

var ramps_grave = [

	{
		map: [{x: 0, y: 0, cliff: true}, {x: 1, y: 0, cliff: true}, {x: 2, y: 0, cliff: true}, {x: 0, y: 1}, {x: 1, y: 1}, {x: 2, y: 1}, {x: 0, y: 2}, {x: 1, y: 2}, {x: 2, y: 2}],
		vec: {x: 0, y: 1},
		code: "S",
		cliffs: [{x: -1, y: -1, cliff: ramp_tiles_grave[0]}, {x: 1, y: -1, cliff: ramp_tiles_grave[1]}],
		texture: {tiles: [ramp_tiles_grave[2], ramp_tiles_grave[3], ramp_tiles_grave[4]], initX: -1, initY: -1, loopX: 1, loopY: 0, drawX: 0.5, drawY: -0.3},
		noRamps: [{x: -1, y: -1}, {x: 0, y: -1}, {x: 1, y: -1}, {x: 2, y: -1}, {x: 3, y: -1}, {x: -1, y: 3}, {x: 0, y: 3}, {x: 1, y: 3}, {x: 2, y: 3}, {x: 3, y: 3}],
		onlyThisRamp: [{x: -1, y: 0}, {x: -1, y: 1}, {x: -1, y: 2}, {x: 3, y: 0}, {x: 3, y: 1}, {x: 3, y: 2}],
		sameLevel: [{x: 0, y: 3}, {x: 1, y: 3}, {x: 2, y: 3}]
	},
	
	{
		map: [{x: 0, y: 0}, {x: 1, y: 0}, {x: 2, y: 0, cliff: true}, {x: 0, y: 1}, {x: 1, y: 1}, {x: 2, y: 1, cliff: true}, {x: 0, y: 2}, {x: 1, y: 2}, {x: 2, y: 2, cliff: true}],
		vec: {x: -1, y: 0},
		code: "W",
		cliffs: [{x: -1, y: -1, cliff: ramp_tiles_grave[5]}, {x: -1, y: 1, cliff: ramp_tiles_grave[6]}],
		texture: {tiles: [ramp_tiles_grave[7], ramp_tiles_grave[8], ramp_tiles_grave[9]], initX: -1, initY: -1, loopX: 0, loopY: 1, drawX: 0.3, drawY: -0.2},
		noRamps: [{x: -1, y: -1}, {x: -1, y: 0}, {x: -1, y: 1}, {x: -1, y: 2}, {x: -1, y: 3}, {x: 3, y: -1}, {x: 3, y: 0}, {x: 3, y: 1}, {x: 3, y: 2}, {x: 3, y: 3}],
		onlyThisRamp: [{x: 0, y: -1}, {x: 1, y: -1}, {x: 2, y: -1}, {x: 0, y: 3}, {x: 1, y: 3}, {x: 2, y: 3}],
		sameLevel: [{x: -1, y: 0}, {x: -1, y: 1}, {x: -1, y: 2}]
	},
	
	{
		map: [{x: 0, y: 0, cliff: true}, {x: 1, y: 0}, {x: 2, y: 0}, {x: 0, y: 1, cliff: true}, {x: 1, y: 1}, {x: 2, y: 1}, {x: 0, y: 2, cliff: true}, {x: 1, y: 2}, {x: 2, y: 2}],
		vec: {x: 1, y: 0},
		code: "E",
		cliffs: [{x: -1, y: -1, cliff: ramp_tiles_grave[10]}, {x: -1, y: 1, cliff: ramp_tiles_grave[11]}],
		texture: {tiles: [ramp_tiles_grave[12], ramp_tiles_grave[13], ramp_tiles_grave[14]], initX: -1, initY: -1, loopX: 0, loopY: 1, drawX: 0.5, drawY: -0.2},
		noRamps: [{x: -1, y: -1}, {x: -1, y: 0}, {x: -1, y: 1}, {x: -1, y: 2}, {x: -1, y: 3}, {x: 3, y: -1}, {x: 3, y: 0}, {x: 3, y: 1}, {x: 3, y: 2}, {x: 3, y: 3}],
		onlyThisRamp: [{x: 0, y: -1}, {x: 1, y: -1}, {x: 2, y: -1}, {x: 0, y: 3}, {x: 1, y: 3}, {x: 2, y: 3}],
		sameLevel: [{x: 3, y: 0}, {x: 3, y: 1}, {x: 3, y: 2}]
	},
	
	{
		map: [{x: 0, y: 0}, {x: 1, y: 0}, {x: 2, y: 0}, {x: 0, y: 1}, {x: 1, y: 1}, {x: 2, y: 1}, {x: 0, y: 2, cliff: true}, {x: 1, y: 2, cliff: true}, {x: 2, y: 2, cliff: true}],
		vec: {x: 0, y: -1},
		code: "N",
		cliffs: [{x: -1, y: -1, cliff: ramp_tiles_grave[15]}, {x: 1, y: -1, cliff: ramp_tiles_grave[16]}],
		texture: {tiles: [ramp_tiles_grave[17], ramp_tiles_grave[18], ramp_tiles_grave[19]], initX: -1, initY: -1, loopX: 1, loopY: 0, drawX: 0.5, drawY: -0.2},
		noRamps: [{x: -1, y: -1}, {x: 0, y: -1}, {x: 1, y: -1}, {x: 2, y: -1}, {x: 3, y: -1}, {x: -1, y: 3}, {x: 0, y: 3}, {x: 1, y: 3}, {x: 2, y: 3}, {x: 3, y: 3}],
		onlyThisRamp: [{x: -1, y: 0}, {x: -1, y: 1}, {x: -1, y: 2}, {x: 3, y: 0}, {x: 3, y: 1}, {x: 3, y: 2}],
		sameLevel: [{x: 0, y: -1}, {x: 1, y: -1}, {x: 2, y: -1}]
	}
	
];




// Map Themes
var mapThemes = [
	
	{
		name: "Grass",
		defaultTiles: ["Ground n 6", "Ground n 7", "Ground n 8", "Ground n 5", "Ground n 1", "Ground n 2", "Ground n 3", "Ground n 4"],
		particleColor: "rgba(255, 255, 100, 0.4)",
		countDots: 150,
		line_red: 255,
		line_green: 255,
		line_blue: 255,
		cliffs: cliffs,
		ramps: ramps,
		arrowColor: "white"
	},
	
	{
		name: "Snow",
		defaultTiles: ["Snow 1", "Snow 2", "Snow 3", "Snow 4"],
		particleColor: "rgba(255, 255, 255, 0.8)",
		countDots: 200,
		alpha: 0.8,
		line_red: 0,
		line_green: 255,
		line_blue: 0,
		cliffs: cliffs_winter,
		ramps: ramps,
		arrowColor: "black"
	},
	
	{
		name: "Egypt",
		defaultTiles: ["Egypt Ground 1", "Egypt Ground 2", "Egypt Ground 3", "Egypt Ground 4", "Egypt Ground 5", "Egypt Ground 6"],
		particleColor: "rgba(255, 255, 100, 0.8)",
		countDots: 0,
		line_red: 255,
		line_green: 255,
		line_blue: 255,
		cliffs: egypt_cliffs,
		ramps: ramps_egypt,
		arrowColor: "white"
	},
	
	{
		name: "Graveyard",
		defaultTiles: ["Grave Ground 1", "Grave Ground 2", "Grave Ground 3", "Grave Ground 4", "Grave Ground 5", "Grave Ground 6"],
		particleColor: "rgba(255, 255, 255, 0.8)",
		countDots: 100,
		line_red: 0,
		line_green: 255,
		line_blue: 0,
		cliffs: grave_cliffs,
		ramps: ramps_grave,
		arrowColor: "white"
	}
	
];






var list_attack_effects = {
	none: null,
	arrow: "arrow",
	mageAttack: "mageAttack",
	launchedRock: "launchedRock",
	dragonAttack: "dragonAttack",
	ballistaAttack: "ballista",
	flamestrike: "flamestrike",
	heal: "heal",
	smoke: "smoke",
	aura: "aura",
	spell: "spell"
};








var unit_fields = [
	
	{
		name: "name",
		type: "string",
		max_len: 30,
		min_len: 1,
		description: "The units name",
		default_: "new_unit",
		logic: true
	},
	
	{
		name: "hp",
		type: "integer",
		min_val: 1,
		max_val: 99999999,
		description: "The max amount of hit points this unit has.",
		default_: 100,
		logic: true
	},
	
	{
		name: "startHp",
		type: "integer",
		min_val: 0,
		max_val: 99999999,
		description: "The amount of hit points this unit has when it spanws. 0 for max.",
		default_: 0,
		logic: true
	},
	
	{
		name: "mana",
		type: "integer",
		min_val: 0,
		max_val: 99999999,
		description: "The amount of mana this unit has.",
		default_: 0,
		logic: true
	},
	
	{
		name: "startMana",
		type: "integer",
		min_val: 0,
		max_val: 99999999,
		description: "The amount of starting mana this unit has.",
		default_: 0,
		logic: true
	},
	
	{
		name: "hpRegenerationRate",
		type: "float",
		min_val: -99999999,
		max_val: 99999999,
		description: "The amount of hit points this unit regenerates per sec.",
		default_: 0,
		logic: true,
		displayScale: 20
	},
	
	{
		name: "manaRegenerationRate",
		type: "float",
		min_val: -99999999,
		max_val: 99999999,
		description: "The amount of mana this unit regenerates per sec.",
		default_: 0,
		logic: true,
		displayScale: 20
	},
	
	{
		name: "armor",
		type: "float",
		min_val: 0,
		max_val: 99999999,
		description: "The armor this unit has. 1 armor reduces all incoming damage by 1.",
		default_: 0,
		logic: true
	},
	
	{
		name: "supply",
		type: "integer",
		min_val: 0,
		max_val: 99999999,
		description: "The amount of supply this unit uses.",
		default_: 1,
		logic: true
	},
	
	{
		name: "supplyProvided",
		type: "integer",
		min_val: 0,
		max_val: 99999999,
		description: "The amount of supply this unit prodives.",
		default_: 0,
		logic: true
	},
	
	{
		name: "movementSpeed",
		type: "float",
		min_val: 0,
		max_val: 6.0,
		description: "The movement speed of the unit.",
		default_: 0.1,
		logic: true,
		displayScale: 20
	},
	
	{
		name: "weaponCooldown",
		type: "float",
		min_val: 0.1,
		max_val: 99999999,
		description: "The time it takes for this unit to fire again when it just fired.",
		default_: 20,
		logic: true,
		displayScale: 1 / 20
	},
	
	{
		name: "weaponDelay",
		type: "float",
		min_val: 0,
		max_val: 99999999,
		description: "The time it takes for this unit to actually fire when an attack is initiated.",
		default_: 20,
		logic: true,
		displayScale: 1 / 20
	},
	
	{
		name: "dmg",
		type: "float",
		min_val: 0,
		max_val: 99999999,
		description: "The damage this unit does with one attack.",
		default_: 10,
		logic: true
	},
	
	{
		name: "dmgModifierAttributes",
		type: "selection",
		description: "The filter that target unit has to meet for the damage modifiers to be applied",
		isArray: true,
		values: targetFilters1,
		default_: "isHuman",
		default2_: [],
		logic: true,
		group: "dmgModifiers",
		subName: "filter",
		groupDescription: "The unit can have different damage for different types of units, for example it can do +3 damage vs mechanical units, or it can do +50% vs flying units."
	},
	
	{
		name: "dmgModifierAddition",
		type: "float",
		min_val: -999999,
		max_val: 9999999,
		description: "This value will be added to the damage value, if it meets the filter atribute.",
		default_: 0,
		default2_: [],
		isArray: true,
		logic: true,
		group: "dmgModifiers",
		subName: "add",
		groupDescription: "The unit can have different damage for different types of units, for example it can do +3 damage vs mechanical units, or it can do +50% vs flying units."
	},
	
	{
		name: "dmgModifierMultiplier",
		type: "float",
		min_val: -999999,
		max_val: 9999999,
		description: "The damage value will be multiplied with this value, if it meets the filter atributes.",
		default_: 1,
		default2_: [],
		isArray: true,
		logic: true,
		group: "dmgModifiers",
		subName: "multiply",
		groupDescription: "The unit can have different damage for different types of units, for example it can do +3 damage vs mechanical units, or it can do +50% vs flying units."
	},
	
	{
		name: "lifesteal",
		type: "float",
		min_val: -99999999,
		max_val: 99999999,
		description: "The % of the damage this unit gets as HP when dealing dmg (0.5 means it gets half the dmg it deals as HP).",
		default_: 0,
		logic: true
	},
	
	{
		name: "armorPenetration",
		type: "float",
		min_val: 0,
		max_val: 99999999,
		description: "The amount of armor this unit ignores when dealing damage.",
		default_: 0,
		logic: true
	},
	
	{
		name: "percDmg",
		type: "float",
		min_val: -1,
		max_val: 1,
		description: "The percentual damage this unit does. For example 0.2 means it does 20% (of target max hp) dmg.",
		default_: 0,
		logic: true
	},
	
	{
		name: "dmgCap",
		type: "float",
		min_val: 0,
		max_val: 99999999,
		description: "The min possible value this units damage can be after applying the defenders armor. If you set this to 2 for example, the damage will always be at least 2, even if the defenders armor would reduce to less than 2 normally.",
		default_: 1,
		logic: true
	},
	
	{
		name: "bouncePower",
		type: "float",
		min_val: 0.0,
		max_val: 99.0,
		description: "If this is set to higher than 0, this unit will smash target units back when attacking them. It only affects units with power less than this bouncePower.",
		default_: 0,
		logic: true
	},
	
	{
		name: "bounceDistMin",
		type: "float",
		min_val: 0.0,
		max_val: 99.0,
		description: "The min range of how far this unit smashes target units back.",
		default_: 0,
		logic: true
	},
	
	{
		name: "bounceDistMax",
		type: "float",
		min_val: 0.0,
		max_val: 99.0,
		description: "The max range of how far this unit smashes target units back.",
		default_: 0,
		logic: true
	},
	
	{
		name: "range",
		type: "float",
		min_val: 0,
		max_val: 99999999,
		description: "The attack range of this unit.",
		default_: 0.2,
		logic: true
	},
	
	{
		name: "minRange",
		type: "float",
		min_val: -999,
		max_val: 999,
		description: "The minimum attack range of this unit. Other units close that this can not be attacked. Set to -1 for no min attack range",
		default_: -999,
		logic: true
	},
	
	{
		name: "aoeRadius",
		type: "float",
		min_val: 0,
		max_val: 99999999,
		description: "If this is bigger than 0, the unit will deal aoe damage (= area of effect). That means not only the target unit takes damage, but all units in range of the target unit.",
		default_: 0,
		logic: true
	},
	
	{
		name: "attackPrio",
		type: "float",
		min_val: -99999,
		max_val: 999999,
		description: "Units with higher attack prios get attacked first.",
		default_: 10,
		logic: true
	},
	
	{
		name: "size",
		type: "float",
		min_val: 0,
		max_val: 12.0,
		description: "The size of the unit (= diameter). This determinates when a unit collides with other units or map objects. Ground units with a size bigger than 2 might cause pathing problems.",
		default_: 0.9,
		logic: true
	},
	
	{
		name: "imageScale",
		type: "float",
		min_val: 0.1,
		max_val: 10,
		description: "If you put another value than 1, the image will be scaled, so the unit becomes bigger or smaller (only visual, no gameplay effect).",
		default_: 1
	},
	
	{
		name: "vision",
		type: "float",
		min_val: -1,
		max_val: 20,
		description: "The vision range of the unit.",
		default_: 7,
		logic: true
	},
	
	{
		name: "repairRate",
		type: "float",
		min_val: 0,
		max_val: 99999999,
		description: "The amount of HP this unit restores when repairing (per sec).",
		default_: 0,
		logic: true,
		displayScale: 20
	},
	
	{
		name: "repairCost",
		type: "float",
		min_val: 0,
		max_val: 99999999,
		description: "The amount of gold it costs when repairing (per sec).",
		default_: 0,
		logic: true,
		displayScale: 20
	},
	
	{
		name: "projectileSpeed",
		type: "float",
		min_val: 0.02,
		max_val: 99999999,
		description: "Only relevant if this is a ranged unit. The speed which the projectile travels.",
		default_: 8,
		logic: true
	},
	
	{
		name: "projectileLen",
		type: "float",
		min_val: 0.02,
		max_val: 10,
		description: "Only relevant if this is a ranged unit with basic arrow projectiles. The length of the projectile.",
		default_: 0.2
	},
	
	{
		name: "attackLaunchSound",
		type: "selection",
		values: SOUND,
		description: "The sound that plays when this unit attacks.",
		default_: SOUND.NONE,
		logic: true
	},
	
	{
		name: "circleSize",
		type: "float",
		min_val: 0.02,
		max_val: 20,
		description: "The size of the selection circle of this unit.",
		default_: 0.43
	},
	
	{
		name: "circleOffset",
		type: "float",
		min_val: -99,
		max_val: 99,
		description: "The y offset of the cirle of this unit (only a visual thing).",
		default_: 0.125
	},
	
	{
		name: "buildTime",
		type: "float",
		min_val: 0,
		max_val: 99999999,
		description: "The time it takes to build this unit.",
		default_: 30,
		logic: true,
		displayScale: 1 / 20
	},
	
	{
		name: "cost",
		type: "float",
		min_val: 0,
		max_val: 99999999,
		description: "The amount of gold it costs to build this unit.",
		default_: 100,
		logic: true
	},
	
	{
		name: "healthbarOffset",
		type: "float",
		min_val: -99,
		max_val: 99,
		description: "The y offset of the health bar (only a visual thing).",
		default_: 0.95
	},
	
	{
		name: "healthbarWidth",
		type: "float",
		min_val: 0.1,
		max_val: 99,
		description: "The width of the health bar.",
		default_: 0.69
	},
	
	{
		name: "selectionOffsetY",
		type: "float",
		min_val: -99,
		max_val: 99,
		description: "The y offset of where the unit should be selected.",
		default_: 0
	},
	
	{
		name: "img",
		type: "selection",
		values: lists.imgs,
		description: "The unit's image.",
		default_: lists.imgs.soldier,
		special: "imgPreview"
	},
	
	{
		name: "description",
		type: "string",
		max_len: 300,
		min_len: 0,
		description: "The description of the unit.",
		default_: ""
	},
	
	{
		name: "experienceLevels",
		type: "integer",
		min_val: 0,
		max_val: 99999999,
		description: "The amount of experience this unit needs to reach higher levels. Each value represents a level. The first value is the exp needed to reach lvl 2, the 2nd value the exp to reach lvl 3 and so on.",
		default_: 0,
		default2_: [],
		logic: true,
		isArray: true
	},
	
	{
		name: "experience",
		type: "integer",
		min_val: 0,
		max_val: 99999999,
		description: "The amount of experience this unit gives when it gets killed.",
		default_: 0,
		logic: true
	},
	
	{
		name: "modifiersPerLevel",
		type: "selection",
		values: lists.modifiers,
		description: "A list of modifiers that will be applied to this unit each time it levels up. For example you can make a modifier, that gives +1 damage and +10 HP and link it here, so the unit will get +1 dmg and +10 HP each time it levels up.",
		default_: null,
		default2_: [],
		isArray: true,
		logic: true
	},
	
	{
		name: "experienceRange",
		type: "float",
		min_val: 0,
		max_val: 99999999,
		description: "The range in which this unit collects experience from enemy dying units.",
		default_: 9.0,
		logic: true
	},
	
	{
		name: "tabPriority",
		type: "float",
		min_val: -99,
		max_val: 99,
		description: "Buttons of units with higher tab priorities will be displayed first. When selecting two different unit types and both have special abilities, then the buttons of the unit with higher tab priority will be displayed.",
		default_: 5
	},
	
	{
		name: "drawOffsetY",
		type: "float",
		min_val: -99,
		max_val: 99,
		description: "Y offset of the unit when drawn.",
		default_: 6
	},
	
	{
		name: "attackEffect",
		type: "selection",
		description: "The effect, that shows when this unit is attacking (only relevant for ranged units).",
		values: list_attack_effects,
		default_: null,
		logic: true
	},
	
	{
		name: "painSound",
		type: "selection",
		values: SOUND,
		description: "A number of sounds that will be played when this unit gets hit.",
		default_: SOUND.NONE,
		logic: true
	},
	
	{
		name: "painSoundVolume",
		type: "float",
		max_val: 1,
		min_val: 0,
		description: "Volume 1 => 100%",
		default_: 1,
		logic: true
	},
	
	{
		name: "painSound2",
		type: "selection",
		values: SOUND,
		description: "A 2nd pain sound, in case 2 are needed.",
		default_: SOUND.NONE,
		logic: true
	},
	
	{
		name: "painSoundVolume2",
		type: "float",
		max_val: 1,
		min_val: 0,
		description: "Volume 1 => 100%",
		default_: 1,
		logic: true
	},
	
	{
		name: "deathSound",
		type: "selection",
		values: SOUND,
		description: "The sound that will be played when this unit dies.",
		default_: SOUND.NONE,
		logic: true
	},
	
	{
		name: "yesSound",
		type: "selection",
		values: SOUND,
		description: "The sound that will be played when this unit gets an order.",
		default_: SOUND.YES,
		logic: true
	},
	
	
	{
		name: "yesSoundVolume",
		type: "float",
		max_val: 1,
		min_val: 0,
		description: "Volume 1 => 100%",
		default_: 0.6,
		logic: true
	},
	
	{
		name: "readySound",
		type: "selection",
		values: SOUND,
		description: "The sound that will be played when this unit spawns.",
		default_: SOUND.READY,
		logic: true
	},
	
	{
		name: "readySoundVolume",
		type: "float",
		max_val: 1,
		min_val: 0,
		description: "The sound that will be played when this unit spawns.",
		default_: 0.9,
		logic: true
	},
	
	{
		name: "bodyPower",
		type: "float",
		min_val: -99,
		max_val: 99,
		description: "This represents the power that a target unit will be pushed when killed by this unit. A higher value means a unit killed by this unit will be pushed back very far when killed.",
		default_: 0.8,
		logic: true
	},
	
	{
		name: "dustCreationChance",
		type: "float",
		min_val: -20,
		max_val: 5,
		description: "The average dust particles this unit creates per sec. Put -1 for no dust creation at all (for example for flying units).",
		default_: 0.05,
		displayScale: 20
	},
	
	{
		name: "visionHeightBonus",
		type: "integer",
		min_val: 0,
		max_val: 99,
		description: "Usually units can not look at higher grounds. With this value set they can look up X cliff levels. A unit being on height level 1 and having a visionHeightBonus of 1 can see height level 2, but not 3.",
		default_: 0,
		logic: true
	},
	
	{
		name: "animSpeed",
		type: "float",
		min_val: 0.1,
		max_val: 99,
		description: "The speed in which the animations for this unit will be played.",
		default_: 1.5
	},
	
	{
		name: "oscillationAmplitude",
		type: "float",
		min_val: 0,
		max_val: 99,
		description: "The determinated how fast a unit is moved up and down (only visual, no gameplay effect). Usually you want this only for flying units. To not have this effect, set to 0",
		default_: 0
	},
	
	{
		name: "height",
		type: "float",
		min_val: -99,
		max_val: 99,
		description: "This is only a visual thing. This value will be used when this unit gets shot with a projectile. The projectile will hit at a higher point when the height value is higher.",
		default_: 0.3
	},
	
	{
		name: "acceleration",
		type: "float",
		min_val: 0,
		max_val: 99,
		description: "Units with an acceleration dont start moving at their full speed. They also need some time to stop or change directions. Usually this is used for flying units. Set this to 0, if you dont want any acceleration.",
		default_: 0,
		logic: true
	},
	
	{
		name: "angularVelocity",
		type: "float",
		min_val: 0,
		max_val: 1,
		description: "Units with an angular velocity take curves instead of immediately changing their angle when moving and changing their direction. Set this to 0, if you dont want any acceleration.",
		default_: 0,
		logic: true
	},
	
	{
		name: "commands",
		type: "commands",
		isObject: true,
		description: "Here are all the abilites stored, that this unit can execute.",
		logic: true
	},
	
	{
		name: "cargoUse",
		type: "integer",
		min_val: -1,
		max_val: 100,
		description: "How much space in a transport unit this unit takes. Cargo space -1 means this unit is not loadable",
		default_: -1,
		logic: true
	},
	
	{
		name: "cargoSpace",
		type: "integer",
		min_val: 0,
		max_val: 99999,
		description: "How much space this unit can carry.",
		default_: 0,
		logic: true
	},
	
	{
		name: "projectileStartHeight",
		type: "float",
		min_val: -99,
		max_val: 99,
		description: "The (only visual) height of projectiles that this unit shoots.",
		default_: 0
	},
	
	{
		name: "power",
		type: "float",
		min_val: 0,
		max_val: 99,
		description: "The smash effect has a bouncePower value. If that value is higher than this units power value, then it gets smashed back.",
		default_: 0,
		logic: true
	},
	
	{
		name: "lifetime",
		type: "float",
		min_val: 0,
		max_val: 999999,
		description: "When this is bigger than 0, the unit will only live for a certain amount of time.",
		default_: 0,
		logic: true,
		displayScale: 1 / 20
	},
	
	{
		name: "goldReward",
		type: "integer",
		min_val: -999999,
		max_val: 999999,
		description: "If this is bigger than 0, a player who kills this unit will get gold rewarded according to this value.",
		default_: 0,
		logic: true
	},
	
	{
		name: "limit",
		type: "integer",
		min_val: 0,
		max_val: 999999,
		description: "Set this to a number bigger than 0 to limit the amount of instances of this building a player can make.",
		default_: 0,
		logic: true
	},
	
	{
		name: "modifiers",
		type: "selection",
		isArray: true,
		values: lists.modifiers,
		description: "Modifiers this unit applies to other units when attacking them.",
		default_: null,
		default2_: [],
		logic: true
	},
	
	{
		name: "modifiersSelf",
		type: "selection",
		isArray: true,
		values: lists.modifiers,
		description: "Modifiers this unit applies to ITSELF when attacking (other units).",
		default_: null,
		default2_: [],
		logic: true
	},
	
	{
		name: "spawnModifiers",
		type: "selection",
		isArray: true,
		values: lists.modifiers,
		description: "The modifiers this unit gets when it spawns.",
		default_: null,
		default2_: [],
		logic: true
	},
	
	{
		name: "hoverText",
		type: "string",
		min_len: 0,
		max_len: 1000,
		description: "If you enter a text here, it will be displayed instead of the owners' name when hovering this unit.",
		default_: ""
	},
	
	{
		name: "canHaveWaypoint",
		type: "bool",
		description: "If this is true, this unit can set a waypoint (waypoints are used to tell spawning units where to go, so this usually makes sense if this unit can produce units)",
		default_: false,
		logic: true
	},
	
	{
		name: "isPassive",
		type: "bool",
		description: "Passive units dont attack on their own.",
		default_: false,
		logic: true
	},
	
	{
		name: "causesFlameDeath",
		type: "bool",
		description: "If this is true, then units killed by this unit will burn for some seconds (only visual, no gameplay effect).",
		default_: false
	},
	
	{
		name: "shootingReveals",
		type: "bool",
		description: "If this is true, then this unit will be visible for a short amount of time for the other player when it attacks.",
		default_: false,
		logic: true
	},
	
	{
		name: "shootWhileMoving",
		type: "bool",
		description: "Determinates if this unit can attack while it moves.",
		default_: false,
		logic: true
	},
	
	{
		name: "hitscan",
		type: "bool",
		description: "Units that use hitscan, can not shoot through other units or obstacles, but need to have free space between them and their target in order to be able to shoot it. Their projectiles also can be intercepted if something moves in their way.",
		default_: false,
		logic: true
	},
	
	{
		name: "maximizeRangeWhenShooting",
		type: "bool",
		description: "Always shoot at max range. Only works on not heatseeking units. Makes sense on hitscan units.",
		default_: false,
		logic: true
	},
	
	{
		name: "hitsFriendly",
		type: "bool",
		description: "Determinates if this unit attack affects friendly units (only relevant on aoe abilities).",
		default_: true,
		logic: true
	},
	
	{
		name: "hitsEnemy",
		type: "bool",
		description: "Determinates if this unit attack affects enemy units (only relevant on aoe abilities).",
		default_: true,
		logic: true
	},
	
	{
		name: "canAttackGround",
		type: "bool",
		description: "Is the unit able to attack ground units ?",
		default_: true,
		logic: true
	},
	
	{
		name: "canAttackFlying",
		type: "bool",
		description: "Determinates if this unit can attack flying units.",
		default_: false,
		logic: true
	},
	
	{
		name: "isHeatSeeking",
		type: "bool",
		description: "If this is false, hits by this unit can miss and will hit where the target unit was, what the attack was started.",
		default_: true,
		logic: true
	},
	
	{
		name: "ignoreEnemyHitscan",
		type: "bool",
		description: "If this is true, the unit will be shootable for enemy units, that use hitscan, even if something is in the way. Makes sense for example on air units.",
		default_: false,
		logic: true
	},
	
	{
		name: "controllable",
		type: "bool",
		description: "If this is false, the unit can not be controlled by the player.",
		default_: true,
		logic: true
	},
	
	{
		name: "hasDetection",
		type: "bool",
		description: "If its true, this unit can detect invisible units.",
		default_: false,
		logic: true
	},
	
	{
		name: "expOnlyFromOwnKills",
		type: "bool",
		description: "If true, this unit gets only experience when it actually kills a unit itself, but not when its just in range when an enemy unit is killed by another allied unit.",
		default_: false,
		logic: true
	},
	
	{
		name: "alliesGetExperience",
		type: "bool",
		description: "If true, allied units get experience when killing this unit.",
		default_: false,
		logic: true
	},
	
	{
		name: "alliesGetGold",
		type: "bool",
		description: "If true, allied units get gold reward when killing this unit.",
		default_: false,
		logic: true
	},
	
	{
		name: "isReflectingProjectiles",
		type: "bool",
		description: "If this is true, this unit reflects projectiles that would hit it otherwise. Only affects projectiles that deal damage while flying.",
		default_: false,
		logic: true
	},
	
	{
		name: "isBlockingProjectiles",
		type: "bool",
		description: "If this is true, this unit blocks (kills) projectiles that would hit it otherwise. Only affects projectiles that deal damage while flying.",
		default_: false,
		logic: true
	},
	
	{
		name: "takeDamageOnBlock",
		type: "bool",
		description: "If this unit blocks or reflects a projectile, this field determinates if it is taking damage from the projectile.",
		default_: false,
		logic: true
	},
	
	{
		name: "preventsLoss",
		type: "bool",
		description: "If a player has no buildings or units that prevent losing, he will be eliminated.",
		default_: false,
		logic: true
	},
	
	{
		name: "flying",
		type: "bool",
		description: "Make an educated guess.",
		default_: false,
		logic: true
	},
	
	{
		name: "uniqueAndHeroic",
		type: "bool",
		description: "Units that are unique &amp; heroic only exist once and can be revived when they die.",
		default_: false,
		logic: true
	},
	
	{
		name: "isMechanical",
		type: "bool",
		description: "Mechanical units can be repaired and not healed.",
		default_: false,
		logic: true
	},
	
	{
		name: "isUndead",
		type: "bool",
		description: "Undead units take damage from healing spells.",
		default_: false,
		logic: true
	},
	
	{
		name: "isBiological",
		type: "bool",
		description: "Classification for unit types. Does not have any active effects but there can be abilities that only work for certain unit types. For example the 'Heal' spell only works with biological units.",
		default_: true,
		logic: true
	},
	
	{
		name: "isBeast",
		type: "bool",
		description: "Classification for unit types. Does not have any active effects but there can be abilities that only work for certain unit types. For example the 'Heal' spell only works with biological units.",
		default_: false,
		logic: true
	},
	
	{
		name: "isHuman",
		type: "bool",
		description: "Classification for unit types. Does not have any active effects but there can be abilities that only work for certain unit types. For example the 'Heal' spell only works with biological units.",
		default_: false,
		logic: true
	},
	
	{
		name: "noShow",
		type: "bool",
		description: "If this is true, the unit will not be drawn.",
		default_: false,
		logic: true
	},
	
	{
		name: "noCollision",
		type: "bool",
		description: "If this is true, the unit will not collide with anything.",
		default_: false,
		logic: true
	},
	
	{
		name: "isInvisible",
		type: "bool",
		description: "Invisible units can only be attacked when detected.",
		default_: false,
		logic: true
	},
	
	{
		name: "isInvincible",
		type: "bool",
		description: "If this is true, the unit can not be attacked or damaged.",
		default_: false,
		logic: true
	},
	
	{
		name: "spawnWithAMove",
		type: "bool",
		description: "If this is true, units this unit produces will use AMove command when spawning to walk to the waypoint instead of normal move.",
		default_: false,
		logic: true
	}
	
];





var building_fields = [
	
	{
		name: "name",
		type: "string",
		max_len: 30,
		min_len: 1,
		description: "The buildings name",
		default_: "new_building",
		logic: true
	},
	
	{
		name: "hp",
		type: "integer",
		min_val: 1,
		max_val: 99999999,
		description: "The max amount of hit points this building has.",
		default_: 500,
		logic: true
	},
	
	{
		name: "mana",
		type: "integer",
		min_val: 0,
		max_val: 99999999,
		description: "The amount of mana this unit has.",
		default_: 0,
		logic: true
	},
	
	{
		name: "startMana",
		type: "integer",
		min_val: 0,
		max_val: 99999999,
		description: "The amount of starting mana this unit has.",
		default_: 0,
		logic: true
	},
	
	{
		name: "hpRegenerationRate",
		type: "float",
		min_val: -99999999,
		max_val: 99999999,
		description: "The amount of hit points this building regenerates per sec.",
		default_: 0,
		logic: true,
		displayScale: 20
	},
	
	{
		name: "manaRegenerationRate",
		type: "float",
		min_val: -99999999,
		max_val: 99999999,
		description: "The amount of mana this unit regenerates per sec.",
		default_: 0,
		logic: true,
		displayScale: 20
	},
	
	{
		name: "armor",
		type: "float",
		min_val: 0,
		max_val: 99999999,
		description: "The armor this building has. 1 armor reduces all incoming damage by 1.",
		default_: 1,
		logic: true
	},
	
	{
		name: "supply",
		type: "integer",
		min_val: 0,
		max_val: 99999999,
		description: "The amount of supply this unit uses.",
		default_: 0,
		logic: true
	},
	
	{
		name: "supplyProvided",
		type: "integer",
		min_val: 0,
		max_val: 99999999,
		description: "The amount of supply this unit provides.",
		default_: 0,
		logic: true
	},
	
	{
		name: "weaponCooldown",
		type: "float",
		min_val: 0.1,
		max_val: 99999999,
		description: "The time it takes for this building to fire again when it just fired.",
		default_: 20,
		logic: true,
		displayScale: 1 / 20
	},
	
	{
		name: "weaponDelay",
		type: "float",
		min_val: 0,
		max_val: 99999999,
		description: "The time it takes for this building to actually fire when an attack is initiated.",
		default_: 20,
		logic: true,
		displayScale: 1 / 20
	},
	
	{
		name: "dmg",
		type: "float",
		min_val: 0,
		max_val: 99999999,
		description: "The damage this building does with one attack.",
		default_: 10,
		logic: true
	},
	
	{
		name: "dmgModifierAttributes",
		type: "selection",
		description: "The filter that target unit has to meet for the damage modifiers to be applied",
		isArray: true,
		values: targetFilters1,
		default_: "isHuman",
		default2_: [],
		logic: true,
		group: "dmgModifiers",
		subName: "filter",
		groupDescription: "The unit can have different damage for different types of units, for example it can do +3 damage vs mechanical units, or it can do +50% vs flying units."
	},
	
	{
		name: "dmgModifierAddition",
		type: "float",
		min_val: -999999,
		max_val: 9999999,
		description: "This value will be added to the damage value, if it meets the filter atribute.",
		default_: 0,
		default2_: [],
		isArray: true,
		logic: true,
		group: "dmgModifiers",
		subName: "add",
		groupDescription: "The unit can have different damage for different types of units, for example it can do +3 damage vs mechanical units, or it can do +50% vs flying units."
	},
	
	{
		name: "dmgModifierMultiplier",
		type: "float",
		min_val: -999999,
		max_val: 9999999,
		description: "The damage value will be multiplied with this value, if it meets the filter atributes.",
		default_: 1,
		default2_: [],
		isArray: true,
		logic: true,
		group: "dmgModifiers",
		subName: "multiply",
		groupDescription: "The unit can have different damage for different types of units, for example it can do +3 damage vs mechanical units, or it can do +50% vs flying units."
	},
	
	{
		name: "lifesteal",
		type: "float",
		min_val: -99999999,
		max_val: 99999999,
		description: "The % of the damage this unit gets as HP when dealing dmg (0.5 means it gets half the dmg it deals as HP).",
		default_: 0,
		logic: true
	},
	
	{
		name: "armorPenetration",
		type: "float",
		min_val: 0,
		max_val: 99999999,
		description: "The amount of armor this unit ignores when dealing damage.",
		default_: 0,
		logic: true
	},
	
	{
		name: "percDmg",
		type: "float",
		min_val: -1,
		max_val: 1,
		description: "The percentual damage this unit does. For example 0.2 means it does 20% (of target max hp) dmg.",
		default_: 0,
		logic: true
	},
	
	{
		name: "dmgCap",
		type: "float",
		min_val: 0,
		max_val: 99999999,
		description: "The min possible value this units damage can be after applying the defenders armor. If you set this to 2 for example, the damage will always be at least 2, even if the defenders armor would reduce to less than 2 normally.",
		default_: 1,
		logic: true
	},
	
	{
		name: "range",
		type: "float",
		min_val: 0,
		max_val: 99999999,
		description: "The attack range of this building.",
		default_: 0.2,
		logic: true
	},
	
	{
		name: "minRange",
		type: "float",
		min_val: -999,
		max_val: 999,
		description: "The minimum attack range of this unit. Other units close that this can not be attacked. Set to -1 for no min attack range",
		default_: -999,
		logic: true
	},
	
	{
		name: "aoeRadius",
		type: "float",
		min_val: 0,
		max_val: 99999999,
		description: "If this is bigger than 0, the building will deal aoe damage (= area of effect). That means not only the target unit takes damage, but all units in range of the target unit.",
		default_: 0,
		logic: true
	},
	
	{
		name: "bouncePower",
		type: "float",
		min_val: 0.0,
		max_val: 99.0,
		description: "If this is set to higher than 0, this unit will smash target units back when attacking them. It only affects units with power less than this bouncePower.",
		default_: 0,
		logic: true
	},
	
	{
		name: "bounceDistMin",
		type: "float",
		min_val: 0.0,
		max_val: 99.0,
		description: "The min range of how far this unit smashes target units back.",
		default_: 0,
		logic: true
	},
	
	{
		name: "bounceDistMax",
		type: "float",
		min_val: 0.0,
		max_val: 99.0,
		description: "The max range of how far this unit smashes target units back.",
		default_: 0,
		logic: true
	},
	
	{
		name: "attackPrio",
		type: "float",
		min_val: -99999,
		max_val: 999999,
		description: "Units with higher attack prios get attacked first.",
		default_: 5,
		logic: true
	},
	
	{
		name: "vision",
		type: "float",
		min_val: -1,
		max_val: 20,
		description: "The vision range of the building.",
		default_: 7,
		logic: true
	},
	
	{
		name: "projectileSpeed",
		type: "float",
		min_val: 0.02,
		max_val: 99999999,
		description: "Only relevant if this is a ranged building. The speed which the projectile travels.",
		default_: 8,
		logic: true
	},
	
	{
		name: "projectileLen",
		type: "float",
		min_val: 0.02,
		max_val: 10,
		description: "Only relevant if this is a ranged building with basic arrow projectiles. The length of the projectile.",
		default_: 0.2
	},
	
	{
		name: "attackLaunchSound",
		type: "selection",
		values: SOUND,
		description: "The sound that plays when this building fires.",
		default_: SOUND.NONE,
		logic: true
	},
	
	{
		name: "attackEffect",
		type: "selection",
		description: "The effect, that shows when this unit is attacking (only relevant for ranged units).",
		values: list_attack_effects,
		default_: null,
		logic: true
	},
	
	{
		name: "projectileStartHeight",
		type: "float",
		min_val: -99,
		max_val: 99,
		description: "The (only visual) height of projectiles that this unit shoots.",
		default_: 0
	},
	
	{
		name: "circleSize",
		type: "float",
		min_val: 0.02,
		max_val: 20,
		description: "The size of the selection circle of this building.",
		default_: 2.2
	},
	
	{
		name: "imageScale",
		type: "float",
		min_val: 0.1,
		max_val: 10,
		description: "If you put another value than 1, the image will be scaled, so the building becomes bigger or smaller (only visual, no gameplay effect).",
		default_: 1
	},
	
	{
		name: "circleOffset",
		type: "float",
		min_val: -99,
		max_val: 99,
		description: "The y offset of the cirle of this building (only a visual thing).",
		default_: 0.125
	},
	
	{
		name: "buildTime",
		type: "float",
		min_val: 0,
		max_val: 99999999,
		description: "The time it takes to build this building.",
		default_: 50,
		logic: true,
		displayScale: 1 / 20
	},
	
	{
		name: "goldPerDelivery",
		type: "float",
		min_val: 0,
		max_val: 99999999,
		description: "The amout of gold a player gets per delivery, when mining from this building.",
		default_: 5,
		logic: true
	},
	
	{
		name: "cost",
		type: "float",
		min_val: 0,
		max_val: 99999999,
		description: "The amount of gold it costs to build this unit.",
		default_: 150,
		logic: true
	},
	
	{
		name: "costIncrease",
		type: "float",
		min_val: -99999999,
		max_val: 99999999,
		description: "The amount of gold-cost-increase for this building. So the building gets more expensive the more you have.",
		default_: 150,
		logic: true
	},
	
	{
		name: "costIncreaseGroup",
		type: "selection",
		values: lists.unitTypes,
		default_: null,
		default2_: [],
		logic: true,
		isArray: true,
		description: "If this building has a costIncrese value, you put here all buildings, that increase this buildings cost."
	},
	
	{
		name: "healthbarOffset",
		type: "float",
		min_val: -99,
		max_val: 99,
		description: "The y offset of the health bar (only a visual thing).",
		default_: 0.95
	},
	
	{
		name: "healthbarWidth",
		type: "float",
		min_val: 0.1,
		max_val: 99,
		description: "The width of the health bar.",
		default_: 1.7
	},
	
	{
		name: "selectionOffsetY",
		type: "float",
		min_val: -99,
		max_val: 99,
		description: "The y offset of where the building should be selected.",
		default_: 0
	},
	
	{
		name: "img",
		type: "selection",
		values: lists.imgs,
		description: "The buildings image.",
		default_: lists.imgs.castle,
		special: "imgPreview"
	},
	
	{
		name: "description",
		type: "string",
		max_len: 300,
		min_len: 0,
		description: "The description of the building.",
		default_: ""
	},
	
	{
		name: "tabPriority",
		type: "float",
		min_val: -99,
		max_val: 99,
		description: "Buttons of building with higher tab priorities will be displayed first. When selecting two different types and both have special abilities, then the buttons of the building with higher tab priority will be displayed.",
		default_: 5
	},
	
	{
		name: "drawOffsetY",
		type: "float",
		min_val: -99,
		max_val: 99,
		description: "Y offset of the building when drawn.",
		default_: 6
	},
	
	{
		name: "size",
		type: "integer",
		min_val: 1,
		max_val: 5,
		description: "The size of the building (in fields). 3 means the building will be 3x3 fields (squares).",
		default_: 1,
		logic: true
	},
	
	{
		name: "repairRate",
		type: "float",
		min_val: 0,
		max_val: 99999999,
		description: "The amount of HP this unit restores when repairing (per sec).",
		default_: 0,
		logic: true,
		displayScale: 20
	},
	
	{
		name: "startGold",
		type: "float",
		min_val: 0,
		max_val: 99999999,
		description: "Only relevant for mines. The amount of gold, this building holds.",
		default_: 0,
		logic: true
	},
	
	{
		name: "timeToMine",
		type: "float",
		min_val: 0,
		max_val: 99999999,
		description: "Only relevant for mines or gold-taking buildings. The time it takes for a worker to grab / bring gold.",
		default_: 20,
		logic: true
	},
	
	{
		name: "miningEfficiencyCoefficient",
		type: "float",
		min_val: 0,
		max_val: 10,
		description: "Only relevant for mines or gold-taking buildings. This determinates how fast workers mine after the first one. If this is set to 0.5 for example, a worker only mines at 50% speed when theres already another worker working on this mine. A third worker only works at 25% speed and so on.",
		default_: 0.5,
		logic: true
	},
	
	{
		name: "minMiningRate",
		type: "float",
		min_val: 0,
		max_val: 99999999,
		description: "The absolute min rate workers will be mining at this building. The miningEfficiencyCoefficient value will make additional workers mine less effective, but they will never mine slower than minMiningRate.",
		default_: 0.1,
		logic: true
	},
	
	{
		name: "maxWorkers",
		type: "integer",
		min_val: 0,
		max_val: 99,
		description: "The max amount of workers that can work on this building.",
		default_: 6,
		logic: true
	},
	
	{
		name: "limit",
		type: "integer",
		min_val: 0,
		max_val: 999999,
		description: "Set this to a number bigger than 0 to limit the amount of instances of this building a player can make.",
		default_: 0,
		logic: true
	},
	
	{
		name: "visionHeightBonus",
		type: "integer",
		min_val: 0,
		max_val: 99,
		description: "Usually units can not look at higher grounds. With this value set they can look up X cliff levels. A unit being on height level 1 and having a visionHeightBonus of 1 can see height level 2, but not 3.",
		default_: 0,
		logic: true
	},
	
	{
		name: "commands",
		type: "commands",
		isObject: true,
		description: "Here are all the abilites stored, that this building can execute.",
		logic: true
	},
	
	{
		name: "lifetime",
		type: "float",
		min_val: 0,
		max_val: 999999,
		description: "When this is bigger than 0, the unit will only live for a certain amount of time.",
		default_: 0,
		logic: true,
		displayScale: 1 / 20
	},
	
	{
		name: "goldReward",
		type: "integer",
		min_val: -999999,
		max_val: 999999,
		description: "If this is not 0, a player who kills this unit will get gold rewarded according to this value.",
		default_: 0,
		logic: true
	},
	
	{
		name: "maxUnitsToRepair",
		type: "integer",
		min_val: 0,
		max_val: 999999,
		description: "Here you can determinate, how many unit can repair this unit at a time.",
		default_: 1,
		logic: true
	},
	
	{
		name: "modifiers",
		type: "selection",
		isArray: true,
		values: lists.modifiers,
		description: "Modifiers this unit applies to other units when attacking them.",
		default_: null,
		default2_: [],
		logic: true
	},
	
	{
		name: "modifiersSelf",
		type: "selection",
		isArray: true,
		values: lists.modifiers,
		description: "Modifiers this unit applies to ITSELF when attacking (other units).",
		default_: null,
		default2_: [],
		logic: true
	},
	
	{
		name: "spawnModifiers",
		type: "selection",
		isArray: true,
		values: lists.modifiers,
		description: "The modifiers this unit gets when it spawns.",
		default_: null,
		default2_: [],
		logic: true
	},
	
	{
		name: "deathSound",
		type: "selection",
		values: SOUND,
		description: "The sound that gets played when this building is destroyed.",
		default_: SOUND.BUILDING_DEATH
	},
	
	{
		name: "clickSound",
		type: "selection",
		values: SOUND,
		description: "The sound that gets played when this building gets selected.",
		default_: null
	},
	
	{
		name: "clickSoundVolume",
		type: "float",
		min_val: 0,
		max_val: 1.0,
		description: "The volume of the sound that gets played when this building gets selected.",
		default_: 1.0
	},
	
	{
		name: "hoverText",
		type: "string",
		min_len: 0,
		max_len: 1000,
		description: "If you enter a text here, it will be displayed instead of the owners' name when hovering this building.",
		default_: ""
	},
	
	{
		name: "canHaveWaypoint",
		type: "bool",
		description: "If this is true, this unit can set a waypoint (waypoints are used to tell spawning units where to go, so this usually makes sense if this unit can produce units)",
		default_: false,
		logic: true
	},
	
	{
		name: "causesFlameDeath",
		type: "bool",
		description: "If this is true, then units killed by this unit will burn for some seconds (only visual, no gameplay effect).",
		default_: false
	},
	
	{
		name: "hitscan",
		type: "bool",
		description: "Units that use hitscan, can not shoot through other units or obstacles, but need to have free space between them and their target in order to be able to shoot it. Their projectiles also can be intercepted if something moves in their way.",
		default_: false,
		logic: true
	},
	
	{
		name: "maximizeRangeWhenShooting",
		type: "bool",
		description: "Always shoot at max range. Only works on not heatseeking units. Makes sense on hitscan units.",
		default_: false,
		logic: true
	},
	
	{
		name: "hitsFriendly",
		type: "bool",
		description: "Determinates if this unit attack affects friendly units (only relevant on aoe abilities).",
		default_: true,
		logic: true
	},
	
	{
		name: "hitsEnemy",
		type: "bool",
		description: "Determinates if this unit attack affects enemy units (only relevant on aoe abilities).",
		default_: true,
		logic: true
	},
	
	{
		name: "canAttackGround",
		type: "bool",
		description: "Is the building able to attack ground units ?",
		default_: true,
		logic: true
	},
	
	{
		name: "canAttackFlying",
		type: "bool",
		description: "Determinates if this building can attack flying units.",
		default_: false,
		logic: true
	},
	
	{
		name: "isHeatSeeking",
		type: "bool",
		description: "If this is false, hits by this unit can miss and will hit where the target unit was, what the attack was started.",
		default_: true,
		logic: true
	},
	
	{
		name: "ignoreEnemyHitscan",
		type: "bool",
		description: "If this is true, the unit will be shootable for enemy units, that use hitscan, even if something is in the way. Makes sense for example on air units.",
		default_: false,
		logic: true
	},
	
	{
		name: "controllable",
		type: "bool",
		description: "If this is false, the unit can not be controlled by the player.",
		default_: true,
		logic: true
	},
	
	{
		name: "hasDetection",
		type: "bool",
		description: "If its true, this unit can detect invisible units.",
		default_: false,
		logic: true
	},
	
	{
		name: "expOnlyFromOwnKills",
		type: "bool",
		description: "If true, this unit gets only experience when it actually kills a unit itself, but not when its just in range when an enemy unit is killed by another allied unit.",
		default_: false,
		logic: true
	},
	
	{
		name: "alliesGetExperience",
		type: "bool",
		description: "If true, allied units get experience when killing this unit.",
		default_: false,
		logic: true
	},
	
	{
		name: "alliesGetGold",
		type: "bool",
		description: "If true, allied units get gold reward when killing this unit.",
		default_: false,
		logic: true
	},
	
	{
		name: "isReflectingProjectiles",
		type: "bool",
		description: "If this is true, this unit reflects projectiles that would hit it otherwise. Only affects projectiles that deal damage while flying.",
		default_: false,
		logic: true
	},
	
	{
		name: "isBlockingProjectiles",
		type: "bool",
		description: "If this is true, this unit blocks (kills) projectiles that would hit it otherwise. Only affects projectiles that deal damage while flying.",
		default_: false,
		logic: true
	},
	
	{
		name: "takeDamageOnBlock",
		type: "bool",
		description: "If this unit blocks or reflects a projectile, this field determinates if it is taking damage from the projectile.",
		default_: false,
		logic: true
	},
	
	{
		name: "isInvincible",
		type: "bool",
		description: "If this is true, the building can not be attacked or damaged.",
		default_: false,
		logic: true
	},
	
	{
		name: "isInvisible",
		type: "bool",
		description: "Invisible units can only be attacked when detected.",
		default_: false,
		logic: true
	},
	
	{
		name: "alwaysNeutral",
		type: "bool",
		description: "Determinates if this building is always neutral (can not be owned by a player).",
		default_: false,
		logic: true
	},
	
	{
		name: "takesGold",
		type: "bool",
		description: "Determinates if this building can be used to return gold by workers.",
		default_: false,
		logic: true
	},
	
	{
		name: "spawnWithAMove",
		type: "bool",
		description: "If this is true, units this unit produces will use AMove command when spawning to walk to the waypoint instead of normal move.",
		default_: false,
		logic: true
	},
	
	{
		name: "preventsReveal",
		type: "bool",
		description: "If a player has no buildings that prevent revealing, he will be revealed. That means all his buildings become visible to other players.",
		default_: true,
		logic: true
	},
	
	{
		name: "preventsLoss",
		type: "bool",
		description: "If a player has no buildings or units that prevent losing, he will be eliminated.",
		default_: true,
		logic: true
	},
	
	{
		name: "isMechanical",
		type: "bool",
		description: "Mechanical units (and all buildings) can be repaired and not healed.",
		default_: false,
		logic: true
	},
	
	{
		name: "isUndead",
		type: "bool",
		description: "Undead units take damage from healing spells.",
		default_: false,
		logic: true
	},
	
	{
		name: "isBiological",
		type: "bool",
		description: "Classification for unit types. Does not have any active effects but there can be abilities that only work for certain unit types. For example the 'Heal' spell only works with biological units.",
		default_: false,
		logic: true
	},
	
	{
		name: "isBeast",
		type: "bool",
		description: "Classification for unit types. Does not have any active effects but there can be abilities that only work for certain unit types. For example the 'Heal' spell only works with biological units.",
		default_: false,
		logic: true
	},
	
	{
		name: "isHuman",
		type: "bool",
		description: "Classification for unit types. Does not have any active effects but there can be abilities that only work for certain unit types. For example the 'Heal' spell only works with biological units.",
		default_: false,
		logic: true
	},
	
	{
		name: "noShow",
		type: "bool",
		description: "If this is true, the unit will not be drawn.",
		default_: false,
		logic: true
	}
	
];





var ability_fields = [
	
	{
		name: "name",
		type: "string",
		max_len: 30,
		min_len: 1,
		description: "The abilities name",
		default_: "new_ability",
		logic: true
	},
	
	{
		name: "type",
		type: "selection",
		values: EDITOR_COMMANDS,
		all_values: COMMAND,
		description: "The abilities type (determinates what the basic function of the ability is)",
		default_: EDITOR_COMMANDS.UNIVERSAL,
		descriptions: commandTypeDescriptions,
		logic: true
	},
	 
	{
		name: "unitType",
		type: "selection",
		values: lists.unitTypes,
		description: "The unit type or building type that this ability produces.",
		default_: null,
		logic: true
	},
	
	{
		name: "hotkey",
		type: "selection",
		values: KEY,
		description: "The abilities hotkey",
		default_: KEY.Q
	},
	
	{
		name: "targetIsPoint",
		type: "bool",
		description: "Determinates if the target is a point.",
		default_: false,
		logic: true
	},
	
	{
		name: "targetIsUnit",
		type: "bool",
		description: "Determinates if the target is a unit.",
		default_: false,
		logic: true
	},
	
	{
		name: "isInstant",
		type: "bool",
		description: "Determinates if this order is instant (no target).",
		default_: false,
		logic: true
	},
	
	{
		name: "isChanneled",
		type: "bool",
		description: "Channeled spells are being cast repediately until the caster is being ordered a different order (or doesnt have enough mana anymore) instead of only once like normal spells.",
		default_: false,
		logic: true
	},
	
	{
		name: "playLaunchSoundOnce",
		type: "bool",
		description: "When this spell is channeled, you can choose to play the launch sound only once while channeling.",
		default_: false,
		logic: true
	},
	
	{
		name: "useAoeCursor",
		type: "bool",
		description: "Determinates if the mouse cursor becomes an aoe indicator when searching a target for this ability (only works / makes sense for ranged abilities with aoe damage).",
		default_: false
	},
	
	{
		name: "commandCard",
		type: "integer",
		min_val: 0,
		max_val: 99,
		description: "Which command card the button will be. 0 is the default one, 1 is the 1st sub command card (for example for workers all the make building commands are on sub command cards).",
		default_: 0
	},
	
	{
		name: "interfacePosX",
		type: "integer",
		min_val: 0,
		max_val: 4,
		description: "The x pos of the button on the command card (0 is very left, 4 is very right).",
		default_: 0
	},
	
	{
		name: "interfacePosY",
		type: "integer",
		min_val: 0,
		max_val: 1,
		description: "The y pos of the button on the command card (0 is top row, 1 is bottom row).",
		default_: 0
	},
	
	{
		name: "requiredLevels",
		type: "integer",
		min_val: 0,
		max_val: 999999,
		isArray: true,
		description: "If you want the ability to be learnable, you can put here one one more levels, that the unit needs to reach before it can learn this ability (only makes sense if you put the ability on a unit that can have levels of course). Put more values for multi level abilities, the first value will be the unit level required for ability lvl 1, the 2nd value the unit level required for ability lvl 2 and so on ...",
		default_: 0,
		default2_: [],
		logic: true
	},
	
	{
		name: "learnCommandCard",
		type: "integer",
		min_val: 0,
		max_val: 99,
		description: "Which command card the learn button will be. 0 is the default one, 1 is the 1st sub command card (for example for workers all the make building commands are on sub command cards). This is required when this ability has to be learned first, where you want the button for learning it to be.",
		default_: 0
	},
	
	{
		name: "learnInterfacePosX",
		type: "integer",
		min_val: 0,
		max_val: 4,
		description: "The x pos of the learn button on the command card (0 is very left, 4 is very right). This is required when this ability has to be learned first, where you want the button for learning it to be.",
		default_: 0
	},
	
	{
		name: "learnInterfacePosY",
		type: "integer",
		min_val: 0,
		max_val: 1,
		description: "The y pos of the learn button on the command card (0 is top row, 1 is bottom row). This is required when this ability has to be learned first, where you want the button for learning it to be.",
		default_: 0
	},
	
	{
		name: "learnHotkey",
		type: "selection",
		values: KEY,
		description: "The abilities hotkey",
		default_: KEY.Q
	},
	
	{
		name: "image",
		type: "selection",
		values: lists.imgs,
		description: "The abilities image (that shows on the button)",
		default_: lists.imgs.stop,
		special: "imgPreview"
	},
	
	{
		name: "attackEffectInit",
		type: "selection",
		values: list_attack_effects,
		description: "The graphic effect that appears when start using this ability.",
		default_: list_attack_effects.spell,
		logic: true
	},
	
	{
		name: "attackEffect",
		type: "selection",
		description: "The graphic effect, that shows when this ability is used.",
		values: list_attack_effects,
		default_: null,
		logic: true
	},
	
	{
		name: "description",
		type: "string",
		max_len: 500,
		min_len: 0,
		description: "The abilities description",
		default_: ""
	},
	
	{
		name: "requirementType",
		type: "selection",
		isArray: true,
		values: lists.buildingsUpgrades,
		description: "The building or research type for the requirement. Put Barracks here for example, then put 1 for level, that will make this ability require at least 1 barracks.",
		default_: lists.buildingsUpgrades.house,
		default2_: [],
		logic: true,
		group: "requirements",
		subName: "type",
		groupDescription: "Here you can put tech requirements, like for example a specific upgrade or a specific building is required to use this ability."
	},
	
	{
		name: "requirementLevel",
		type: "integer",
		isArray: true,
		min_val: 0,
		max_val: 9999,
		description: "The level that the required building / research has to be.",
		default_: 1,
		default2_: [],
		logic: true,
		group: "requirements",
		subName: "level",
		groupDescription: "Here you can put tech requirements, like for example a specific upgrade or a specific building is required to use this ability."
	},
	
	{
		name: "requirementText",
		type: "string",
		isArray: true,
		max_len: 300,
		min_len: 0,
		description: "The description for failed requirement mets.",
		default_: "",
		default2_: [],
		logic: true,
		group: "requirements",
		subName: "text",
		groupDescription: "Here you can put tech requirements, like for example a specific upgrade or a specific building is required to use this ability."
	},
	
	{
		name: "targetRequirements1",
		type: "selection",
		isArray: true,
		values: targetRequirements,
		description: "The requirements the target has to fit. If you put multiple requirements into one field, only one of them has to fit.",
		default_: targetRequirements.isBiological,
		default2_: [],
		logic: true
	},
	
	{
		name: "targetRequirements2",
		type: "selection",
		isArray: true,
		values: targetRequirements,
		description: "The requirements the target has to fit. If you put multiple requirements into one field, only one of them has to fit.",
		default_: targetRequirements.isBiological,
		default2_: [],
		logic: true
	},
	
	{
		name: "targetRequirements3",
		type: "selection",
		isArray: true,
		values: targetRequirements,
		description: "The requirements the target has to fit. If you put multiple requirements into one field, only one of them has to fit.",
		default_: targetRequirements.isBiological,
		default2_: [],
		logic: true
	},
	
	{
		name: "launchSound",
		type: "selection",
		values: SOUND,
		description: "The sound that plays when the ability starts.",
		default_: SOUND.NONE,
		logic: true
	},
	
	{
		name: "upgrade",
		type: "selection",
		values: lists.upgrades,
		description: "The upgrade that will be researched.",
		default_: null,
		logic: true
	},
	
	{
		name: "improvedBuilding",
		type: "selection",
		values: lists.buildingTypes,
		description: "The building that the building will be upgraded to.",
		default_: null,
		logic: true
	},
	
	{
		name: "manaCost",
		type: "integer",
		min_val: -9999,
		max_val: 9999,
		description: "The mana cost of this ability. Put multiple values if you want to create a multiple level ability. First value will be level 1, 2nd level 2 and so on ...",
		default_: 0,
		default2_: [0],
		logic: true,
		isArray: true
	},
	
	{
		name: "goldCost",
		type: "integer",
		min_val: -9999,
		max_val: 9999,
		description: "The gold cost of this ability.",
		default_: 0,
		logic: true
	},
	
	{
		name: "aoeRadius",
		type: "float",
		min_val: 0,
		max_val: 99999999,
		description: "If this is bigger than 0, the ability will deal aoe damage (= area of effect). That means not only the target unit takes damage, but all units in range of the target unit. Put multiple values if you want to create a multiple level ability. First value will be level 1, 2nd level 2 and so on ...",
		default_: 0,
		default2_: [0],
		logic: true,
		isArray: true
	},
	
	{
		name: "damage",
		type: "float",
		min_val: -99999999,
		max_val: 99999999,
		description: "The damage this ability does. Put multiple values if you want to create a multiple level ability. First value will be level 1, 2nd level 2 and so on ...",
		default_: 0,
		default2_: [0],
		logic: true,
		isArray: true
	},
	
	{
		name: "projectileDamage",
		type: "float",
		min_val: -99999999,
		max_val: 99999999,
		description: "The damage the projectile does while flying. Damage will be dealt every 1 / 20 sec. So if you put 2 here, the projectile will deal 40 dmg per sec. Put multiple values if you want to create a multiple level ability. First value will be level 1, 2nd level 2 and so on ...",
		default_: 0,
		default2_: [0],
		logic: true,
		isArray: true
	},
	
	{
		name: "projectileAoeRadius",
		type: "float",
		min_val: 0,
		max_val: 99999999,
		description: "The aoe radius in which the projectile does damage while flying. Put multiple values if you want to create a multiple level ability. First value will be level 1, 2nd level 2 and so on ...",
		default_: 0,
		default2_: [0],
		isArray: true,
		logic: true
	},
	
	{
		name: "maximizeRangeWhenCasting",
		type: "bool",
		description: "If this is true, the spell gets cast at full range even when the target point is closer than max range. You usually want this for spells that have damaging projectiles, because the projectile should fly as long as possible.",
		default_: false,
		logic: true
	},
	
	{
		name: "hitsFriendly",
		type: "bool",
		description: "Determinates if this ability affects friendly units (only relevant on aoe abilities).",
		default_: true,
		logic: true
	},
	
	{
		name: "hitsEnemy",
		type: "bool",
		description: "Determinates if this ability affects enemy units (only relevant on aoe abilities).",
		default_: true,
		logic: true
	},
	
	{
		name: "hitsSelf",
		type: "bool",
		description: "Determinates if this ability affects the casting unit itself (only relevant on aoe abilities).",
		default_: true,
		logic: true
	},
	
	{
		name: "targetFilters",
		type: "string",
		isArray: true,
		max_len: 50,
		min_len: 0,
		description: "Here you can put one or more fields that the target units have to meet to be hit (for exaple flying, isBiological, isMechanical, isUnit, isBuilding, ...).",
		default_: "",
		default2_: [],
		logic: true
	},
	
	{
		name: "targetFiltersExclude",
		type: "string",
		isArray: true,
		max_len: 50,
		min_len: 0,
		description: "The same as targetFilters, but these filters will exclude units from being a target instead of including them.",
		default_: "",
		default2_: [],
		logic: true
	},
	
	{
		name: "effectScale",
		type: "float",
		min_val: 0,
		max_val: 99,
		description: "The scaling of the attack effect graphic (only graphic, no gameplay effect).",
		default_: 1,
		logic: true
	},
	
	{
		name: "hasAutocast",
		type: "bool",
		description: "If set to true, this ability can be set to be cast automatically.",
		default_: false,
		logic: true
	},
	
	{
		name: "autocastDefault",
		type: "bool",
		description: "If set to true, autocast is enabled by default (only makes sense, if hasAutocast is enabled, of course).",
		default_: false,
		logic: true
	},
	
	{
		name: "autocastConditions",
		realTimeCompile: true,
		compilerType: "Command",
		type: "string",
		max_len: 1000,
		min_len: 0,
		description: "If this ability has autocast, you can use this to tell the AI what targets to use for autocasting. Write something like hp > 10 and units that have hp bigger than 10 will be targetted. use && to combine multiple conditions with a logical AND, use || to combine multiple conditions with a logical OR. Use type.fieldname to refer to the units basic types fields. If you use hp, its the current units hp, if you use type.hp, its its basic hp. So if you use hp < type.hp for example, you get units that currently have hp less then their full hp. Use this to refer to the casting unit. For example this.owner = owner will only hit units that have the same owner as the casting unit.",
		default_: "",
		logic: true
	},
	
	{
		name: "projectileSpeed",
		type: "float",
		min_val: 0,
		max_val: 99999999,
		description: "The speed which the projectile travels. Put multiple values if you want to create a multiple level ability. First value will be level 1, 2nd level 2 and so on ...",
		default_: 8,
		default2_: [8],
		logic: true,
		isArray: true
	},
	
	{
		name: "duration",
		type: "float",
		min_val: 0.0,
		max_val: 99999999,
		description: "If projectileSpeed is 0 then you can set a duration instead, that determinates how long it takes for the ability to hit.",
		default_: 0,
		logic: true,
		displayScale: 1 / 20
	},
	
	{
		name: "castingDelay",
		type: "float",
		min_val: 0.0,
		max_val: 99999999,
		description: "When a unit starts using this ability there can be a short delay until the ability actually starts kicking in.",
		default_: 0,
		logic: true,
		displayScale: 1 / 20
	},
	
	{
		name: "cooldown",
		type: "float",
		min_val: 0.0,
		max_val: 99999999,
		description: "The time the unit cant do any other things after doing this ability.",
		default_: 0,
		logic: true,
		displayScale: 1 / 20
	},
	
	{
		name: "cooldown2",
		type: "float",
		min_val: 0.0,
		max_val: 99999999,
		description: "The time it takes for this unit to be able to do this order again after it did it.",
		default_: 0,
		logic: true,
		displayScale: 1 / 20
	},
	
	{
		name: "range",
		type: "float",
		min_val: 0.0,
		max_val: 99999999,
		description: "The range of the ability. Put multiple values if you want to create a multiple level ability. First value will be level 1, 2nd level 2 and so on ...",
		default_: 0,
		default2_: [0],
		logic: true,
		isArray: true
	},
	
	{
		name: "minRange",
		type: "float",
		min_val: -999,
		max_val: 999,
		description: "The minimum range of this ability. Set to -1 for no min range. Put multiple values if you want to create a multiple level ability. First value will be level 1, 2nd level 2 and so on ...",
		default_: -999,
		default2_: [-999],
		logic: true,
		isArray: true
	},
	
	{
		name: "bounceDistMin",
		type: "float",
		min_val: 0.0,
		max_val: 99.0,
		description: "The min range of how far this ability smashes target units back.",
		default_: 0,
		logic: true
	},
	
	{
		name: "bounceDistMax",
		type: "float",
		min_val: 0.0,
		max_val: 99.0,
		description: "The max range of how far this ability smashes target units back.",
		default_: 0,
		logic: true
	},
	
	{
		name: "bouncePower",
		type: "float",
		min_val: 0.0,
		max_val: 99.0,
		description: "If this is set to higher than 0, the ability will smash target units back. It only affects units with power less than this bouncePower.",
		default_: 0,
		logic: true
	},
	
	{
		name: "targetCC",
		type: "float",
		min_val: 0,
		max_val: 99,
		description: "Target Command Card. Determinated the number of the command card that will be switched to (0 = basic command card).",
		default_: 0
	},
	
	{
		name: "animationName",
		type: "string",
		max_len: 300,
		min_len: 0,
		description: "Name of the animation played when executing this order. The model of the unit must have an ability of this name, otherwise it wont work.",
		default_: ""
	},
	
	{
		name: "causesFlameDeath",
		type: "bool",
		description: "If this is true, then units killed by this ability will burn for some seconds (only visual, no gameplay effect).",
		default_: false,
		logic: true
	},
	
	{
		name: "modifiers",
		type: "selection",
		isArray: true,
		values: lists.modifiers,
		description: "The modifier this ability applies to target unit(s). Put multiple modifiers if you have a multiple level ability. First modifier will be used at level 1, 2nd at level 2 and so on ...",
		default_: null,
		default2_: [],
		logic: true
	},
	
	{
		name: "modifiersSelf",
		type: "selection",
		isArray: true,
		values: lists.modifiers,
		description: "The modifier this ability applies to the caster. Put multiple modifiers if you have a multiple level ability. First modifier will be used at level 1, 2nd at level 2 and so on ...",
		default_: null,
		default2_: [],
		logic: true
	},
	 
	{
		name: "summonedUnits",
		type: "selection",
		isArray: true,
		values: lists.unitTypes,
		description: "Unit, that this ability summons. Put multiple units if you want to create a multiple level ability. First unit will be summoned at level 1, 2nd at level 2 and so on ...",
		default_: null,
		default2_: [],
		logic: true
	},
	
	{
		name: "summonsUseWaypoint",
		type: "bool",
		description: "Determinates if the summoned unit(s) move to the waypoint of the summoning unit.",
		default_: false,
		logic: true
	},
	
	{
		name: "summonsWaypointAMove",
		type: "bool",
		description: "Determinates if the summoned units move to the waypoint with attack-move instead of normal move command.",
		default_: false,
		logic: true
	},
	
	{
		name: "ignoreSupplyCheck",
		type: "bool",
		description: "If this is true, the summonedUnit will be summoned even if theres not enough free supply.",
		default_: false,
		logic: true
	},
	
	{
		name: "requiresVision",
		type: "bool",
		description: "Determinates if the casting player needs to have vision at the target point in order to be able to cast this spell.",
		default_: false,
		logic: true
	}
	
];





var upgrade_fields = [
	
	{
		name: "name",
		type: "string",
		max_len: 30,
		min_len: 1,
		description: "The upgrades name",
		default_: "new_upgrade",
		logic: true
	},
	
	{
		name: "buildTime",
		type: "float",
		min_val: 0,
		max_val: 99999999,
		description: "The time it takes to research this upgrade.",
		default_: 30,
		logic: true,
		displayScale: 1 / 20
	},
	
	{
		name: "cost",
		type: "float",
		min_val: 0,
		max_val: 99999999,
		description: "The amount of gold it costs to research this upgrade.",
		default_: 100,
		logic: true
	},
	
	{
		name: "maxLevel",
		type: "integer",
		min_val: 0,
		max_val: 9999,
		description: "The amount of levels this upgrade has.",
		default_: 1,
		logic: true
	},
	
	{
		name: "description",
		type: "string",
		max_len: 300,
		min_len: 0,
		description: "The description of the upgrade.",
		default_: ""
	},
	
	{
		name: "image",
		type: "selection",
		values: lists.imgs,
		description: "The upgrades image",
		default_: null,
		special: "imgPreview"
	},
	
	{
		name: "effectsTypes",
		type: "selection",
		isArray: true,
		values: lists.types,
		description: "The type of the unit / building / upgrade / ability that receives the modification.",
		default_: lists.types.soldier,
		default2_: [],
		logic: true,
		group: "modification",
		subName: "type",
		groupDescription: "Here you can determinate which field of which units will be affected by this upgrade and how they will be affected."
	},
	
	{
		name: "effectsFields",
		type: "string",
		max_len: 300,
		min_len: 0,
		default_: "damage",
		default2_: [],
		isArray: true,
		description: "Which field should be modified.",
		logic: true,
		group: "modification",
		subName: "field",
		groupDescription: "Here you can determinate which field of which units will be affected by this upgrade and how they will be affected."
	},
	
	{
		name: "effectsModifications",
		type: "float",
		isArray: true,
		min_val: -99999999,
		max_val: 99999999,
		description: "How to modify the field. Here you can put a value that will be added.",
		default_: 0.0,
		default2_: [],
		logic: true,
		group: "modification",
		subName: "add",
		groupDescription: "Here you can determinate which field of which units will be affected by this upgrade and how they will be affected."
	},
	
	{
		name: "effectsModsMultiplier",
		type: "float",
		isArray: true,
		min_val: -99999999,
		max_val: 99999999,
		description: "How to modify the field. Here you can put a value that will be multiplied.",
		default_: 1.0,
		default2_: [],
		logic: true,
		group: "modification",
		subName: "multiply",
		groupDescription: "Here you can determinate which field of which units will be affected by this upgrade and how they will be affected."
	},
	
	{
		name: "noParallelResearch",
		type: "bool",
		description: "If this is true, the next upgrade level can only be started after the last one is finished. By default, if this is not set, multiple levels can be researched at the same time.",
		default_: false,
		logic: true
	}
	
];




var modifiers_fields = [
	
	{
		name: "name",
		type: "string",
		max_len: 30,
		min_len: 1,
		description: "The modifiers name",
		default_: "new_modifier",
		logic: true
	},
	
	{
		name: "description",
		type: "string",
		max_len: 300,
		min_len: 0,
		description: "The description of the modifier.",
		default_: ""
	},
	
	{
		name: "image",
		type: "selection",
		values: lists.imgs,
		description: "The modifiers image",
		default_: null,
		special: "imgPreview"
	},
	
	{
		name: "duration",
		type: "float",
		min_val: -99999999,
		max_val: 99999999,
		description: "The duration of the modifier. It will be removed after the duration expires. Put 0 or a negative number for endless duration.",
		default_: 60,
		logic: true,
		displayScale: 1 / 20
	},
	
	{
		name: "fields",
		type: "string",
		max_len: 300,
		min_len: 0,
		default_: "damage",
		default2_: [],
		isArray: true,
		description: "The field that will be modified.",
		logic: true,
		group: "modification",
		subName: "field",
		groupDescription: "Here you can determinate which field will be affected by this modifier and how."
	},
	
	{
		name: "modifications",
		type: "float",
		isArray: true,
		min_val: -99999999,
		max_val: 99999999,
		description: "How the field will be modified. The value in here will be added to the value of the field.",
		default_: 0.0,
		default2_: [],
		logic: true,
		group: "modification",
		subName: "add",
		groupDescription: "Here you can determinate which field will be affected by this modifier and how."
	},
	
	{
		name: "modificationsMultiplier",
		type: "float",
		isArray: true,
		min_val: -99999999,
		max_val: 99999999,
		description: "How the field will be modified. The value in here will be multiplied with the value of the field.",
		default_: 1.0,
		default2_: [],
		logic: true,
		group: "modification",
		subName: "multiply",
		groupDescription: "Here you can determinate which field will be affected by this modifier and how."
	},

	{
		name: "modificationsRate",
		type: "float",
		isArray: true,
		min_val: -99999999,
		max_val: 99999999,
		description: "The rate at which the value of the field will be modified per second.",
		default_: 0.0,
		default2_: [],
		logic: true,
		group: "modification",
		subName: "rate",
		groupDescription: "Here you can determinate which field will be affected by this modifier and how.",
		displayScale: 20
	},
	
	{
		name: "maxStack",
		type: "integer",
		min_val: 0,
		max_val: 9999,
		description: "How many instances of this modifier can be on one unit. Put 0 for unlimited instancs.",
		default_: 1,
		logic: true
	},
	
	{
		name: "auraModifiers",
		type: "selection",
		isArray: true,
		values: lists.modifiers,
		description: "This is the modifier that gets applied. It gets applied every 1.05 sec, so if you want them to be applied constantly, you want to give them a duration of at least something like 1.1 sec.",
		default_: null,
		default2_: [],
		logic: true,
		group: "aura",
		subName: "modifier",
		groupDescription: "Here you can create auras. Put a range and a modifier and the modifier will be applied to all units in range."
	},
	
	{
		name: "auraRange",
		type: "float",
		isArray: true,
		min_val: 0,
		max_val: 999,
		description: "Determinates the range in which the modifier gets applied.",
		default_: 9,
		default2_: [],
		logic: true,
		group: "aura",
		subName: "range",
		groupDescription: "Here you can create auras. Put a range and a modifier and the modifier will be applied to all units in range."
	},
	
	{
		name: "auraHitsFriendly",
		type: "bool",
		description: "Determinates if the aura affects the casting players units.",
		default_: true,
		logic: true
	},
	
	{
		name: "auraHitsAllied",
		type: "bool",
		description: "Determinates if the aura affects units by allied players.",
		default_: true,
		logic: true
	},
	
	{
		name: "auraHitsEnemy",
		type: "bool",
		description: "Determinates if the aura affects enemy units.",
		default_: true,
		logic: true
	},
	
	{
		name: "auraHitsSelf",
		type: "bool",
		description: "Determinates if the aura affects the origin unit.",
		default_: true,
		logic: true
	},
	
	{
		name: "auraTargetFilters",
		type: "selection",
		isArray: true,
		values: targetFilters1,
		description: "Here you can put one or more fields that the target units have to meet to be hit.",
		default_: "isHuman",
		default2_: [],
		logic: true
	},
	
	{
		name: "auraTargetFiltersExclude",
		type: "selection",
		isArray: true,
		values: targetFilters1,
		description: "The same as targetFilters, but these filters will exclude units from being a target instead of including them.",
		default_: "isHuman",
		default2_: [],
		logic: true
	},
	
	{
		name: "disabledCommands",
		type: "selection",
		isArray: true,
		values: lists.commands,
		description: "Abilities / commands that get disabled for the target unit while being under the influence of this modifier.",
		default_: lists.commands.flamestrike,
		default2_: [],
		logic: true
	},

	{
		name: "hasActivationCondition",
		type: "bool",
		description: "Determines if this modifier only applies under certain conditions.",
		default_: false
	},

	{
		name: "activationConditions",
		realTimeCompile: true,
		compilerType: "Modifier",
		type: "string",
		max_len: 1000,
		min_len: 0,
		description: "If this ability has activation conditions, this modifier will only apply if those conditions are satisfied. \
			These conditions are based on the state of the current unit, constructed from statements similar to this.hp > 100. \
			Any arithmetic expressions involving the operators +, -, *, /, and % are allowed, along with parentheses. \
			Conditions can be combined using && for a logical AND, and || for a logical OR, and parentheses can be used in combining conditions as well. \
			To get the default values for the unit, rather than the current values, use type.fieldname instead of just this.fieldname. \
			As an example, here is a condition for a modifier that will apply when a unit is between 30% and 70% HP: \
			this.hp > type.hp * 0.3 && this.hp < type.hp * 0.7",
		default_: "",
		logic: true
	},
	
	{
		name: "changeUnitImg",
		type: "bool",
		description: "Determinates if this modifier changes the img of the unit.",
		default_: false
	},
	
	{
		name: "unitImg",
		type: "selection",
		values: lists.imgs,
		description: "Changes the units img to this img. Only works, when changeUnitImg is set.",
		default_: null
	},
	
	{
		name: "changeAttackEffect",
		type: "bool",
		description: "Determinates if this modifier changes the attack effect of the unit (only graphic).",
		default_: false,
		logic: true
	},
	
	{
		name: "attackEffect",
		type: "selection",
		values: list_attack_effects,
		description: "Changes the units attack effect to this effect. Only works, when changeAttackEffect is set.",
		default_: null,
		logic: true
	},
	
	{
		name: "effects",
		type: "selection",
		isArray: true,
		values: list_attack_effects,
		description: "Graphic effects that will be displayed on a unit that has this modifier",
		default_: null,
		default2_: []
	},
	
	{
		name: "sound",
		type: "selection",
		values: SOUND,
		description: "The sound that plays when this modifier is active (will be looped).",
		default_: SOUND.NONE
	},
	
	{
		name: "volume",
		type: "float",
		min_val: 0,
		max_val: 1.0,
		description: "The volume at which the sound will be played",
		default_: 1.0
	},
	
	{
		name: "killModifiers",
		type: "selection",
		isArray: true,
		values: lists.modifiers,
		description: "Here you can put modifiers that will be removed when this modifier gets applied.",
		default_: null,
		default2_: [],
		logic: true
	}
	
];


var imgs_fields = [
	
	{
		name: "name",
		type: "string",
		max_len: 30,
		min_len: 1,
		description: "The images name",
		default_: "new_img"
	},
	
	{
		name: "file",
		type: "selection",
		values: customImgs,
		description: "The source file",
		default_: null
	},
	
	{
		name: "_angles",
		type: "selection",
		values: possibleAngleCounts,
		description: "4 angle units have 4 views (top, left, right, down), 8 angle units have 8 views (top, left, right, down, top-left, top-right, down-left, down-right). 1 angle units only have one view.",
		default_: 4
	},
	
	{
		name: "idle",
		type: "complex",
		default_: {x: 0, y: 0, w: 0, h: 0, frameWidth: 0},
		values: [
			{
				name: "x",
				type: "integer",
				min_val: 0,
				max_val: 5000,
				description: "The x cordinate of the part of the image where this animation starts.",
				default_: 0
			},
			
			{
				name: "y",
				type: "integer",
				min_val: 0,
				max_val: 5000,
				description: "The y cordinate of the part of the image where this animation starts.",
				default_: 0
			},
			
			{
				name: "w",
				type: "integer",
				min_val: 0,
				max_val: 5000,
				description: "The width (pixels) of the part of the image that contains this animation.",
				default_: 0
			},
			
			{
				name: "h",
				type: "integer",
				min_val: 0,
				max_val: 5000,
				description: "The height (pixels) of the part of the image that contains this animation.",
				default_: 0
			},
			
			{
				name: "frameWidth",
				type: "integer",
				min_val: 0,
				max_val: 5000,
				description: "The width (pixels) of one animation frame of this animation. The width (w) divided by the frameWidth equels the number of frames for this animation.",
				default_: 0
			}
		],
		description: "The idle animation frames."
	},
	
	{
		name: "walk",
		type: "complex",
		default_: {x: 0, y: 0, w: 0, h: 0, frameWidth: 0},
		values: [
			{
				name: "x",
				type: "integer",
				min_val: 0,
				max_val: 5000,
				description: "The x cordinate of the part of the image where this animation starts.",
				default_: 0
			},
			
			{
				name: "y",
				type: "integer",
				min_val: 0,
				max_val: 5000,
				description: "The y cordinate of the part of the image where this animation starts.",
				default_: 0
			},
			
			{
				name: "w",
				type: "integer",
				min_val: 0,
				max_val: 5000,
				description: "The width (pixels) of the part of the image that contains this animation.",
				default_: 0
			},
			
			{
				name: "h",
				type: "integer",
				min_val: 0,
				max_val: 5000,
				description: "The height (pixels) of the part of the image that contains this animation.",
				default_: 0
			},
			
			{
				name: "frameWidth",
				type: "integer",
				min_val: 0,
				max_val: 5000,
				description: "The width (pixels) of one animation frame of this animation. The width (w) divided by the frameWidth equels the number of frames for this animation.",
				default_: 0
			}
		],
		description: "The walk animation frames."
	},
	
	{
		name: "walkGold",
		type: "complex",
		default_: {x: 0, y: 0, w: 0, h: 0, frameWidth: 0},
		values: [
			{
				name: "x",
				type: "integer",
				min_val: 0,
				max_val: 5000,
				description: "The x cordinate of the part of the image where this animation starts.",
				default_: 0
			},
			
			{
				name: "y",
				type: "integer",
				min_val: 0,
				max_val: 5000,
				description: "The y cordinate of the part of the image where this animation starts.",
				default_: 0
			},
			
			{
				name: "w",
				type: "integer",
				min_val: 0,
				max_val: 5000,
				description: "The width (pixels) of the part of the image that contains this animation.",
				default_: 0
			},
			
			{
				name: "h",
				type: "integer",
				min_val: 0,
				max_val: 5000,
				description: "The height (pixels) of the part of the image that contains this animation.",
				default_: 0
			},
			
			{
				name: "frameWidth",
				type: "integer",
				min_val: 0,
				max_val: 5000,
				description: "The width (pixels) of one animation frame of this animation. The width (w) divided by the frameWidth equels the number of frames for this animation.",
				default_: 0
			}
		],
		description: "The walkGold animation frames."
	},
	
	{
		name: "die",
		type: "complex",
		default_: {x: 0, y: 0, w: 0, h: 0, frameWidth: 0},
		values: [
			{
				name: "x",
				type: "integer",
				min_val: 0,
				max_val: 5000,
				description: "The x cordinate of the part of the image where this animation starts.",
				default_: 0
			},
			
			{
				name: "y",
				type: "integer",
				min_val: 0,
				max_val: 5000,
				description: "The y cordinate of the part of the image where this animation starts.",
				default_: 0
			},
			
			{
				name: "w",
				type: "integer",
				min_val: 0,
				max_val: 5000,
				description: "The width (pixels) of the part of the image that contains this animation.",
				default_: 0
			},
			
			{
				name: "h",
				type: "integer",
				min_val: 0,
				max_val: 5000,
				description: "The height (pixels) of the part of the image that contains this animation.",
				default_: 0
			},
			
			{
				name: "frameWidth",
				type: "integer",
				min_val: 0,
				max_val: 5000,
				description: "The width (pixels) of one animation frame of this animation. The width (w) divided by the frameWidth equels the number of frames for this animation.",
				default_: 0
			}
		],
		description: "The die animation frames."
	},
	
	{
		name: "attack",
		type: "complex",
		default_: {x: 0, y: 0, w: 0, h: 0, frameWidth: 0},
		values: [
			{
				name: "x",
				type: "integer",
				min_val: 0,
				max_val: 5000,
				description: "The x cordinate of the part of the image where this animation starts.",
				default_: 0
			},
			
			{
				name: "y",
				type: "integer",
				min_val: 0,
				max_val: 5000,
				description: "The y cordinate of the part of the image where this animation starts.",
				default_: 0
			},
			
			{
				name: "w",
				type: "integer",
				min_val: 0,
				max_val: 5000,
				description: "The width (pixels) of the part of the image that contains this animation.",
				default_: 0
			},
			
			{
				name: "h",
				type: "integer",
				min_val: 0,
				max_val: 5000,
				description: "The height (pixels) of the part of the image that contains this animation.",
				default_: 0
			},
			
			{
				name: "frameWidth",
				type: "integer",
				min_val: 0,
				max_val: 5000,
				description: "The width (pixels) of one animation frame of this animation. The width (w) divided by the frameWidth equels the number of frames for this animation.",
				default_: 0
			}
		],
		description: "The attack animation frames."
	},
	
	{
		name: "special1",
		type: "complex",
		default_: {x: 0, y: 0, w: 0, h: 0, frameWidth: 0},
		values: [
			{
				name: "x",
				type: "integer",
				min_val: 0,
				max_val: 5000,
				description: "The x cordinate of the part of the image where this animation starts.",
				default_: 0
			},
			
			{
				name: "y",
				type: "integer",
				min_val: 0,
				max_val: 5000,
				description: "The y cordinate of the part of the image where this animation starts.",
				default_: 0
			},
			
			{
				name: "w",
				type: "integer",
				min_val: 0,
				max_val: 5000,
				description: "The width (pixels) of the part of the image that contains this animation.",
				default_: 0
			},
			
			{
				name: "h",
				type: "integer",
				min_val: 0,
				max_val: 5000,
				description: "The height (pixels) of the part of the image that contains this animation.",
				default_: 0
			},
			
			{
				name: "frameWidth",
				type: "integer",
				min_val: 0,
				max_val: 5000,
				description: "The width (pixels) of one animation frame of this animation. The width (w) divided by the frameWidth equels the number of frames for this animation.",
				default_: 0
			}
		],
		description: "The special1 animation frames (can be used for casting animation for example)"
	},
	
	{
		name: "img",
		type: "complex",
		default_: {x: 0, y: 0, w: 0, h: 0, frameWidth: 0, frames: []},
		values: [
			{
				name: "x",
				type: "integer",
				min_val: 0,
				max_val: 5000,
				description: "The x cordinate of the part of the image where this animation starts.",
				default_: 0
			},
			
			{
				name: "y",
				type: "integer",
				min_val: 0,
				max_val: 5000,
				description: "The y cordinate of the part of the image where this animation starts.",
				default_: 0
			},
			
			{
				name: "w",
				type: "integer",
				min_val: 0,
				max_val: 5000,
				description: "The width (pixels) of the part of the image that contains this animation.",
				default_: 0
			},
			
			{
				name: "h",
				type: "integer",
				min_val: 0,
				max_val: 5000,
				description: "The height (pixels) of the part of the image that contains this animation.",
				default_: 0
			},
			
			{
				name: "frameWidth",
				type: "integer",
				min_val: 0,
				max_val: 5000,
				description: "The width (pixels) of one animation frame of this animation. The width (w) divided by the frameWidth equels the number of frames for this animation.",
				default_: 0
			},
			
			{
				name: "frames",
				type: "integer",
				isArray: true,
				min_val: 0,
				max_val: 5000,
				description: "When you have multiple frames, then you can put here in which order they will be played. Each entry will last for 0.05 sec, so if you put 1, 1, 1, 2, 3 for example, then the first frame will be shown for 0.15 sec, then the 2nd frame will be shown for 0.05 sec and then the 3rd frame for 0.05 sec and then it starts all over again.",
				default_: 0,
				default2_: [],
			}
		],
		description: "The main image."
	},
	
	{
		name: "constructionImg",
		type: "complex",
		default_: {x: 0, y: 0, w: 0, h: 0, frameWidth: 0, frames: []},
		values: [
			{
				name: "x",
				type: "integer",
				min_val: 0,
				max_val: 5000,
				description: "The x cordinate of the part of the image where this animation starts.",
				default_: 0
			},
			
			{
				name: "y",
				type: "integer",
				min_val: 0,
				max_val: 5000,
				description: "The y cordinate of the part of the image where this animation starts.",
				default_: 0
			},
			
			{
				name: "w",
				type: "integer",
				min_val: 0,
				max_val: 5000,
				description: "The width (pixels) of the part of the image that contains this animation.",
				default_: 0
			},
			
			{
				name: "h",
				type: "integer",
				min_val: 0,
				max_val: 5000,
				description: "The height (pixels) of the part of the image that contains this animation.",
				default_: 0
			},
			
			{
				name: "frameWidth",
				type: "integer",
				min_val: 0,
				max_val: 5000,
				description: "The width (pixels) of one animation frame of this animation. The width (w) divided by the frameWidth equels the number of frames for this animation.",
				default_: 0
			},
			
			{
				name: "frames",
				type: "integer",
				isArray: true,
				min_val: 0,
				max_val: 5000,
				description: "When you have multiple frames, then you can put here in which order they will be played. Each entry will last for 0.05 sec, so if you put 0, 0, 0, 1, 2 for example, then the first frame (first frame = 0, 2nd frame = 1, and so on ...) will be shown for 0.15 sec, then the 2nd frame will be shown for 0.05 sec and then the 3rd frame for 0.05 sec and then it starts all over again.",
				default_: 0,
				default2_: [],
			}
		],
		description: "The image that is shown while the building is under construction. (only required for building images)"
	},
	
	{
		name: "damagedImg",
		type: "complex",
		default_: {x: 0, y: 0, w: 0, h: 0, frameWidth: 0, frames: []},
		values: [
			{
				name: "x",
				type: "integer",
				min_val: 0,
				max_val: 5000,
				description: "The x cordinate of the part of the image where this animation starts.",
				default_: 0
			},
			
			{
				name: "y",
				type: "integer",
				min_val: 0,
				max_val: 5000,
				description: "The y cordinate of the part of the image where this animation starts.",
				default_: 0
			},
			
			{
				name: "w",
				type: "integer",
				min_val: 0,
				max_val: 5000,
				description: "The width (pixels) of the part of the image that contains this animation.",
				default_: 0
			},
			
			{
				name: "h",
				type: "integer",
				min_val: 0,
				max_val: 5000,
				description: "The height (pixels) of the part of the image that contains this animation.",
				default_: 0
			},
			
			{
				name: "frameWidth",
				type: "integer",
				min_val: 0,
				max_val: 5000,
				description: "The width (pixels) of one animation frame of this animation. The width (w) divided by the frameWidth equels the number of frames for this animation.",
				default_: 0
			},
			
			{
				name: "frames",
				type: "integer",
				isArray: true,
				min_val: 0,
				max_val: 5000,
				description: "When you have multiple frames, then you can put here in which order they will be played. Each entry will last for 0.05 sec, so if you put 0, 0, 0, 1, 2 for example, then the first frame (first frame = 0, 2nd frame = 1, and so on ...) will be shown for 0.15 sec, then the 2nd frame will be shown for 0.05 sec and then the 3rd frame for 0.05 sec and then it starts all over again.",
				default_: 0,
				default2_: [],
			}
		],
		description: "The image that is shown when the building is (heavily) damaged. (only required for building images)"
	},
	
	{
		name: "busyImgs",
		type: "complex",
		default_: {x: 0, y: 0, w: 0, h: 0, frameWidth: 0, frames: []},
		values: [
			{
				name: "x",
				type: "integer",
				min_val: 0,
				max_val: 5000,
				description: "The x cordinate of the part of the image where this animation starts.",
				default_: 0
			},
			
			{
				name: "y",
				type: "integer",
				min_val: 0,
				max_val: 5000,
				description: "The y cordinate of the part of the image where this animation starts.",
				default_: 0
			},
			
			{
				name: "w",
				type: "integer",
				min_val: 0,
				max_val: 5000,
				description: "The width (pixels) of the part of the image that contains this animation.",
				default_: 0
			},
			
			{
				name: "h",
				type: "integer",
				min_val: 0,
				max_val: 5000,
				description: "The height (pixels) of the part of the image that contains this animation.",
				default_: 0
			},
			
			{
				name: "frameWidth",
				type: "integer",
				min_val: 0,
				max_val: 5000,
				description: "The width (pixels) of one animation frame of this animation. The width (w) divided by the frameWidth equels the number of frames for this animation.",
				default_: 0
			},
			
			{
				name: "frames",
				type: "integer",
				isArray: true,
				min_val: 0,
				max_val: 5000,
				description: "When you have multiple frames, then you can put here in which order they will be played. Each entry will last for 0.05 sec, so if you put 0, 0, 0, 1, 2 for example, then the first frame (first frame = 0, 2nd frame = 1, and so on ...) will be shown for 0.15 sec, then the 2nd frame will be shown for 0.05 sec and then the 3rd frame for 0.05 sec and then it starts all over again.",
				default_: 0,
				default2_: [],
			}
		],
		description: "The image that is shown when the building is busy (training a unit, researching an upgrade). (only required for building images)"
	},
	
	{
		name: "busyDamagedImgs",
		type: "complex",
		default_: {x: 0, y: 0, w: 0, h: 0, frameWidth: 0, frames: []},
		values: [
			{
				name: "x",
				type: "integer",
				min_val: 0,
				max_val: 5000,
				description: "The x cordinate of the part of the image where this animation starts.",
				default_: 0
			},
			
			{
				name: "y",
				type: "integer",
				min_val: 0,
				max_val: 5000,
				description: "The y cordinate of the part of the image where this animation starts.",
				default_: 0
			},
			
			{
				name: "w",
				type: "integer",
				min_val: 0,
				max_val: 5000,
				description: "The width (pixels) of the part of the image that contains this animation.",
				default_: 0
			},
			
			{
				name: "h",
				type: "integer",
				min_val: 0,
				max_val: 5000,
				description: "The height (pixels) of the part of the image that contains this animation.",
				default_: 0
			},
			
			{
				name: "frameWidth",
				type: "integer",
				min_val: 0,
				max_val: 5000,
				description: "The width (pixels) of one animation frame of this animation. The width (w) divided by the frameWidth equels the number of frames for this animation.",
				default_: 0
			},
			
			{
				name: "frames",
				type: "integer",
				isArray: true,
				min_val: 0,
				max_val: 5000,
				description: "When you have multiple frames, then you can put here in which order they will be played. Each entry will last for 0.05 sec, so if you put 0, 0, 0, 1, 2 for example, then the first frame (first frame = 0, 2nd frame = 1, and so on ...) will be shown for 0.15 sec, then the 2nd frame will be shown for 0.05 sec and then the 3rd frame for 0.05 sec and then it starts all over again.",
				default_: 0,
				default2_: [],
			}
		],
		description: "The image that is shown when the building is damaged and busy (training a unit, researching an upgrade). (only required for building images)"
	},
	
	{
		name: "upgradeImg",
		type: "complex",
		default_: {x: 0, y: 0, w: 0, h: 0, frameWidth: 0, frames: []},
		values: [
			{
				name: "x",
				type: "integer",
				min_val: 0,
				max_val: 5000,
				description: "The x cordinate of the part of the image where this animation starts.",
				default_: 0
			},
			
			{
				name: "y",
				type: "integer",
				min_val: 0,
				max_val: 5000,
				description: "The y cordinate of the part of the image where this animation starts.",
				default_: 0
			},
			
			{
				name: "w",
				type: "integer",
				min_val: 0,
				max_val: 5000,
				description: "The width (pixels) of the part of the image that contains this animation.",
				default_: 0
			},
			
			{
				name: "h",
				type: "integer",
				min_val: 0,
				max_val: 5000,
				description: "The height (pixels) of the part of the image that contains this animation.",
				default_: 0
			},
			
			{
				name: "frameWidth",
				type: "integer",
				min_val: 0,
				max_val: 5000,
				description: "The width (pixels) of one animation frame of this animation. The width (w) divided by the frameWidth equels the number of frames for this animation.",
				default_: 0
			},
			
			{
				name: "frames",
				type: "integer",
				isArray: true,
				min_val: 0,
				max_val: 5000,
				description: "When you have multiple frames, then you can put here in which order they will be played. Each entry will last for 0.05 sec, so if you put 0, 0, 0, 1, 2 for example, then the first frame (first frame = 0, 2nd frame = 1, and so on ...) will be shown for 0.15 sec, then the 2nd frame will be shown for 0.05 sec and then the 3rd frame for 0.05 sec and then it starts all over again.",
				default_: 0,
				default2_: [],
			}
		],
		description: "The image that is shown when the building is upgrading to a different building. (only required for building images)"
	},
	
	{
		name: "upgradeImgDamaged",
		type: "complex",
		default_: {x: 0, y: 0, w: 0, h: 0, frameWidth: 0, frames: []},
		values: [
			{
				name: "x",
				type: "integer",
				min_val: 0,
				max_val: 5000,
				description: "The x cordinate of the part of the image where this animation starts.",
				default_: 0
			},
			
			{
				name: "y",
				type: "integer",
				min_val: 0,
				max_val: 5000,
				description: "The y cordinate of the part of the image where this animation starts.",
				default_: 0
			},
			
			{
				name: "w",
				type: "integer",
				min_val: 0,
				max_val: 5000,
				description: "The width (pixels) of the part of the image that contains this animation.",
				default_: 0
			},
			
			{
				name: "h",
				type: "integer",
				min_val: 0,
				max_val: 5000,
				description: "The height (pixels) of the part of the image that contains this animation.",
				default_: 0
			},
			
			{
				name: "frameWidth",
				type: "integer",
				min_val: 0,
				max_val: 5000,
				description: "The width (pixels) of one animation frame of this animation. The width (w) divided by the frameWidth equels the number of frames for this animation.",
				default_: 0
			},
			
			{
				name: "frames",
				type: "integer",
				isArray: true,
				min_val: 0,
				max_val: 5000,
				description: "When you have multiple frames, then you can put here in which order they will be played. Each entry will last for 0.05 sec, so if you put 0, 0, 0, 1, 2 for example, then the first frame (first frame = 0, 2nd frame = 1, and so on ...) will be shown for 0.15 sec, then the 2nd frame will be shown for 0.05 sec and then the 3rd frame for 0.05 sec and then it starts all over again.",
				default_: 0,
				default2_: [],
			}
		],
		description: "The image that is shown when the building is damaged and upgrading to a different building. (only required for building images)"
	},
	
	{
		name: "imgEmpty",
		type: "complex",
		default_: {x: 0, y: 0, w: 0, h: 0, frameWidth: 0, frames: []},
		values: [
			{
				name: "x",
				type: "integer",
				min_val: 0,
				max_val: 5000,
				description: "The x cordinate of the part of the image where this animation starts.",
				default_: 0
			},
			
			{
				name: "y",
				type: "integer",
				min_val: 0,
				max_val: 5000,
				description: "The y cordinate of the part of the image where this animation starts.",
				default_: 0
			},
			
			{
				name: "w",
				type: "integer",
				min_val: 0,
				max_val: 5000,
				description: "The width (pixels) of the part of the image that contains this animation.",
				default_: 0
			},
			
			{
				name: "h",
				type: "integer",
				min_val: 0,
				max_val: 5000,
				description: "The height (pixels) of the part of the image that contains this animation.",
				default_: 0
			},
			
			{
				name: "frameWidth",
				type: "integer",
				min_val: 0,
				max_val: 5000,
				description: "The width (pixels) of one animation frame of this animation. The width (w) divided by the frameWidth equels the number of frames for this animation.",
				default_: 0
			},
			
			{
				name: "frames",
				type: "integer",
				isArray: true,
				min_val: 0,
				max_val: 5000,
				description: "When you have multiple frames, then you can put here in which order they will be played. Each entry will last for 0.05 sec, so if you put 0, 0, 0, 1, 2 for example, then the first frame (first frame = 0, 2nd frame = 1, and so on ...) will be shown for 0.15 sec, then the 2nd frame will be shown for 0.05 sec and then the 3rd frame for 0.05 sec and then it starts all over again.",
				default_: 0,
				default2_: [],
			}
		],
		description: "The image that is shown when the building used to have gold but has been mined out. (only required for building images)"
	}
	
];






var targetFilters = [];

for(var i = 0; i < unit_fields.length; i++)
	if(unit_fields[i].logic)
		targetFilters.push(unit_fields[i].name);

for(var i = 0; i < building_fields.length; i++)
	if(building_fields[i].logic && !targetFilters.contains(building_fields[i].name))
		targetFilters.push(building_fields[i].name);

targetFilters.push();





var list_unit_fields = {};
for(var i = 0; i < unit_fields.length; i++)
	list_unit_fields[unit_fields[i].name] = unit_fields[i];

var list_building_fields = {};
for(var i = 0; i < building_fields.length; i++)
	list_building_fields[building_fields[i].name] = building_fields[i];

var list_ability_fields = {};
for(var i = 0; i < ability_fields.length; i++)
	list_ability_fields[ability_fields[i].name] = ability_fields[i];

var list_upgrade_fields = {};
for(var i = 0; i < upgrade_fields.length; i++)
	list_upgrade_fields[upgrade_fields[i].name] = upgrade_fields[i];

var list_modifiers_fields = {};
for(var i = 0; i < modifiers_fields.length; i++)
	list_modifiers_fields[modifiers_fields[i].name] = modifiers_fields[i];

var list_graphic_fields = {};
for(var i = 0; i < imgs_fields.length; i++)
	list_graphic_fields[imgs_fields[i].name] = imgs_fields[i];

// the centeral class of a game; represents a game and holds arrays to all the objects
function Game()
{
	this.selectedUnits = []; // by the playing player currently selected units
	this.blockArray = []; // false = blocked, true = free
	this.timeOfLastSelection = 0; // to check for double click on selection
	this.projectiles = []; // arrows, ...
	this.fields = []; // one Field() for every grid element is stored here, also containing an array with all its neighbours
	this.fields2x2 = []; // addininal grid, we need that for units that are bigger than 1 field
	this.buckets2x2 = [];
	
	this.units = []; // all units
	this.units4 = []; // dead heroes; they must be stored in case they get ressurected
	this.buildings = []; // all in game existing buildings
	this.buildings2 = []; // all existing buildings plus some already dead buildings (if seen by some play who doesnt know the building is dead it still has to be drawn for him)
	this.groundTiles2 = []; // ground tiles, that are not default (might be added or removed in editor)
	this.blockingTiles = []; // trees, rocks and so on, that block pathing and are bound to the grid
	this.objectsToDraw = [];
	this.unitList = {};
	
	// camera position (top left corner of the screen, in pixels)
	this.cameraX = 0;
	this.cameraY = 0;
	
	this.global_id = 1;
	this.global_command_id = 0;
	this.buildingTypeIdCounter = 0;
	this.unitTypeIdCounter = 0;
	
	this.minimap = null;
	this.env = new Enviroment();
	this.rain = new Rain();
	
	this.lastYesSound = -999; // tick of last time unit said "yes" sound (reaction to order)
	this.lastReadySound = -999; // tick of last time unit said "ready" sound (reaction to order)
	this.lastMuteToggle = -999; // tick of last time unit said "ready" sound (reaction to order)
	
	// create additional canvas for groundtiles
	this.groundTilesCanvas = document.createElement('canvas');
	
	// create additional canvas for default tiles
	this.defaultTilesCanvas = document.createElement('canvas');
	
	// canvasses for tiles, we put some tiles together in canvasses, so in game we have less draw calls
	this.tilesCashes = [];
	
	this.gameHasEnded = false;
	this.playingPlayerWon = false;
	
	// set replay mode to false (might have been true if we watched a replay before)
	this.replay_mode = false;
	this.chat_muted = false;
	
	this.playingFromEditor = false;
	this.chatLog = {};
	this.chat = {};
	
	this.globalVars = null;
	
	this.oldVisionSetting = -1;
	
	this.specFieldNames = [
		"",
		"units",
		"buildings",
		"upgrades",
		"production",
		"",
		"",
		"lostUnitTypes"
	];
};

// load a map
/*
 * @param data map file data
 * @param playerSetting array of json datas for each player
 * @param aiRandomizer random number that comes from the server and determinates the style / strategy, that ai players play, (has to be the same for all clients)
 * @param ticksCounter in case of replay this is the amount of total ticks, so the game knows when the replay is finished and it has to stop
 */
Game.prototype.loadMap = function(data, playerSettings, aiRandomizer, replayTicksCounter, editorLoad, chat, rainTime)
{
	if(!playerSettings)
	{
		playerSettings = [{name: networkPlayerName, controller: CONTROLLER.COMPUTER, team: 1}];
		for(var i = 1; i < MAX_PLAYERS; i++)
			playerSettings.push({name: "Computer", controller: CONTROLLER.COMPUTER, team: i + 1, nr: i + 1});
		playerSettings.push({name: networkPlayerName, controller: CONTROLLER.HUMAN, team: 0, isPlayingPlayer: true});
	}
	
	this.x = parseInt(data.x);
	this.y = parseInt(data.y);
	this.name = data.name;
	this.description = data.description;
	this.data = data;
	this.aiRandomizer = aiRandomizer ? aiRandomizer : Math.ceil(Math.random() * 100000); // this is used to determinate, which AI-type the cpu players pick
	this.replayTicksCounter = replayTicksCounter ? replayTicksCounter : -1;
	
	// create Minimap
	this.minimap = new Minimap(this, 0, -MINIMAP_HEIGHT);
	
	initCustomImgsObj();
	
	// custom graphics
	if(data.graphics)
		for(key2_ in data.graphics)
		{
			var newImg = new Image();
			customImgs[key2_] = [];
			for(var i = 0; i < MAX_PLAYERS + 2; i++)
				customImgs[key2_][i] = newImg;
			
			newImg.onload = function(){
				for(key3_ in customImgs)
					if(customImgs[key3_] && customImgs[key3_][0] == customImgs[key3_][1])
					{
						var newImgs = ImageTransformer.replaceColors(customImgs[key3_][0], searchColors, playerColors);
						for(var i = 0; i < newImgs.length; i++)
							customImgs[key3_][i + 1] = newImgs[i];
						customImgs[key3_][MAX_PLAYERS + 1] = ImageTransformer.getGreyScaledImage(customImgs[key3_][0]);
					}
			};
			
			newImg.src = data.graphics[key2_];
		}
	
	this.updateGlobalVars(data.globalVars);
	
	// create teams
	this.teams = [];
	for(var i = 0; i < MAX_PLAYERS + 1; i++)
		this.teams.push(new Team(i));
	
	// create players, player 0 is always the neutral player. He owns gold mines for example
	this.players = [new Player("Neutral", CONTROLLER.NONE, 0, 0)];
	
	// create the active players from playerSettings
	var specNr = MAX_PLAYERS + 1;
	for(var i = 0; i < playerSettings.length; i++)
	{
		var ps = playerSettings[i];
		
		var nr = ps.nr ? ps.nr : i + 1;
		if(ps.controller == CONTROLLER.SPECTATOR)
		{
			nr = specNr;
			specNr++;
		}
		
		var custom_ai_index = ps.controller == (CONTROLLER.COMPUTER && !network_game) ? ps.ai_index : -1;
		
		var p = new Player(ps.name, ps.controller, nr, ps.controller == CONTROLLER.SPECTATOR ? 0 : ps.team, this.aiRandomizer, custom_ai_index, ps.customAI, ps.clan, ps.skins, ps.dances);
		
		if(playerSettings[i].isPlayingPlayer)
			PLAYING_PLAYER = p;
		
		// set controller == remote, if human but not playing player
		if(p.controller == CONTROLLER.HUMAN && PLAYING_PLAYER != p)
			p.controller == CONTROLLER.REMOTE;
		
		this.players[nr] = p;
	}
	
	// reset ticksCounter (= Game timer)
	ticksCounter = 0;
	
	// reset TICK_TIME
	TICK_TIME = 50;
	replaySpeedIndex = 1;
	
	// reset storage for commands that will be sent and recieved
	incomingOrders = {};
	outgoingOrders = [];
	playerLefts = {};
	
	// Set default delay
	TICKS_DELAY = network_game ? 6 : 2;
	
	// new keymanager (so control groups from possible last game get deleted)
	keyManager = new KeyManager();
	
	// fill block and Fields Arrays
	for(var x = 0; x <= this.x + 1; x++)
	{
		this.fields[x] = [];
		this.fields2x2[x] = [];
		this.blockArray[x] = [];
		for(var y = 0; y <= this.y + 1; y++)
		{
			this.fields[x][y] = new Field(x, y);
			this.fields2x2[x][y] = new Field(x, y, true);
			this.blockArray[x][y] = true;
			if(x < 1 || x > this.x || y < 1 || y > this.y) // if outside borders
				this.blockArray[x][y] = false;
		}
	}
	
	
	
	// create types
	interface_.buttons = [];
	
	_.each(lists, function(listElement, listName){
		if(listName != "imgs")
			_.each(listElement, function(type, key){
				if(key != "none")
					delete listElement[key];
			});
	});
	
	this.unitTypes = [];
	for(var i = 0; i < basicUnitTypes.length; i++)
		this.unitTypes.push(new UnitType(basicUnitTypes[i]));
	
	this.buildingTypes = [];
	for(var i = 0; i < basicBuildingTypes.length; i++)
		this.buildingTypes.push(new BuildingType(basicBuildingTypes[i]));
	
	this.upgrades = [];
	for(var i = 0; i < basicUpgrades.length; i++)
		this.upgrades.push(new Upgrade(basicUpgrades[i]));
	
	this.commands = [];
	for(var i = 0; i < basicCommands.length; i++)
		this.commands.push(new Command(basicCommands[i]));
	
	this.modifiers = [];
	for(var i = 0; i < basicModifiers.length; i++)
		this.modifiers.push(new Modifier(basicModifiers[i]));
	
	this.graphics = [];
	
	for(key in unit_imgs)
	{
		unit_imgs[key].id_string = key;
		this.graphics.push(new Graphic(unit_imgs[key]));
	}
	
	for(key in building_imgs)
	{
		building_imgs[key].id_string = key;
		building_imgs[key].file = building_imgs[key].file ? building_imgs[key].file : buildingSheet;
		this.graphics.push(new Graphic(building_imgs[key]));
	}
	
	for(key in imgs)
		this.graphics.push(new Graphic(imgs[key]));
	
	_.each(this.buildingTypes.concat(this.unitTypes, this.commands, this.upgrades, this.modifiers, this.graphics), function(t){ t.addToLists(); });
	
	// load custom unit Data
	var gameRef = this;
	_.each(data.unitData, function(type, typeName){
		
		if(typeName != "amove")
		{
			
			if(!lists.types[typeName])
			{
				var o = null;
				
				if(type.isUnit)
				{
					o = new UnitType(type);
					gameRef.unitTypes.push(o);
				}
				
				else if(type.isBuilding)
				{
					o = new BuildingType(type);
					gameRef.buildingTypes.push(o);
				}
				
				else if(type.isCommand)
				{
					o = new Command(type);
					gameRef.commands.push(o);
				}
				
				else if(type.isUpgrade)
				{
					o = new Upgrade(type);
					gameRef.upgrades.push(o);
				}
				
				else if(type.isModifier)
				{
					o = new Modifier(type);
					gameRef.modifiers.push(o);
				}
				
				else if(type.isGraphic)
				{
					o = new Graphic(type);
					gameRef.graphics.push(o);
				}
				
				o.id_string = typeName;
				
				o.addToLists();
			}
			
			var dataFields = type.isGraphic ? lists.imgs[typeName].getDataFields() : lists.types[typeName].getDataFields();
			
			_.each(type, function(val, field){
				
				if(dataFields[field])
				{
					if(dataFields[field].isObject)
					{
						var obj = {};
						
						_.each(val, function(el, key){
							obj[key] = el;
						});
						
						lists.types[typeName][field] = obj;
					}
					
					else if(dataFields[field].isArray)
					{
						var arr = [];
						
						if(Object.prototype.toString.call(val) === '[object Array]')
							for(var i = 0; i < val.length; i++)
								arr.push(checkField(dataFields[field], val[i]));
						
						else
							arr.push(checkField(dataFields[field], val));
						
						lists.types[typeName][field] = arr;
					}
					
					else
					{
						lists.types[typeName][field] = checkField(dataFields[field], val);
						
						if(dataFields[field].type == "selection" && dataFields[field].all_values && !_.contains(dataFields[field].all_values, lists.types[typeName][field]))
							lists.types[typeName][field] = dataFields[field].default_;
					}
				}
				
			});
			
		}
		
	});
	
	// load custom unit Data
	_.each(data.graphicObjects, function(type, typeName){
		
		if(!lists.imgs[typeName])
		{
			var o = new Graphic(type);
			o.id_string = typeName;
			gameRef.graphics.push(o);
			o.addToLists();
		}
		
		var dataFields = lists.imgs[typeName].getDataFields();
		
		_.each(type, function(val, field){
			
			if(dataFields[field])
			{
				if(dataFields[field].type == "complex")
				{
					var obj = {};
					
					_.each(val, function(el, key){
						obj[key] = el;
					});
					
					lists.imgs[typeName][field] = obj;
				}
				
				else
				{
					lists.imgs[typeName][field] = checkField(dataFields[field], val);
					
					if(dataFields[field].type == "selection" && dataFields[field].all_values && !_.contains(dataFields[field].all_values, lists.types[typeName][field]))
						lists.imgs[typeName][field] = dataFields[field].default_;
				}
			}
			
		});
		
	});
	
	// refresh all buttons
	for(var k = 0; k < interface_.buttons.length; k++)
		interface_.buttons[k].init(interface_.buttons[k].command, interface_.buttons[k].learn);
	
	calculateTypesTickValues();
	
	// replacing references
	_.each(this.commands.concat(this.upgrades, this.buildingTypes, this.unitTypes, this.modifiers, this.graphics, tileTypes, cliffs, cliffs_winter, egypt_cliffs, grave_cliffs, ramp_tiles, ramp_tiles_egypt, ramp_tiles_grave), function(t){
		t.replaceReferences();
	});
	
	mapEditorData = new MapEditorData();
	
	if(game_state == GAME.EDITOR && editor)
		editor.createButtons();
	
	
	
	
	// change environment particle style depending on theme
	var theme = getThemeByName(data.theme);
	
	if(!theme && this.data.defaultTiles && this.data.defaultTiles[0])
		for(var i = 0; i < mapThemes.length; i++)
			if(mapThemes[i].defaultTiles.contains(this.data.defaultTiles[0]))
				theme = mapThemes[i];
	
	if(!theme)
		theme = mapThemes[0];
	
	this.theme = theme;
	
	// generate default ground tiles (by random)
	if(this.data.defaultTiles)
		for(var x = 1; x <= this.x + DEAD_MAP_SPACE; x++)
			for(var y = 1; y <= this.y + DEAD_MAP_SPACE; y++)
				new Tile({x: x, y: y, type: this.data.defaultTiles[Math.floor(Math.random() * this.data.defaultTiles.length)].toUnitType()});
	
	// make cliffs
	this.makeCliffsArray();
	this.makeCliffs();
	
	for(var i = 0; i < data.tiles.length; i++)
		new Tile({x: data.tiles[i].x, y: data.tiles[i].y, type: data.tiles[i].type.toUnitType(), dontRefreshNBs: true});
	
	// set size depending on map size
	this.defaultTilesCanvas.width = (this.x + DEAD_MAP_SPACE) * FIELD_SIZE / SCALE_FACTOR;
	this.defaultTilesCanvas.height = (this.y + 2 + DEAD_MAP_SPACE) * FIELD_SIZE / SCALE_FACTOR;
	
	var ctx = this.defaultTilesCanvas.getContext("2d");
	var ctxM = this.minimap.groundTiles.getContext('2d');
	
	// generate default ground tiles (by random)
	if(this.data.defaultTiles)
		for(var x = 1; x <= this.x + DEAD_MAP_SPACE; x++)
			for(var y = -1; y <= this.y + DEAD_MAP_SPACE; y++)
			{
				var type = this.data.defaultTiles[Math.floor(Math.random() * this.data.defaultTiles.length)].toUnitType();
				
				ctx.drawImage(type.img.file[0], type.img.img.x, type.img.img.y, 16, 16, (x - 1) * 16, (y - 1 + 2) * 16, 16, 16);
				
				ctxM.fillStyle = type.minimapColor;
				ctxM.fillRect(Math.floor((x - 1) * this.minimap.x_scale), Math.floor((y - 1) * this.minimap.y_scale), Math.ceil(this.minimap.x_scale * type.sizeX), Math.ceil(this.minimap.y_scale * type.sizeY));
				
				// new Tile({x: x, y: y, type: this.data.defaultTiles[Math.floor(Math.random() * this.data.defaultTiles.length)].toUnitType()});
			}
	
	this.generateGroundTextureCanvas();
	
	this.generateTilesCanvasses();
	
	this.sortTiles();
	
	this.reduceDelayOnNextTick = false;
	this.increaseDelayOnNextTick = false;
	
	this.chat = chat ? chat : {};
	
	FIELD_SIZE = 16 * SCALE_FACTOR;
	
	this.minimap.refreshTilesCanvas();
	
	// find cc or start location
	var cc = null;
	for(var k = 0; k < this.buildings.length; k++)
		if(this.buildings[k].type.takesGold && this.buildings[k].owner == PLAYING_PLAYER)
			cc = this.buildings[k];
	
	// empty points gained caption
	$('#showLadderPointsDiv').html("");
	
	// empty chat history
	$('#chatHistorytextContainer').html("");
	
	// kill xp string
	xpNfo = "";
	
	// refresh player vision dropdown
	$('#visionDropdown').html("<option id='visionAll' selected='selected' value='0'>All [" + getKeyName(obsKeys[0]) + "]</option>");
	for(var i = 1; i < this.players.length; i++)
		if(this.players[i] && this.players[i].controller != CONTROLLER.SPECTATOR && playerColors[i - 1])
		{
			var arr = playerColors[i - 1][4];
			$('#visionDropdown')[0].innerHTML += "<option style='color: rgb(" + arr[0] + ", " + arr[1] + ", " + arr[2] + ");' value='" + i + "'>" + this.players[i].name + " [" + i + "]</option>";
		}
	$('#visionDropdown')[0].selectedIndex = 0;
	$('#spectatorDropdown')[0].selectedIndex = 0;
	refreshPlayerSettingsHTML(data.players ? data.players : getDefaultPlayerSettings(data.countPlayers ? data.countPlayers : MAX_PLAYERS));
	
	env.setFromTheme(theme);
	
	this.replay_mode = typeof replayTicksCounter != 'undefined' && replayTicksCounter !== null;
	game_paused = false;
	show_fps = false;
	this.chat_muted = false;
	
	if(network_game)
		interface_.chatMsg("press [ENTER] to chat", true);
	
	this.rainTime = rainTime ? rainTime : getRainTimeFromSeed(aiRandomizer);
};

Game.prototype.updateGlobalVars = function(o)
{
	this.globalVars = o ? o : {};
	
	this.globalVars.mineDist = (typeof this.globalVars.mineDist !== "undefined") ? Math.min(toInt(this.globalVars.mineDist), 100) : MINE_DIST;
	this.globalVars.maxSupply = (typeof this.globalVars.maxSupply !== "undefined") ? Math.min(toInt(this.globalVars.maxSupply), 200) : MAX_SUPPLY;
	this.globalVars.startGold = (typeof this.globalVars.startGold !== "undefined") ? Math.min(Math.max(toInt(this.globalVars.startGold), 0), 999999) : START_GOLD;
};

Game.prototype.getFieldFromPos = function(x, y, lowerMod)
{
	// if no coords passed, use current mouse pos as default
	if(!x && !y)
	{
		x = (keyManager.x + game.cameraX) / FIELD_SIZE;
		y = (keyManager.y + game.cameraY) / FIELD_SIZE;
	}
	
	var bestDist = 99999;
	var bestField = null;
	for(var i = MAX_CLIFF_LEVEL * CLIFF_HEIGHT; i > 0; i -= 0.1)
	{
		var f = new Field(x, y + i, true);
		var dist = Math.abs(i - (lowerMod ? this.getHMValue3X(f) : this.getHMValue3(f)) * CLIFF_HEIGHT);
		if(dist < 0.2)
			return f;
		
		if(dist < bestDist)
		{
			bestDist = dist;
			bestField = f;
		}
	}
	
	if(bestField)
		return bestField;
	
	return new Field(x, y, true);
};

// höhe, auf der Einheiten gezeichnet werden
Game.prototype.getHMValue3X = function(pos)
{
	if(this.fields[pos.x] && this.fields[pos.x][pos.y])
	{
		var f = this.fields[pos.x][pos.y];
		
		if(!f.rampEnds)
			return f.hm2 ? f.hm2 : 0;
		
		var dist = f.rampEnds.low.distanceTo2(f.rampEnds.high);
		return f.hm2 + Math.min(Math.max((pos.distanceTo2(f.rampEnds.low) - 0.1) * 1.1, 0) / dist, 1);
	}
	
	return 0;
};

// höhe, auf der Einheiten gezeichnet werden
Game.prototype.getHMValue3 = function(pos)
{
	if(this.fields[pos.x] && this.fields[pos.x][pos.y])
	{
		var f = this.fields[pos.x][pos.y];
		
		if(!f.rampEnds)
			return f.hm4 ? f.hm4 : 0;
		
		var dist = f.rampEnds.low.distanceTo2(f.rampEnds.high);
		return f.hm2 + Math.min(Math.max((pos.distanceTo2(f.rampEnds.low) - 0.1) * 1.1, 0) / dist, 1);
	}
	
	return 0;
};

Game.prototype.getHMValue4 = function(x, y)
{
	return (this.fields[x] && this.fields[x][y]) ? this.fields[x][y].hm4 : 0;
};

Game.prototype.getHMValue2 = function(x, y)
{
	return (this.fields[x] && this.fields[x][y]) ? this.fields[x][y].hm2 : 0;
};

Game.prototype.getHMValue = function(x, y)
{
	return (this.fields[x] && this.fields[x][y]) ? this.fields[x][y].hm : 0;
};

Game.prototype.setHMValue = function(x, y, val, noHistory)
{
	if(this.fields[x] && this.fields[x][y]) {
		if(game_state == GAME.EDITOR && noHistory!=true) {
			var heightMapChange = {
				x : x,
				y : y,
				newHeight: val,
				oldHeight: this.fields[x][y].hm
			}
			editor.clipboard.history.addObject(heightMapChange, "ChangeHeight");
		}
		this.fields[x][y].hm = val;
	}
};

Game.prototype.makeCliffsArray = function()
{
	var hm = this.data.heightmap ? this.data.heightmap : "";
	var i = 0;
	
	for(var x = 1; x <= this.x; x++)
	{
		for(var y = 1; y <= this.y; y++)
		{
			if(hm.length > i)
			{
				var val = hm.slice(i, i + 1);
				
				if(parseInt(val) == val)
				{
					if(val > MAX_CLIFF_LEVEL)
						val = MAX_CLIFF_LEVEL;
					
					if(val < 0)
						val = 0;
					
					val = parseInt(val);
				}
				
				this.fields[x][y].hm = val;
			}
			else
				this.fields[x][y].hm = 0;
			
			i++;
		}
	}
};

// make cliffs (in an area from x1:y1 to x2:y2; default: whole map)
Game.prototype.makeCliffs = function(x1_, y1_, x2_, y2_)
{
	x1_ = Math.min(Math.max(x1_ ? x1_ : 1, 1), this.x);
	y1_ = Math.min(Math.max(y1_ ? y1_ : 1, 1), this.y);
	x2_ = Math.min(Math.max(x2_ ? x2_ : this.x, 1), this.x);
	y2_ = Math.min(Math.max(y2_ ? y2_ : this.y, 1), this.y);
	
	// kill all existing cliff Tiles
	for(var i = 0; i < this.blockingTiles.length; i++)
	{
		var tile = this.blockingTiles[i];
		if(tile.type.isCliff && tile.x >= x1_ && tile.x <= x2_ && tile.y >= y1_ && tile.y <= y2_)
		{
			this.blockingTiles[i].switchBlockingTotal(false);
			this.blockingTiles.splice(i, 1);
			i--;
		}
	}
	
	// higher level, if single low grounded cliff fields, cuz those look stupido
	for(var x = x1_; x <= x2_; x++)
		for(var y = y1_; y <= y2_; y++)
		{
			var h = this.fields[x][y].hm;
			
			if(parseInt(h) == h)
			{
				var countHigherNBs = 0;
				
				for(var i = 0; i < 8; i++)
				{
					var h2 = this.getHMValue(x + nbCoords[i].x, y + nbCoords[i].y);
					
					if(parseInt(h2) == h2 && h2 > h)
						countHigherNBs++;
				}
				
				// if all but one (or all) nbs are higher, make this field, higher, too
				if(countHigherNBs >= 6)
					this.fields[x][y].hm++;
				
				else
				{
					for(var i = 0; i < reversePairs.length; i++)
					{
						var h1_ = this.getHMValue(x + reversePairs[i][0].x, y + reversePairs[i][0].y);
						var h2_ = this.getHMValue(x + reversePairs[i][1].x, y + reversePairs[i][1].y);
						
						if(parseInt(h1_) == h1_ && h1_ > h && parseInt(h2_) == h2_ && h2_ > h)
						{
							this.fields[x][y].hm++;
							i = reversePairs.length;
						}
					}
				}
			}
		}
	
	for(var x = x1_; x <= x2_; x++)
		for(var y = y1_; y <= y2_; y++)
		{
			var h = this.fields[x][y].hm;
			
			this.fields[x][y].hm2 = h;
			this.fields[x][y].hm4 = h;
			this.fields[x][y].rampEnds = null;
			
			// get height levels of all nbs
			var nbs = [];
			for(var i = 0; i < 8; i++)
			{
				var h2 = this.getHMValue(x + nbCoords[i].x, y + nbCoords[i].y);
				
				if(parseInt(h2) != h2)
					h2 = h;
				
				nbs.push(h2 - h);
			}
			
			// find according cliff
			var cliffTilePlaced = false;
			for(var i = 0; i < cliffTable.length; i++)
			{
				var match = true;
				var arr = cliffTable[i].arr;
				for(var k = 0; k < 8; k++)
					if(!(arr[k] == "*" || (arr[k] == 0 && nbs[k] <= 0) || (arr[k] == 1 && nbs[k] == 1)))
						match = false;
				
				if(match)
				{
					new Tile({x: x, y: y, type: this.theme.cliffs[cliffTable[i].cliffIndex]});
					cliffTilePlaced = true;
					this.fields[x][y].hm4++;
				}
			}
			
			if(!cliffTilePlaced)
			{
				var atLeastOneHigherGroundExists = false;
				for(var k = 0; k < 8; k++)
					if(nbs[k] > 0)
						atLeastOneHigherGroundExists = true;
				
				if(atLeastOneHigherGroundExists && h == parseInt(h))
				{
					if(this.getHMValue(x, y + 1) <= h)
						new Tile({x: x, y: y, type: this.theme.cliffs[0]});
					
					else
						new Tile({x: x, y: y, type: this.theme.cliffs[12]});
					
					this.fields[x][y].hm4++;
				}
			}
		}
	
	
	// Ramps
	var usedPoints = [];
	
	for(var x = x1_; x <= x2_; x++)
		for(var y = y1_; y <= y2_; y++)
		{
			var h = this.fields[x][y].hm;
			
			if(h == "N" || h == "S" || h == "E" || h == "W")
			{
				var ramp = getRampTypeFromCode(h);
				
				// determinate height level of this ramp
				var x2 = x;
				var y2 = y;
				
				while(this.getHMValue(x2, y2) == h)
				{
					x2 += ramp.vec.x;
					y2 += ramp.vec.y;
				}
				
				this.fields[x][y].hm2 = this.getHMValue(x2, y2);
				
				// search and set lowest and highest point
				x2 = x;
				y2 = y;
				
				while(this.getHMValue(x2, y2) == h)
				{
					x2 += ramp.vec.x;
					y2 += ramp.vec.y;
				}
				
				var x3 = x;
				var y3 = y;
				
				while(this.getHMValue(x3, y3) == h)
				{
					x3 -= ramp.vec.x;
					y3 -= ramp.vec.y;
				}
				
				this.fields[x][y].rampEnds = {low: new Field(x2, y2).add3(-ramp.vec.x / 2, -ramp.vec.y / 2), high: new Field(x3, y3).add3(ramp.vec.x / 2, ramp.vec.y / 2)};
				
				// sides
				for(var i = 0; i < ramp.cliffs.length; i++)
				{
					var cliff = ramp.cliffs[i];
					
					// search point1
					x2 = x;
					y2 = y;
					
					while(this.getHMValue(x2 + cliff.x, y2) == h)
						x2 += cliff.x;
					
					while(this.getHMValue(x2, y2 + cliff.y) == h)
						y2 += cliff.y;
					
					if(cliff.addX)
						x2 += cliff.addX;
					
					if(cliff.addY)
						y2 += cliff.addY;
					
					var hash = x2 + y2 * 10000;
					if(usedPoints.contains(hash))
					{
						i = ramp.cliffs.length;
						continue;
					}
					
					else
					{
						usedPoints.push(hash);
						if(!this.fieldIsBlocked(x2, y2))
							new Tile({x: x2, y: y2, type: cliff.cliff});
					}
				}
				
				// ground texture
				
				// move draw pointer to initial position
				x2 = x;
				y2 = y;
				
				while(this.getHMValue(x2 + ramp.texture.initX, y2) == h)
					x2 += ramp.texture.initX;
				
				while(this.getHMValue(x2, y2 + ramp.texture.initY) == h)
					y2 += ramp.texture.initY;
				
				// draw
				while(this.getHMValue(x2 + ramp.texture.loopX * 2, y2 + ramp.texture.loopY * 2) == h)
				{
					new Tile({x: x2 + ramp.texture.drawX, y: y2 + ramp.texture.drawY - this.getHMValue2(x2, y2) * CLIFF_HEIGHT, type: ramp.texture.tiles[Math.floor(Math.random() * ramp.texture.tiles.length)]});
					
					x2 += ramp.texture.loopX;
					y2 += ramp.texture.loopY;
				}
			}
		}
};
Game.prototype.enableChat = function(val)
{
	this.chat_muted = val; //!this.chat_muted;
	// Pop up
	interface_.addMessage("Chat " + (this.chat_muted ? "muted." : "unmuted."), "yellow", imgs.attentionmarkYellow);
}

// kill ramp at position x, y
Game.prototype.killRamp = function(x, y)
{
	var h = this.getHMValue(x, y);
	
	if(h == parseInt(h))
		return;
	
	var fields = [this.fields[x][y]];
	var fields2 = [];
	
	while(fields.length > 0)
	{
		var f = fields.pop();
		fields2.push(f);
		
		for(var i = 0; i < nbCoords.length; i++)
		{
			var nb = this.fields[f.x + nbCoords[i].x] ? this.fields[f.x + nbCoords[i].x][f.y + nbCoords[i].y] : null;
			if(nb && !fields.contains(nb) && !fields2.contains(nb) && this.getHMValue(nb.x, nb.y) == h)
				fields.push(nb);
		}
	}
	
	for(var i = 0; i < fields2.length; i++)
	{
		// kill side cliffs
		if(!this.blockArray[fields2[i].x][fields2[i].y])
			for(var k = 0; k < this.blockingTiles.length; k++)
				if(this.blockingTiles[k].includesField(fields2[i].x, fields2[i].y))
				{
					this.blockingTiles[k].switchBlockingTotal(false);
					this.blockingTiles.splice(k, 1); // kill the object
				}
		
		// kill ground tiles
		for(var k = 0; k < this.groundTiles2.length; k++)
			if(this.groundTiles2[k].type.isCliff)
				this.groundTiles2.splice(k, 1);
		
		fields2[i].hm = fields2[i].hm2;
	}
	
	// refresh the pre drawn blocking tiles canvasses
	this.generateTilesCanvasses();
	
	// re sort tiles
	this.sortTiles();
	
	// refresh minimap canvas, we might have killed a tile
	this.minimap.refreshTilesCanvas();
	
	// redraw ground tiles canvas
	this.generateGroundTextureCanvas();
};

// sort tiles by y coord to bring them in the right order when drawing
Game.prototype.sortTiles = function()
{
	this.objectsToDraw = _.sortBy(this.tilesCashes.concat(this.units, this.buildings), function(obj){ return obj.getYDrawingOffset(); });
};

Game.prototype.generateTilesCanvasses = function()
{
	for(var y = 0; y <= this.y; y++)
		this.refreshBlockingTilesCanvas(y);
};

Game.prototype.refreshBlockingTilesCanvas = function(y)
{
	var tiles = [];
	var maxHeight = 1;
	
	// add all tiles that have this y coordinate
	for(var i = 0; i < this.blockingTiles.length; i++)
	{
		var tile = this.blockingTiles[i];
		
		if(tile.y + tile.type.sizeY - 1 == y)
		{
			tiles.push(tile);
			var hm = this.getHMValue2(tile.x, tile.y);
			maxHeight = Math.max(maxHeight, tile.type.img.img.h + (hm ? hm : 0) * CLIFF_HEIGHT * 16);
		}
	}
	
	// sort the tiles by their exact y offset
	tiles = _.sortBy(tiles, function(tile){ return tile.randomOffsetY; });
	
	// create canvas and set parameters
	var canvas = document.createElement('canvas');
	canvas.width = (this.x + 1) * FIELD_SIZE / SCALE_FACTOR;
	canvas.height = maxHeight;
	canvas.y_ = y;
	
	canvas.getYDrawingOffset = function()
	{
		return this.y_;
	}
	
	// define draw function
	canvas.draw = function(x1, x2, y1, y2)
	{
		c.drawImage(this, -x1 * FIELD_SIZE, (this.y_ - y1) * FIELD_SIZE - this.height * SCALE_FACTOR, this.width * SCALE_FACTOR, this.height * SCALE_FACTOR);
	}
	
	canvas.isInBox = function(x1, y1, x2, y2)
	{
		return y1 < this.y_ && y2 > this.y_ - 1 && this.height > 1;
	}
	
	canvas.isInBoxVisible = canvas.isInBox;
	
	var ctx = canvas.getContext("2d");
	
	// draw the tiles on the canvas
	for(var i = 0; i < tiles.length; i++)
	{
		var tile = tiles[i];
		
		var img = (game_state == GAME.EDITOR && tile.type.img.imgEditor) ? tile.type.img.imgEditor : tile.type.img.img;
		var x_ = (tile.pos.px + tile.randomOffsetX) * 16 - img.w / 2;
		var y_ = maxHeight - img.h + (tile.randomOffsetY - this.getHMValue2(tile.x, tile.y) * CLIFF_HEIGHT) * 16;
		ctx.drawImage(tile.type.img.file[0], img.x, img.y, img.w, img.h, Math.floor(x_), Math.floor(y_), img.w, img.h);
	}
	
	this.tilesCashes[y] = canvas;
};

Game.prototype.refreshSpectatorTab = function()
{
	var index = $('#spectatorDropdown')[0].selectedIndex;
	
	if(index == 0)
		return;
	
	var fieldName = this.specFieldNames[index];
	
	// draw
	$('#spectatorDiv').html("");
	
	var x = 0;
	var y = 0;
	
	for(var i = 1; i < this.players.length; i++)
		if(this.players[i] && this.players[i].controller != CONTROLLER.SPECTATOR && playerColors[i - 1])
		{
			var p = this.players[i];
			
			x = 20;
			
			var arr = playerColors[i - 1][4];
			$('#spectatorDiv')[0].innerHTML += "<div class='playerIndicator' style='top: " + y + "px; background-color: rgb(" + arr[0] + ", " + arr[1] + ", " + arr[2] + ");'></div>";
			
			if(fieldName)
			{
				_.each(p[fieldName], function(count, type_id_string){
					
					var type = lists.types[type_id_string];
					
					var count_ = 0;
					var bar = "";
					
					if(isNaN(count))
					{
						var perc = 0;
						
						if(!count.from)
						{
							var buildTicksLeft = _.sortBy(count.to, function(el){ return el.buildTicksLeft; })[0].buildTicksLeft;
							perc = (type.getValue("buildTime", p) - buildTicksLeft) / type.getValue("buildTime", p);
						}
						else
						{
							var soonestFinish = _.sortBy(count.to, function(el){ return el; })[0];
							var soonestStart = _.sortBy(count.from, function(el){ return el; })[0];
							perc = (ticksCounter - soonestStart) / (soonestFinish - soonestStart);
						}
						
						bar = "<div class='whitebar' style='width: 52px; z-index: 1;'></div><div style='width: " + Math.floor(Math.min(perc, 1) * 50) + "px; z-index: 1;'></div>";
						count_ = count.to.length;
					}
					else
						count_ = count;
					
					var img = ((type.img && type.img.getDataURLFile) ? type.img : type.image).getDataURLFile(game.players[i].number);
					
					var rnd = "div_" + parseInt(Math.random() * 999999999);
					
					var str = "<div id='" + rnd + "' style='left: " + x + "px; top: " + y + "px; overflow: hidden;'><p style='z-index: 1;'>" + count_ + "</p>" + bar + "</div>";
					
					$('#spectatorDiv')[0].innerHTML += str;
					$('#' + rnd)[0].appendChild(img);
					
					x += 60;
					
				});
			}
			
			else if(index == 5) // mined gold
				$('#spectatorDiv')[0].innerHTML += "<div style='left: 20px; top: " + (y - 8) + "px;'><p style='font-size: 24px; right: initial; width: 400px;'>Current: <font color='#87FF73'>" + (p.currentMinedGold * 6) + "</font> &nbsp; &nbsp; Total: " + p.minedGold + " &nbsp; &nbsp; Lost: <font color='#FF7373'>" + p.goldLost + "</font></p></div>";
			
			else if(index == 6) // apm
				$('#spectatorDiv')[0].innerHTML += "<div style='left: 20px; top: " + (y - 8) + "px;'><p style='font-size: 24px;'>" + Math.floor(p.apm / (ticksCounter / 1200)) + "</p></div>";
			
			y += 60;
		}
};

Game.prototype.refreshVision = function()
{
	var p = $('#visionDropdown').val();
	
	if(p != this.oldVisionSetting)
	{
		this.oldVisionSetting = p;
		PLAYING_PLAYER.team = p > 0 ? this.players[p].team : PLAYING_PLAYER.team = this.teams[0];
		worker.postMessage({what: "requestFogMask", teamIndex: this.players[p].team.number});
	}
};

Game.prototype.getReplayFile = function()
{
	// build players info object
	var p = [];
	for(var i = 1; i < this.players.length; i++)
		if(this.players[i])
		{
			var player = this.players[i];
			p.push({
				name: player.name,
				controller: player.controller,
				team: player.originalTeam.number,
				nr: player.number,
				customAI: (player.controller == CONTROLLER.COMPUTER && player.custom_ai_index >= 0) ? true : false,
				clan: player.clan ? player.clan : ""
			});
		}
	
	// strip ticks without orders
	var orders = {};
	for(var i = 0; i <= ticksCounter; i++)
		if(incomingOrders[i] && incomingOrders[i].length > 0)
			orders[i] = incomingOrders[i];
	
	// build and return stringified replay object
	return JSON.stringify({
		map: this.name,
		mapVersion: this.data.timestamp,
		gameVersion: GAME_VERSION,
		players: p,
		aiRandomizer: this.aiRandomizer,
		ticksCounter: ticksCounter,
		orders: orders,
		messages: this.chatLog,
		playerLefts: playerLefts
	});
};

Game.prototype.addChatMsgToLog = function(msg)
{
	// if this index already exists, push the msg
	if(this.chatLog[ticksCounter])
		this.chatLog[ticksCounter].push(msg);
	
	// if the index doesnt exist, create it and add the msg
	else
		this.chatLog[ticksCounter] = [msg];
	// add to chat history window
	$('#chatHistorytextContainer')[0].innerHTML += "<p>" + msg + "</p>";
};

Game.prototype.refreshReplayButtonVisibleState = function()
{
	$('#saveReplayButton')[0].style.display = (!this.playingFromEditor && !this.replay_mode) ? "inline" : "none";
};

// refresh the neighbours of a field, gets called everytime a building gets destroyed or created
Game.prototype.refreshNBSOfField = function(field)
{
	var nbs = [];
	
	for(var x = field.x - 1; x <= field.x + 1; x++)
		for(var y = field.y - 1; y <= field.y + 1; y++)
			if((x != field.x || y != field.y) && x >= 0 && y >= 0 && x <= this.x && y <= this.y && this.blockArray[x][y] && (x == field.x || y == field.y || (this.blockArray[field.x][y] && this.blockArray[x][field.y])))
				nbs.push(this.fields[x][y]);
	
	field.nbs = nbs;
};

// refresh the neighbours of a field, gets called everytime a building gets destroyed or created (2x2)
Game.prototype.refreshNBSOfField2x2 = function(field)
{
	var nbs = [];
	
	for(var x = field.x - 1; x <= field.x + 1; x++)
		for(var y = field.y - 1; y <= field.y + 1; y++)
			if((x != field.x || y != field.y) && x >= 0 && y >= 0 && x <= this.x - 1 && y <= this.y - 1 && this.fieldIsFree2x2(x, y) && (x == field.x || y == field.y || (this.fieldIsFree2x2(field.x, y) && this.fieldIsFree2x2(x, field.y))))
				nbs.push(this.fields2x2[x][y]);
	
	field.nbs = nbs;
};

Game.prototype.fieldIsFree2x2 = function(x, y)
{
	return this.blockArray[x][y] && this.blockArray[x + 1][y] && this.blockArray[x][y + 1] && this.blockArray[x + 1][y + 1];
};

Game.prototype.generateGroundTextureCanvas = function()
{
	// set size depending on map size
	this.groundTilesCanvas.width = this.defaultTilesCanvas.width;
	this.groundTilesCanvas.height = this.defaultTilesCanvas.height;
	
	var textures = [];
	var nonTextures = [];
	
	for(var i = 0; i < this.groundTiles2.length; i++)
	{
		if(this.groundTiles2[i].type.isTexture)
			textures.push(this.groundTiles2[i]);
		
		else
			nonTextures.push(this.groundTiles2[i]);
	}
	
	var tiles = textures.concat(nonTextures);
	
	var ctx = this.groundTilesCanvas.getContext("2d");
	
	ctx.drawImage(this.defaultTilesCanvas, 0, 0);
	
	for(var i = 0; i < tiles.length; i++)
	{
		var img = tiles[i].type.img.img;
		ctx.drawImage(tiles[i].type.img.file[0], img.x, img.y, img.w, img.h, Math.floor(tiles[i].drawPos.px * 16 - img.w / 2), Math.floor((tiles[i].drawPos.py + 2) * 16 - img.h / 2), img.w, img.h);
	}
	
	ctx.fillStyle = "rgba(0, 0, 0, 0.8)";
	ctx.fillRect(0, 0, this.groundTilesCanvas.width, 32);
};

Game.prototype.getHeightmapString = function()
{
	var str = "";
	for(var x = 1; x <= this.x; x++)
		for(var y = 1; y <= this.y; y++)
			str += this.fields[x][y].hm.toString();
	return str;
};

// returns a json file which includes the whole map data including all tiles and units
Game.prototype.export_ = function(withCliffs)
{
	var unitData = {};
	
	_.each(lists.types, function(t1){
		
		var t2 = t1.getBasicType();
		var fields = t1.getDataFields();
		
		if(!t2)
			unitData[t1.id_string] = {isUnit: t1.isUnit, isBuilding: t1.isBuilding, isUpgrade: t1.isUpgrade, isCommand: t1.isCommand, isModifier: t1.isModifier};
		
		_.each(fields, function(field){
			
			if(field.isArray)
			{
				if(!t2 || !arraysAreSame(t1[field.name], typeof t2[field.name] === "undefined" ? field.default2_ : t2[field.name], field.values))
				{
					if(!unitData[t1.id_string])
						unitData[t1.id_string] = {};
					
					var arr = [];
					
					if(t1[field.name])
						for(var j = 0; j < t1[field.name].length; j++)
						{
							if(isObject(t1[field.name][j]) && t1[field.name][j].id_string)
								arr[j] = t1[field.name][j].id_string;
							
							else if(isObject(t1[field.name][j]) && t1[field.name][j].isTargetRequirement)
								arr[j] = t1[field.name][j].funcName;
							
							else
								arr[j] = t1[field.name][j];
						}
					
					unitData[t1.id_string][field.name] = arr;
				}
			}
			
			else if(field.type == "commands")
			{
				if(!t2 || !objectsAreSame(t1[field.name], t2[field.name], lists.types))
				{
					if(!unitData[t1.id_string])
						unitData[t1.id_string] = {};
					
					var obj = {};
					
					_.each(t1[field.name], function(val, key){
						obj[key] = val.id_string;
					});
					
					unitData[t1.id_string][field.name] = obj;
				}
			}
			
			else
			{
				if(!t2 || (typeof t1[field.name] !== "undefined" && t1[field.name] != (typeof t2[field.name] === "undefined" ? field.default_ : (field.values && (typeof t2[field.name] == "string") && field.values[t2[field.name]]) ? field.values[t2[field.name]] : t2[field.name])))
				{
					if(!unitData[t1.id_string])
						unitData[t1.id_string] = {};
					
					var dataToWrite = t1[field.name];
					
					if(isObject(dataToWrite))
					{
						if(getBuildingImgNameFromImgObject(dataToWrite)) // building img
							dataToWrite = getBuildingImgNameFromImgObject(dataToWrite);
						
						else if(dataToWrite.name && dataToWrite.file) // unit img
							dataToWrite = dataToWrite.id_string;
						
						else if(dataToWrite.id_string) // other type
							dataToWrite = dataToWrite.id_string;
					}
					
					else if(_.isFunction(dataToWrite))
						dataToWrite = getImageFunctionName(dataToWrite);
					
					unitData[t1.id_string][field.name] = dataToWrite;
				}
			}
		});
	});
	
	var graphics = {};
	for(key in customImgs)
		if(!unit_imgs[key] && !building_imgs[key] && key != "buildingSheet" && key != "tileSheet" && key != "miscSheet")
			graphics[key] = customImgs[key][0].src;
	
	var graphicObjects = {};
	_.each(lists.imgs, function(t1){
		
		if(t1)
		{
			var t2 = t1.getBasicType();
			var fields = t1.getDataFields();
			
			if(!t2)
				unitData[t1.id_string] = {isGraphic: true};
			
			_.each(fields, function(field){
				
				if(field.type == "complex")
				{
					if(t1[field.name] && !mapEditorData.fieldIsDefault(field, t1))
					{
						if(!graphicObjects[t1.id_string])
							graphicObjects[t1.id_string] = {};
						
						graphicObjects[t1.id_string][field.name] = {
							x: t1[field.name].x,
							y: t1[field.name].y,
							w: t1[field.name].w,
							h: t1[field.name].h,
							frameWidth: t1[field.name].frameWidth,
							frames: t1[field.name].frames
						};
					}
				}
				
				else if(field.name == "file")
				{
					if(!t2 || t1[field.name] != t2[field.name])
					{
						if(!graphicObjects[t1.id_string])
							graphicObjects[t1.id_string] = {};
						
						for(key_ in customImgs)
							if(customImgs[key_] == t1[field.name])
								graphicObjects[t1.id_string][field.name] = key_;
					}
				}
				
				else
				{
					if(!t2 || (typeof t1[field.name] !== "undefined" && t1[field.name] != (typeof t2[field.name] === "undefined" ? field.default_ : (field.values && (typeof t2[field.name] == "string") && field.values[t2[field.name]]) ? field.values[t2[field.name]] : t2[field.name])))
					{
						if(!graphicObjects[t1.id_string])
							graphicObjects[t1.id_string] = {};
						
						var dataToWrite = t1[field.name];
						
						if(isObject(dataToWrite))
						{
							if(getBuildingImgNameFromImgObject(dataToWrite)) // building img
								dataToWrite = getBuildingImgNameFromImgObject(dataToWrite);
							
							else if(dataToWrite.name && dataToWrite.file) // unit img
								dataToWrite = dataToWrite.name;
							
							else if(dataToWrite.id_string) // other type
								dataToWrite = dataToWrite.id_string;
						}
						
						else if(_.isFunction(dataToWrite))
							dataToWrite = getImageFunctionName(dataToWrite);
						
						graphicObjects[t1.id_string][field.name] = dataToWrite;
					}
				}
			});
		}
		
	});
	
	var data = {
		name: this.name,
		x: this.x,
		y: this.y,
		tiles: [],
		groundTiles: [],
		units: [],
		buildings: [],
		defaultTiles: this.data.defaultTiles,
		heightmap: this.getHeightmapString(),
		unitData: unitData,
		description: this.description,
		globalVars: this.globalVars,
		players: getPlayerSettings(),
		graphics: graphics,
		graphicObjects: graphicObjects
	};
	
	var tiles = this.groundTiles2.concat(this.blockingTiles);
	for(var i = 0; i < tiles.length; i++)
		if(!tiles[i].type.isCliff || withCliffs) // dont save default tiles (= ground textures), they are generated randomly at each mapload and dont save cliff tiles, they are created from heightmap
		{
			if(tiles[i].type.ignoreGrid)
				data.tiles.push({x: tiles[i].pos.px, y: tiles[i].pos.py, type: tiles[i].type.name});
			else
				data.tiles.push({x: tiles[i].x, y: tiles[i].y, type: tiles[i].type.name});
		}
	
	for(var i = 0; i < this.units.length; i++)
	{
		var u = this.units[i];
		var o = {x: u.pos.px, y: u.pos.py, type: u.type.name, owner: u.owner.number, waypoint: this.getWaypointExportObject(u.waypoint)};
		data.units.push(o);
	}
	
	for(var i = 0; i < this.buildings.length; i++)
	{
		var u = this.buildings[i];
		var o = {x: u.x, y: u.y, type: u.type.name, owner: u.owner.number, waypoint: this.getWaypointExportObject(u.waypoint)};
		data.buildings.push(o);
	}
		
	return data;
};

Game.prototype.getWaypointExportObject = function(wp)
{
	if(wp)
	{
		var arr = [];
		for(var i = 0; i < wp.length; i++)
			if(wp[i].px)
				arr.push(wp[i].px, wp[i].py);
		
		return arr;
	}
}

Game.prototype.getUnitById = function(id)
{
	return this.unitList[id];
};

Game.prototype.getNextBuildingOfType = function(pos, owner, onlyFinished, filter)
{
	var shortestDistance = 999999;
	var building = null;
	
	for(var i = 0; i < this.buildings.length; i++)
	{
		var b = this.buildings[i];
		if((!filter || b.type[filter]) && pos.distanceTo2(b.pos) < shortestDistance && (!owner || owner == b.owner) && (!onlyFinished || !b.isUnderConstruction))
		{
			building = b;
			shortestDistance = pos.distanceTo2(b.pos);
		}
	}
	
	return building;
};

Game.prototype.unitMatchesFilters = function(unit, command)
{
	if(unit && unit.type)
		for(var k = 0; k < command.targetRequiremementsArray.length; k++)
		{
			var met = false;
			
			for(var i = 0; i < command.targetRequiremementsArray[k].length; i++)
				if(command.targetRequiremementsArray[k][i].func(unit))
					met = true;
			
			if(!met)
				return false;
		}
	
	return true;
};

// get unit at specific position (usually to check if where we clicked is a unit and which one) or for hover effect
Game.prototype.getUnitAtPosition = function(x, y, filters)
{
	var bestUnit = null;
	var lowestDistance = 99999;
	var clickedField = new Field(x, y, true);
	
	for(var i = 0; i < this.units.length; i++)
	{
		var unit = this.units[i];
		var dist = unit.pos.distanceTo2(clickedField);
		
		if((game_state == GAME.EDITOR || PLAYING_PLAYER.team.canSeeUnitInvisible(unit) || PLAYING_PLAYER.controller == CONTROLLER.SPECTATOR) && unit.isInBox(x - CLICK_TOLERANCE, y - CLICK_TOLERANCE + unit.type.selectionOffsetY, x + CLICK_TOLERANCE, y + CLICK_TOLERANCE + 0.4 + unit.type.selectionOffsetY) && lowestDistance > dist && PLAYING_PLAYER.team.canSeeUnit(unit))
			if(!filters || this.unitMatchesFilters(unit, filters))
			{
				lowestDistance = dist;
				bestUnit = unit;
			}
	}
	
	if(bestUnit)
		return bestUnit;
	
	lowestDistance = 99999;
	for(var i = 0; i < this.buildings2.length; i++)
	{
		var building = this.buildings2[i];
		var dist = building.pos.distanceTo2(clickedField);
		
		var selectionOffsetY = building.type.selectionOffsetY || 0;
		if(building.seenBy[PLAYING_PLAYER.team.number] && building.isInBox(x - CLICK_TOLERANCE, y - CLICK_TOLERANCE + selectionOffsetY, x + CLICK_TOLERANCE, y + CLICK_TOLERANCE + selectionOffsetY + 0.4) && lowestDistance > dist)
		{
			lowestDistance = dist;
			bestUnit = building;
		}
	}
	return bestUnit;
};

// return unit-array based on the coordinates of a box drawn (if double click or strg == true and single click, select all units of this type in the screen region)
Game.prototype.getSelection = function(x1, y1, x2, y2, strg)
{
	var units = [];
	
	// if click (no box), then look for nearest valiable unit and select this one
	if(x2 - x1 <= 0.05 && y2 - y1 <= 0.05)
	{
		var newUnit = this.getUnitAtPosition(x1, y1);
		
		// if strg+click or doubleclick
		if(newUnit && newUnit.owner == PLAYING_PLAYER && (strg || (this.timeOfLastSelection + 500 >= timestamp && /*game.selectedUnits.length == 1 &&*/ newUnit == game.selectedUnits[0])))
		{
			var unitsAndBuildings = this.units.concat(this.buildings);
			for(var i = 0; i < unitsAndBuildings.length; i++)
			{
				var u = unitsAndBuildings[i];
				if((game_state == GAME.EDITOR || PLAYING_PLAYER.team.canSeeUnitInvisible(u) || PLAYING_PLAYER.controller == CONTROLLER.SPECTATOR) && u.isInBox(game.cameraX / FIELD_SIZE, game.cameraY / FIELD_SIZE, (WIDTH + game.cameraX) / FIELD_SIZE, (HEIGHT - INTERFACE_HEIGHT + game.cameraY) / FIELD_SIZE) && u.type == newUnit.type && u.owner == PLAYING_PLAYER)
					units.push(u);
			}
			
			return units;
		}
		
		return newUnit ? [newUnit] : [];
	}
	
	var countEnemyUnitsSelected = 0; // also buildings
	var countOwnUnitsSelected = 0; // also buildings
	var countOwnBildingsSelected = 0;
	var unitsAndBuildings = this.units.concat(this.buildings);
	var selected_type_id_strings = {};
	
	for(var i = 0; i < unitsAndBuildings.length; i++)
	{
		var u = unitsAndBuildings[i];
		if((game_state == GAME.EDITOR || PLAYING_PLAYER.team.canSeeUnitInvisible(u) || PLAYING_PLAYER.controller == CONTROLLER.SPECTATOR) && u.isInBox(x1, y1 + u.type.selectionOffsetY, x2, y2 + u.type.selectionOffsetY))
		{
			if(strg)
				selected_type_id_strings[u.type.id_string] = true;
			else
			{
				units.push(u);
				countEnemyUnitsSelected += u.owner != PLAYING_PLAYER ? 1 : 0;
				countOwnUnitsSelected += u.owner == PLAYING_PLAYER ? 1 : 0;
				countOwnBildingsSelected += (u.owner == PLAYING_PLAYER && u.type.isBuilding) ? 1 : 0;
			}
		}
	}
	
	if(strg)
		for(var i = 0; i < unitsAndBuildings.length; i++)
		{
			var u = unitsAndBuildings[i];
			if(selected_type_id_strings[u.type.id_string] && ((game_state == GAME.EDITOR || PLAYING_PLAYER.team.canSeeUnitInvisible(u) || PLAYING_PLAYER.controller == CONTROLLER.SPECTATOR) && u.isInBox(game.cameraX / FIELD_SIZE, game.cameraY / FIELD_SIZE, (WIDTH + game.cameraX) / FIELD_SIZE, (HEIGHT - INTERFACE_HEIGHT + game.cameraY) / FIELD_SIZE) && u.owner == PLAYING_PLAYER))
			{
				units.push(u);
				countEnemyUnitsSelected += u.owner != PLAYING_PLAYER ? 1 : 0;
				countOwnUnitsSelected += u.owner == PLAYING_PLAYER ? 1 : 0;
				countOwnBildingsSelected += (u.owner == PLAYING_PLAYER && u.type.isBuilding) ? 1 : 0;
			}
		}
	
	// if were in the editor, were allowed to select multiple enemy units and multiple whatever, so return here and dont perform the deselect stuff
	if(game_state == GAME.EDITOR || PLAYING_PLAYER.controller == CONTROLLER.SPECTATOR)
		return units;
	
	// if own and enemy units selected, unselect all enemy units
	if(countOwnUnitsSelected > 0 && countEnemyUnitsSelected > 0)
		for(var i = 0; i < units.length; i++)
			if(units[i].owner != PLAYING_PLAYER)
			{
				units.splice(i, 1);
				i--;
			}

	// if no own but more than 1 enemy units selected, unselect all but 1 enemy units
	if(countOwnUnitsSelected == 0 && countEnemyUnitsSelected > 0)
		units = [units[0]];
	
	// if only buildings selected, unselect all but 1
	if(units.length > 1 && countOwnBildingsSelected == units.length)
		units.length = 1;
	
	// if buildings but also units selected, unselect all buildings
	if(countOwnBildingsSelected > 0 && countOwnUnitsSelected - countOwnBildingsSelected > 0)
		for(var i = 0; i < units.length; i++)
			if(units[i].type.isBuilding)
			{
				units.splice(i, 1);
				i--;
			}
	
	return units;
};

// adding new units to an existing selection, removing duplicates and not allowing buildings & units or units from several players
Game.prototype.addUnitsToSelection = function(selection, newUnits)
{
	// if no new units, nothing to do
	if(newUnits.length == 0)
		return;
	
	// if no existing units, just replace selected units with the new units
	if(selection.length == 0)
	{
		selection = newUnits;
		return;
	}
	
	if(newUnits[0].owner == PLAYING_PLAYER && selection[0].owner == PLAYING_PLAYER && (selection[0].type.isBuilding && newUnits[0].type.isBuilding) || (!selection[0].type.isBuilding && !newUnits[0].type.isBuilding))
	{
		var newUnitsContainUnselectedUnits = false;
		
		for(var i = 0; i < newUnits.length; i++)
			if(!selection.contains(newUnits[i]))
				newUnitsContainUnselectedUnits = true;
		
		for(var i = 0; i < newUnits.length; i++)
		{
			if(selection.contains(newUnits[i]))
			{
				if(!newUnitsContainUnselectedUnits)
					selection.erease(newUnits[i]);
			}
			else
				selection.push(newUnits[i]);
		}
	}
};

// check if the current selected units belong to the playing player
Game.prototype.humanUnitsSelected = function()
{
	return this.selectedUnits.length > 0 && this.selectedUnits[0].owner == PLAYING_PLAYER;
};

Game.prototype.getGameStateCheckSum = function()
{
	var checksum = 0;
	
	for(var i = 0; i < this.units.length; i++)
		checksum += this.units[i].pos.px + this.units[i].pos.py;
	
	return checksum;
};

Game.prototype.fieldIsBlocked = function(x, y)
{
	return !(x > 0 && x <= this.x && y > 0 && y <= this.y && this.blockArray[x][y]);
};

Game.prototype.fieldIsBlockedForBuilding = function(x, y)
{
	return !(x > 0 && x <= this.x && y > 0 && y <= this.y && this.blockArray[x][y] && this.fields[x][y].hm == parseInt(this.fields[x][y].hm));
};

Game.prototype.fieldIsBlockedFlying = function(x, y)
{
	return !(x > 0 && x <= this.x && y > 2 && y <= this.y);
};

// get the center of a group of units
Game.prototype.getCenterOfUnits = function(units)
{
	var x = 0;
	var y = 0;
	
	for(var i = 0; i < units.length; i++)
	{
		x += units[i].pos.px;
		y += units[i].pos.py;
	}
	
	return new Field(x / units.length, y / units.length, true);
};

// return true, if at least one of the selected units can perform a specific order; only the units matching 'type' are checked
Game.prototype.selectedUnitsCanPerformOrder = function(order, type)
{
	// loop through all units, and check if one of the highest prio units can perform the order
	var units = this.selectedUnits;
	for(var i = 0; i < units.length; i++)
		if(units[i].type == type)
		{
			if(units[i].type.commands[order.id_string] && (!units[i].type.isBuilding || !units[i].isUnderConstruction))
				return true;
			
			if(order.type == COMMAND.CANCEL && units[i].type.isBuilding && (units[i].isUnderConstruction || units[i].queue[0]))
				return true;
		}
	
	return false;
};

Game.prototype.playerHasIdleWorkers = function(player)
{
	for(var i = 0; i < this.units.length; i++)
		if(this.units[i].owner == player && this.units[i].type == lists.types.worker && (!this.units[i].order || this.units[i].order.type == COMMAND.IDLE))
			return true;
	return false;
};

Game.prototype.getOrderArray = function(units, order, target, shift, autoCast, on, learn)
{
		// make array with target and order
		var o;
		
		if(learn)
			o = ["learn", order.id];
		
		else if(autoCast)
			o = ["ac", order.id, on];
		
		else if(!target)
			o = ["instant", order.id, shift];
		
		else if(target.isField)
			o = ["field", order.id, shift, target.px, target.py];
		
		else if(order.targetIsInt)
			o = ["int", order.id, shift, parseInt(target)];
		
		else
			o = ["unit", order.id, shift, target.id];
		
		// add all the selected units
		for(var i = 0; i < units.length; i++)
			o.push(units[i].id);
		
		return o;
};

Game.prototype.getUnitsWithRdyCooldown = function(cmd)
{
	var units = this.selectedUnits.slice();
	
	for(var i = 0; i < units.length; i++)
		if(units[i].lastTickAbilityUsed[cmd.id] + cmd.getValue("cooldown2", units[i]) > ticksCounter)
		{
			units.splice(i, 1);
			i--;
		}
	
	return units;
};

// store an order 
Game.prototype.issueOrderToUnits = function(units, order, target, shift, autoCast, on, learn)
{
	if(!units || units.length == 0)
		return;
	
	if(learn)
	{
		if(network_game)
			outgoingOrders.push(this.getOrderArray(units, order, target, shift, autoCast, on, true));
		
		else
			worker.postMessage({what: "order", msg: [units[0].owner.number].concat(this.getOrderArray(units, order, target, shift, autoCast, on, true))});
		
		return;
	}
	
	// check for cooldown
	units = order.cooldown2 ? game.getUnitsWithRdyCooldown(order) : game.selectedUnits;
	
	if(units.length == 0)
	{
		interface_.addMessage("Cooldown not ready", "red", imgs.attentionmark);
		soundManager.playSound(SOUND.NEGATIVE);
		return;
	}
	
	// if attacking invincible unit (Goldmine) and drawing and playingplayer, create msg and sound
	if(order.type == COMMAND.ATTACK && target.getValue("isInvincible"))
	{
		// if drawing, show alert
		if(units[0].owner == PLAYING_PLAYER)
		{
			interface_.addMessage("This " + (target.type.isBuilding ? "building" : "unit") + " is invincible.", "red", imgs.attentionmark);
			soundManager.playSound(SOUND.NEGATIVE);
		}
		
		return;
	}
	
	// check for target requirements
	var requirement_text = !autoCast ? units[0].owner.getCommandRequirementText(order, units, target) : null;
	
	if(requirement_text)
	{
		// if drawing, show alert
		if(units[0].owner == PLAYING_PLAYER)
		{
			interface_.addMessage(requirement_text, "red", imgs.attentionmark);
			soundManager.playSound(SOUND.NEGATIVE);
		}
		
		return;
	}
	
	if(network_game)
		outgoingOrders.push(this.getOrderArray(units, order, target, shift, autoCast, on));
	
	else
		worker.postMessage({what: "order", msg: [units[0].owner.number].concat(this.getOrderArray(units, order, target, shift, autoCast, on))});
};

Game.prototype.getReplayName = function()
{
	var str = "";
	
	for(var i = 0; i < this.players.length; i++)
		if(this.players[i] && this.players[i].originalTeam.number > 0)
			str += this.players[i].name  + "_v_";
	
	if(str.length > 2)
		str = str.substring(0, str.length - 2);
	
	str += "on_" + this.data.name;
	
	return str;
};

Game.prototype.selectionContainsCargoUnits = function()
{
	for(var i = 0; i < this.selectedUnits.length; i++)
		if(this.selectedUnits[i].type.cargoSpace)
			return true;
	return false;
};

Game.prototype.selectionContainsWorkers = function()
{
	for(var i = 0; i < this.selectedUnits.length; i++)
		if(this.selectedUnits[i].type == lists.types.worker)
			return true;
	return false;
}

Game.prototype.addObject = function(o)
{
	if(o.type && o.type.isUnit)
		this.units.push(o);
	
	else if(o.type && o.type.isBuilding && !o.isDummy)
	{
		this.buildings.push(o);
		this.buildings2.push(o);
	}
	
	if(!o.isDummy)
		this.unitList[o.id] = o;
	
	this.addToObjectsToDraw(o);
};

Game.prototype.addToObjectsToDraw = function(o)
{
	for(var i = 0; i < this.objectsToDraw.length; i++)
		if(this.objectsToDraw[i].getYDrawingOffset() > o.getYDrawingOffset())
		{
			this.objectsToDraw.splice(i, 0, o);
			return;
		}
	this.objectsToDraw.push(o);
};

Game.prototype.draw = function()
{
	// limit the max zoom, users can archive with their browser zoom
	var maxViewSize = 1200 / 2;
	
	if(HEIGHT / SCALE_FACTOR > maxViewSize)
	{
		var middle_x = (game.cameraX + WIDTH / 2) / FIELD_SIZE;
		var middle_y = (game.cameraY + HEIGHT / 2) / FIELD_SIZE;
		
		SCALE_FACTOR = HEIGHT / maxViewSize;
		FIELD_SIZE = 16 * SCALE_FACTOR;
		
		game.cameraX = middle_x * FIELD_SIZE - WIDTH / 2;
		game.cameraY = middle_y * FIELD_SIZE - HEIGHT / 2;
	}
	
	// limit the max zoom, users can archive with their browser zoom
	if(HEIGHT > 1200)
	{
		var max_scale = HEIGHT / maxViewSize;
		
		if(SCALE_FACTOR < max_scale)
		{
			SCALE_FACTOR = max_scale;
			FIELD_SIZE = 16 * SCALE_FACTOR;
		}
	}
		
	var oldCameraX = this.cameraX;
	var oldCameraY = this.cameraY;
	
	// Scrolling
	if(!game_paused || PLAYING_PLAYER.controller == CONTROLLER.SPECTATOR)
	{
		var mouseScrollEnabled = (document.fullScreen || document.mozFullScreen || document.webkitIsFullScreen || mouse_scroll_when_window_mode) && timeDiff < 1;
		
		if(keyManager.keys[KEY.M] && this.lastMuteToggle + 10 <= ticksCounter)
		{
			this.enableChat(!this.chat_muted);
			this.lastMuteToggle = ticksCounter;
		}
		if(keyManager.keys[KEY.DOWN] || keyManager.y >= HEIGHT - SCROLL_RANGE && mouseScrollEnabled)
			this.cameraY += timeDiff * scrollSpeed;
		
		if(keyManager.keys[KEY.UP] || keyManager.y <= 25 && mouseScrollEnabled)
			this.cameraY -= timeDiff * scrollSpeed;
		
		if(keyManager.keys[KEY.LEFT] || keyManager.x <= SCROLL_RANGE && mouseScrollEnabled)
			this.cameraX -= timeDiff * scrollSpeed;
		
		if(keyManager.keys[KEY.RIGHT] || keyManager.x >= WIDTH - SCROLL_RANGE && mouseScrollEnabled)
			this.cameraX += timeDiff * scrollSpeed;
		
		// Minimap click change screen
		if(keyManager.minimapScroll && keyManager.x < MINIMAP_WIDTH && keyManager.y > HEIGHT - MINIMAP_HEIGHT)
		{
			var field = this.minimap.getFieldFromClick(keyManager.x, keyManager.y);
			
			this.cameraX = Math.floor(field.px * FIELD_SIZE - WIDTH / 2);
			this.cameraY = Math.floor(field.py * FIELD_SIZE - HEIGHT / 2);
		}
		
		// clicking portrait scrolling (following unit)
		var unitNfoX = (WIDTH - 780) / 2;
		if(this.selectedUnits.length == 1 && (keyManager.keys[KEY.SPACE] || (keyManager.leftMouse && keyManager.x > unitNfoX && keyManager.y > HEIGHT - INTERFACE_HEIGHT + 20 && keyManager.x < unitNfoX + 140)))
		{
			this.cameraX = this.selectedUnits[0].drawPos.px * FIELD_SIZE - WIDTH / 2;
			this.cameraY = this.selectedUnits[0].drawPos.py * FIELD_SIZE - HEIGHT / 2;
		}
	}
	
	// if camera is out of bounds, bring it back
	this.cameraX = Math.floor(Math.min(this.cameraX, this.x * FIELD_SIZE - WIDTH));
	this.cameraY = Math.floor(Math.min(this.cameraY, (this.y - this.getHMValue(1, this.y) * CLIFF_HEIGHT) * FIELD_SIZE - HEIGHT + (game_state == GAME.EDITOR ? MINIMAP_HEIGHT : INTERFACE_HEIGHT)));
	this.cameraX = Math.floor(Math.max(this.cameraX, 0));
	this.cameraY = Math.floor(Math.max(this.cameraY, /* -FIELD_SIZE * 2*/ 0));
	
	if(keyManager.drawBox && (oldCameraX != this.cameraX || oldCameraY != this.cameraY))
	{
		keyManager.startX -= this.cameraX - oldCameraX;
		keyManager.startY -= this.cameraY - oldCameraY;
	}
	
	// unselected units
	if(game_state == GAME.PLAYING)
		for(var i = 0; i < this.selectedUnits.length; i++)
			if(!PLAYING_PLAYER.team.canSeeUnit(this.selectedUnits[i], true) || (!(PLAYING_PLAYER.team.canSeeUnitInvisible(this.selectedUnits[i]) || PLAYING_PLAYER.controller == CONTROLLER.SPECTATOR)))
			{
				this.selectedUnits.splice(i, 1);
				i--;
			}
	
	var unitsBuildings = this.buildings2.concat(this.units);
	
	var hoverUnit = null;
	
	// clear screen
	c.fillStyle = "black";
	c.fillRect(0, 0, WIDTH, HEIGHT);
	
	// draw GroundTiles canvas
	var drawW = Math.min(WIDTH, this.groundTilesCanvas.width * SCALE_FACTOR);
	var drawH = Math.min(HEIGHT - (game_state == GAME.EDITOR ? MINIMAP_HEIGHT : INTERFACE_HEIGHT), this.groundTilesCanvas.height * SCALE_FACTOR);
	c.drawImage(this.groundTilesCanvas, this.cameraX / SCALE_FACTOR, (this.cameraY + 2 * FIELD_SIZE) / SCALE_FACTOR, drawW / SCALE_FACTOR, drawH / SCALE_FACTOR, 0, 0, drawW, drawH);
	
	// calculate gameplay screen coords
	var x1 = this.cameraX / FIELD_SIZE;
	var y1 = this.cameraY / FIELD_SIZE;
	var x2 = (this.cameraX + WIDTH) / FIELD_SIZE;
	var y2 = (this.cameraY + HEIGHT) / FIELD_SIZE;
	
	// editor grid
	if(game_state == GAME.EDITOR && $('#showGridCheckbox')[0].checked)
	{
		c.lineWidth = 1;
		c.strokeStyle = "rgba(" + this.theme.line_red + ", " + this.theme.line_green + ", " + this.theme.line_blue + ", 0.7)";
		c.beginPath();
		
		var y_ = Math.ceil(y1) * FIELD_SIZE - this.cameraY + 0.5;
		
		while(y_ < HEIGHT - INTERFACE_HEIGHT)
		{
			c.moveTo(0, y_);
			c.lineTo(WIDTH, y_);
			
			y_ += FIELD_SIZE;
		}
		
		var x_ = Math.ceil(x1) * FIELD_SIZE - this.cameraX + 0.5;
		
		while(x_ < WIDTH)
		{
			c.moveTo(x_, 0);
			c.lineTo(x_, HEIGHT - INTERFACE_HEIGHT);
			
			x_ += FIELD_SIZE;
		}
		
		c.stroke();
		c.closePath();
		
		// make middle lines red
		if(this.x / 2 > x1 && this.x / 2 < x2 && this.x % 2 == 0)
		{
			var x2_ = (this.x / 2) * FIELD_SIZE - this.cameraX + 0.5;
			
			c.strokeStyle = "rgba(255, 0, 0, 0.9)";
			c.beginPath();
			c.moveTo(x2_, 0);
			c.lineTo(x2_, HEIGHT - INTERFACE_HEIGHT);
			c.stroke();
			c.closePath();
		}
		
		// make middle lines red
		if(this.y / 2 > y1 && this.y / 2 < y2 && this.y % 2 == 0)
		{
			var y2_ = (this.y / 2) * FIELD_SIZE - this.cameraY + 0.5;
			
			c.strokeStyle = "rgba(255, 0, 0, 0.9)";
			c.beginPath();
			c.moveTo(0, y2_);
			c.lineTo(WIDTH, y2_);
			c.stroke();
			c.closePath();
		}
	}
	
	// calculate exact drawing positions (interpolate between real positions)
	for(var i = 0; i < this.units.length; i++)
		this.units[i].updateDrawPosition();
	
	// mark selected units
	for(var i = 0; i < this.selectedUnits.length; i++)
		this.selectedUnits[i].lastSelectionTime = timestamp;
		
	// mark hover units
	if(keyManager.drawBox)
	{
		var x1n = (Math.min(keyManager.x, keyManager.startX) + this.cameraX) / FIELD_SIZE;
		var x2n = (Math.max(keyManager.x, keyManager.startX) + this.cameraX) / FIELD_SIZE;
		var y1n = (Math.min(keyManager.y, keyManager.startY) + this.cameraY) / FIELD_SIZE;
		var y2n = (Math.max(keyManager.y, keyManager.startY) + this.cameraY) / FIELD_SIZE;
		
		for(var i = 0; i < unitsBuildings.length; i++)
		{
			var u = unitsBuildings[i];
			
			if(u.isAlive && u.isInBox(x1n, y1n + u.type.selectionOffsetY, x2n, y2n + u.type.selectionOffsetY) && PLAYING_PLAYER.team.canSeeUnit(u, true) && (PLAYING_PLAYER.team.canSeeUnitInvisible(u) || PLAYING_PLAYER.controller == CONTROLLER.SPECTATOR))
				u.lastHoverTime = timestamp;
		}
	}
	
	// mark curser hovering unit
	else if(!keyManager.command || keyManager.command.targetIsUnit)
	{
		hoverUnit = this.getUnitAtPosition((keyManager.x + this.cameraX) / FIELD_SIZE, (keyManager.y + this.cameraY) / FIELD_SIZE);
		hoverUnit = (hoverUnit && PLAYING_PLAYER.team.canSeeUnit(hoverUnit, true)) ? hoverUnit : null;
		
		if(hoverUnit && (PLAYING_PLAYER.team.canSeeUnitInvisible(hoverUnit) || PLAYING_PLAYER.controller == CONTROLLER.SPECTATOR))
			hoverUnit.lastHoverTime = timestamp;
	}
	
	
	// selection circcles of tiles (if editor)
	if(game_state == GAME.EDITOR)
		for(var i = 0; i < this.selectedUnits.length; i++)
			if(this.selectedUnits[i].type.isTile)
				drawCircle(this.selectedUnits[i].drawPos.px * FIELD_SIZE - this.cameraX, (this.selectedUnits[i].drawPos.py + this.selectedUnits[i].getValue("circleOffset")) * FIELD_SIZE - this.cameraY, this.selectedUnits[i].getValue("circleSize") * FIELD_SIZE, this.selectedUnits[i].owner.getAllyColor());
	
	// draw all objects
	var objectsToDraw = this.objectsToDraw.slice();
	for(var i = 0; i < objectsToDraw.length; i++)
	{
		var u = objectsToDraw[i];
		
		if(u.isInBoxVisible(x1, y1, x2, y2))
		{
			// selection circles or blinking circles
			if(u.lastSelectionTime == timestamp && u.isThrowedUntil < ticksCounter)
				drawCircle(u.drawPos.px * FIELD_SIZE - this.cameraX, (u.drawPos.py + u.getValue("circleOffset")) * FIELD_SIZE - this.cameraY, u.getValue("circleSize") * FIELD_SIZE, u.owner.getAllyColor());
			
			// hover circles
			if(u.isThrowedUntil < ticksCounter && ((u.lastBlinkStart && u.lastBlinkStart + 1000 > timestamp && (timestamp - u.lastBlinkStart) % 200 < 100) || (u.lastHoverTime == timestamp && (!u.lastBlinkStart || u.lastBlinkStart + 1000 <= timestamp))))
				drawCircle(u.drawPos.px * FIELD_SIZE - this.cameraX, (u.drawPos.py + u.getValue("circleOffset")) * FIELD_SIZE - this.cameraY, u.getValue("circleSize") * FIELD_SIZE, u.owner.getAllyColor(), u.owner.getAllyColor(0.4));
			
			u.draw(x1, x2, y1, y2);
		}
		
		if(u.isEffect && u.isExpired())
			this.objectsToDraw.erease(u);
	}
	
	// draw health bars
	for(var i = 0; i < unitsBuildings.length; i++)
	{
		var unit = unitsBuildings[i];
		
		if(PLAYING_PLAYER.team.canSeeUnit(unit, true) && (PLAYING_PLAYER.team.canSeeUnitInvisible(unit) || PLAYING_PLAYER.controller == CONTROLLER.SPECTATOR) && unit.isAlive && unit.isInBoxVisible(x1, y1, x2, y2))
		{
			var x = (unit.drawPos.px - unit.type.healthbarWidth / 2) * FIELD_SIZE - game.cameraX;
			var y = (unit.drawPos.py - unit.type.healthbarOffset) * FIELD_SIZE - game.cameraY;
			
			if(!unit.type.isInvincible && (!noShowHPBarsWhenFullHP || unit.hp < unit.getValue("hp")))
			{
				unit.drawHealthbar(x, y, unit.type.healthbarWidth * FIELD_SIZE, 0.125 * FIELD_SIZE, SCALE_FACTOR / 2);
				y -= FIELD_SIZE * 0.16;
			}
			
			if(unit.type.mana)
			{
				unit.drawManabar(x, y, unit.type.healthbarWidth * FIELD_SIZE, 0.125 * FIELD_SIZE, SCALE_FACTOR / 2);
				y -= FIELD_SIZE * 0.16;
			}
			
			if(unit.type.lifetime)
			{
				unit.drawLifetimebar(x, y, unit.type.healthbarWidth * FIELD_SIZE, 0.125 * FIELD_SIZE, SCALE_FACTOR / 2);
				y -= FIELD_SIZE * 0.16;
			}
			
			if(unit.owner == PLAYING_PLAYER && unit.cargo && unit.cargo.length > 0)
			{
				unit.drawLoadbar(x, y, unit.type.healthbarWidth * FIELD_SIZE, 0.125 * FIELD_SIZE, SCALE_FACTOR / 2);
				y -= FIELD_SIZE * 0.16;
			}
			
			if((unit.owner == PLAYING_PLAYER || PLAYING_PLAYER.controller == CONTROLLER.SPECTATOR) && unit.queue[0])
				unit.drawProgressBar(x, y, unit.type.healthbarWidth * FIELD_SIZE, 0.125 * FIELD_SIZE, SCALE_FACTOR / 2);
		}
		
		// draw workload
		if(unit.gold && unit.type.startGold && unit.countWorkingWorkers > 0)
		{
			var workload = unit.getWorkload();
			
			drawText(c, "Workload", "white", "bold " + (SCALE_FACTOR * 6) + "px LCDSolid", unit.drawPos.px * FIELD_SIZE - this.cameraX, (unit.drawPos.py - unit.type.healthbarOffset * 0.3) * FIELD_SIZE - this.cameraY, 999, "center", null, "rgba(0, 0, 0, 0.5)", null, (SCALE_FACTOR * 6));
			drawText(c, workload + " %", "white", "bold " + (SCALE_FACTOR * 6) + "px LCDSolid", unit.drawPos.px * FIELD_SIZE - this.cameraX, (unit.drawPos.py - unit.type.healthbarOffset * 0.1) * FIELD_SIZE - this.cameraY, 999, "center", null, "rgba(0, 0, 0, 0.5)", null, (SCALE_FACTOR * 6));
			
			c.strokeStyle = "white";
			c.fillStyle = "white";
			c.strokeRect(unit.drawPos.px * FIELD_SIZE - this.cameraX - FIELD_SIZE  * 1.1, (unit.drawPos.py + unit.type.healthbarOffset * 0.0) * FIELD_SIZE - this.cameraY, FIELD_SIZE * 2.2, FIELD_SIZE * 0.3);
			c.fillRect(unit.drawPos.px * FIELD_SIZE - this.cameraX - FIELD_SIZE  * 1.05, (unit.drawPos.py + unit.type.healthbarOffset * 0.0 + 0.05) * FIELD_SIZE - this.cameraY, FIELD_SIZE * 2.1 * (workload / 100), FIELD_SIZE * 0.2);
		}
	}
	
	// draw waypoints
	if(this.humanUnitsSelected() || PLAYING_PLAYER.controller == CONTROLLER.SPECTATOR || game_state == GAME.EDITOR)
	{
		c.lineWidth = 2;
		
		for(var i = 0; i < this.selectedUnits.length; i++)
		{
			var unit = this.selectedUnits[i];
			
			if(unit.waypoint && (unit.type.isBuilding || unit.queue[0]))
				for(var k = 0; k < unit.waypoint.length; k++)
				{
					c.strokeStyle = "rgba(" + this.theme.line_red + ", " + this.theme.line_green + ", " + this.theme.line_blue + ", " + (1 - ((timestamp / 1000) % 0.8) * 0.8) + ")";
					
					var point0 = (k > 0 ? (unit.waypoint[k - 1].pos ? unit.waypoint[k - 1].pos : unit.waypoint[k - 1]) : unit.pos);
					point0 = point0.add3(0, -this.getHMValue3(point0) * CLIFF_HEIGHT);
					
					var point = unit.waypoint[k].pos ? unit.waypoint[k].pos : unit.waypoint[k];
					point = point.add3(0, -this.getHMValue3(point) * CLIFF_HEIGHT);
					
					c.beginPath();
					c.moveTo(point0.px * FIELD_SIZE - game.cameraX, (point0.py + (k == 0 ? (unit.getValue("circleOffset") / 2) : -Y_OFFSET)) * FIELD_SIZE - game.cameraY);
					c.lineTo(point.px * FIELD_SIZE - game.cameraX, (point.py - Y_OFFSET) * FIELD_SIZE - game.cameraY);
					c.stroke();
					
					// circle effect
					if(k == (unit.waypoint.length - 1) && ticksCounter % 8 == 0 && unit.lastTickCircleEffect != ticksCounter)
					{
						new GroundOrder({from: point.add3(0, -Y_OFFSET)});
						unit.lastTickCircleEffect = ticksCounter;
					}
				}
			
			if(unit.targetsQueue && unit.targetsQueue.length > 0 && unit.targetUnit)
			{
				c.strokeStyle = "rgba(164, 0, 0, " + (1 - ((timestamp / 1000) % 0.8) * 0.8) + ")";
				
				var targetsArray = [unit.targetUnit.drawPos];
				for(var k = 0; k < unit.targetsQueue.length; k++)
					targetsArray.push(unit.targetsQueue[k].drawPos);
				
				c.beginPath();
				c.moveTo(unit.drawPos.px * FIELD_SIZE - game.cameraX, (unit.drawPos.py + unit.getValue("circleOffset") / 2) * FIELD_SIZE - game.cameraY);
				for(var k = 0; k < targetsArray.length; k++)
					c.lineTo(targetsArray[k].px * FIELD_SIZE - game.cameraX, (targetsArray[k].py + Y_OFFSET) * FIELD_SIZE - game.cameraY);
				c.stroke();
			}
		}
	}
	
	// queued paths
	if(this.humanUnitsSelected() && this.selectedUnits[0].type.isUnit)
	{
		c.strokeStyle = "rgba(" + this.theme.line_red + ", " + this.theme.line_green + ", " + this.theme.line_blue + ", 0.5)";
		
		for(var i = 0; i < this.selectedUnits.length; i++)
			if(this.selectedUnits[i].queueOrder && this.selectedUnits[i].queueOrder.length > 0)
			{
				var unit = this.selectedUnits[i];
				
				var targetsArray = [unit.drawPos];
				if(unit.hasPath())
					targetsArray.push(unit.path.add3(0, -this.getHMValue3(unit.path) * CLIFF_HEIGHT));
				
				for(var k = 0; k < unit.queueOrder.length; k++)
				{
					var target = unit.queueTarget[k];
					
					if(target && target.isField)
						targetsArray.push(target.add3(0, -this.getHMValue3(target) * CLIFF_HEIGHT));
					
					if(target && target.pos)
						targetsArray.push(target.drawPos);
				}
				
				for(var k = 1; k < targetsArray.length; k++)
				{
					c.beginPath();
					c.moveTo(targetsArray[k - 1].px * FIELD_SIZE - game.cameraX, (targetsArray[k - 1].py) * FIELD_SIZE - game.cameraY);
					c.lineTo(targetsArray[k].px * FIELD_SIZE - game.cameraX, (targetsArray[k].py) * FIELD_SIZE - game.cameraY);
					c.stroke();
				}
				
				// circle effect
				if(ticksCounter % 8 == 0 && unit.lastTickCircleEffect != ticksCounter)
				{
					new GroundOrder({from: targetsArray[targetsArray.length - 1].add3(0, 0)});
					unit.lastTickCircleEffect = ticksCounter;
				}
			}
	}
	
	// map pings
	for(var i = 0; i < this.minimap.mapPings.length; i++)
	{
		var ping = this.minimap.mapPings[i];
		
		var age = Date.now() - ping.time;
		
		if(age > 7000) //ping is too old, kill it
		{
			this.minimap.mapPings.splice(i, 1);
			i--;
		}
		
		else
		{
			var drawX = (ping.field.x - 0.5) * FIELD_SIZE - this.cameraX;
			var drawY = (ping.field.y - 0.5) * FIELD_SIZE - this.cameraY;
			
			c.strokeStyle = "rgba(255, 255, 0, " + (age < 6000 ? 0.9 : Math.max((7000 - age) / 1000, 0)) + ")";
			c.lineWidth = 1.5 * SCALE_FACTOR;
			
			
			var radius  = FIELD_SIZE * 0.3 * Math.max(Math.sin(Math.PI * age / 250) + 1.5) / 2.5;
			var radius2 = FIELD_SIZE * 0.3 * Math.max(Math.sin(Math.PI * age / 250 + 3.14/2) + 1.5) / 2.5;
			
			c.beginPath();
			c.strokeRect(drawX - radius, drawY - radius, 2 * radius, 2 * radius);
			c.strokeRect(drawX - radius2, drawY - radius2, 2 * radius2, 2 * radius2);
			c.stroke();
			
			
			var angles = [0, 90, 180, 270];
			
			var sin = angles.map(function(s) { return Math.sin(s / 180 * Math.PI + age / 5000 * Math.PI * 3);});
			var cos = angles.map(function(s) { return Math.cos(s / 180 * Math.PI + age / 5000 * Math.PI * 3);});
			
			var xs = [FIELD_SIZE, FIELD_SIZE, FIELD_SIZE / 2];
			var ys = [-FIELD_SIZE / 3, FIELD_SIZE / 3, 0];
			
			for(var j = 0; j < 4; j++)
			{
				c.beginPath();
				
				c.moveTo(drawX + xs[0] * cos[j] - ys[0] * sin[j], drawY + ys[0] * cos[j] + xs[0] * sin[j]);
				c.lineTo(drawX + xs[1] * cos[j] - ys[1] * sin[j], drawY + ys[1] * cos[j] + xs[1] * sin[j]);
				c.lineTo(drawX + xs[2] * cos[j] - ys[2] * sin[j], drawY + ys[2] * cos[j] + xs[2] * sin[j]);
				
				c.closePath();
				c.stroke();
			}
		}
	}
	
	if(game_state == GAME.PLAYING)
	{
		this.env.draw();
		this.rain.draw();
	}
	
	// draw fog
	c.drawImage(game_state == GAME.PLAYING ? this.minimap.screenCanvas : this.minimap.editorCanvas, this.cameraX / SCALE_FACTOR, this.cameraY / SCALE_FACTOR, drawW / SCALE_FACTOR, drawH / SCALE_FACTOR, 0, 0, drawW, drawH);
	
	// if cursor is hovering a unit, draw the units owners name (if not playing player)
	if(hoverUnit && ((hoverUnit.owner != PLAYING_PLAYER && hoverUnit.owner.number > 0) || (hoverUnit.type.hoverText && hoverUnit.type.hoverText.length > 0)))
	{
		var y = hoverUnit.drawPos.py * FIELD_SIZE - this.cameraY;
		y += hoverUnit.type.isUnit ? FIELD_SIZE : ((hoverUnit.type.sizeY / 2 + 0.7) * FIELD_SIZE);
		
		var text = (hoverUnit.type.hoverText && hoverUnit.type.hoverText.length > 0) ? hoverUnit.type.hoverText : hoverUnit.owner.name;
		
		if(game_state == GAME.EDITOR)
			text = hoverUnit.type.name + " (x: " + (parseInt(hoverUnit.pos.px * 100) / 100) + ", y: " + (parseInt(hoverUnit.pos.py * 100) / 100) + ")";
		
		drawText(c, text, "white", "bold " + (4 * 6) + "px LCDSolid", hoverUnit.drawPos.px * FIELD_SIZE - this.cameraX, y, 300, "center", 1, "rgba(0, 0, 0, 0.5)", null, (4 * 6));
	}
	
	// if game paused, draw black screen with opac
	if(game_paused)
	{
		c.fillStyle = "rgba(0, 0, 0, 0.5)";
		c.fillRect(0, 0, WIDTH, HEIGHT);
	}
	
	// print path
	if(path2Print)
		for(var i = 1; i < path2Print.length; i++)
		{
			c.beginPath();
			c.moveTo(path2Print[i - 1].px * FIELD_SIZE - game.cameraX, (path2Print[i - 1].py) * FIELD_SIZE - game.cameraY);
			c.lineTo(path2Print[i].px * FIELD_SIZE - game.cameraX, (path2Print[i].py) * FIELD_SIZE - game.cameraY);
			c.stroke();
		}
	
	/*
	for(var x = parseInt(x1); x < x2; x++)
		for(var y = parseInt(y1); y < y2; y++)
		{
			drawText(c, x + ":" + y, "white", 12, (x - x1) * FIELD_SIZE, (y - y1) * FIELD_SIZE);
			drawText(c, "hm: " + this.fields[x][y].hm, "white", 12, (x - x1) * FIELD_SIZE, (y - y1) * FIELD_SIZE + 16);
			drawText(c, "hm2: " + this.fields[x][y].hm2, "white", 12, (x - x1) * FIELD_SIZE, (y - y1) * FIELD_SIZE + 32);
			drawText(c, "hm4: " + this.fields[x][y].hm4, "white", 12, (x - x1) * FIELD_SIZE, (y - y1) * FIELD_SIZE + 48);
		}
	*/
	
	// draw minimap
	this.minimap.draw();
};
// a html div, that has children
function UIWindow(id, condition, closeable, title, draggable, onKey)
{
	this.domElement = document.createElement('div');
	this.domElement.id = id;
	this.domElement.className = "ingameWindow" + (draggable ? " draggable" : "");
	this.draggable = draggable;
	if(condition)
	{
		this.domElement.style.display = "none";
		this.active = true; // some elements are closable; it not closable, this is always true
		this.condition = condition; // decides if this should be drawn
		// TODO: MOVE THIS.CONDITION OUT OF HERE - CURRENTLY BREAKS EVERYTHING
	}
	
	document.body.appendChild(this.domElement);
	
	this.onKey = onKey;
	
	// if this is true, the windiw has a "x" button for closing in the corner
	if(closeable)
	{
		this.active = false;
		this.wasActiveLastFrame = false;
		
		// create close button
		var closeButton = document.createElement('button');
		closeButton.className = "closeButton";
		closeButton.innerHTML = "X";
		this.closeButton = closeButton;
		closeButton.parent_ = this;
		closeButton.onclick = function(){
			console.log('x was clicked');
			soundManager.playSound(SOUND.CLICK);
			this.parent_.active = false;
			fadeOut($(this.parent_.domElement));
			
			if(this.parent_.domElement.id == "infoWindow2")
				setTimeout(showAchivement, 1000);
		};
		
		// make it close on escape
		this.domElement.parent_ = this;
		this.domElement.onkeydown = function(e){
			
			if(keyManager.getKeyCode(e) == KEY.ESC)
			{
				soundManager.playSound(SOUND.CLICK);
				this.parent_.active = false;
				fadeOut($(this.parent_.domElement));
				
				if(this.parent_.domElement.id == "infoWindow2")
					setTimeout(showAchivement, 1000);
			}
			
		};
		
		// add it to the window
		this.domElement.appendChild(closeButton);
	}
	
	// if a title is set
	if(title)
	{
		var title_ = document.createElement("h2");
		title_.innerHTML = "&raquo; " + title;
		title_.className = "windowTitle";
		this.title = title_;
		this.domElement.appendChild(title_);
	}
	
	// head rider
	this.head_rider = document.createElement("div");
	this.head_rider.className = "head_rider";
	this.domElement.appendChild(this.head_rider);
	
	this.blocksCanvas = true;
	// elements.push(this);
	// TODO: ADD THIS - currently divs default to visible so this causes issues.
};

UIWindow.prototype.setTitle = function(newTitle, head_rider)
{
	this.head_rider.innerHTML = head_rider ? head_rider : "";
	
	var h2s = this.domElement.getElementsByTagName("h2");
	
	if(h2s.length == 0)
		return;
	
	h2s[0].innerHTML = newTitle;
};
UIWindow.prototype.setTitleStyle = function(style)
{
	if (!this.title) { return; }
	this.title.className = style;
};

UIWindow.prototype.setCloseButtonStyle = function(style)
{
	this.closeButton.className = style;
};

UIWindow.prototype.setBackgroundStyle = function(style)
{
	this.domElement.className = style;
	this.closeButton.className = style;
};

// adds a scrollable subdiv to the parent div, which covers most of the div, usually used for text content (chat window for example)
UIWindow.prototype.addScrollableSubDiv = function(id)
{
	var textArea = document.createElement('div');
	textArea.className = "textContainer";
	textArea.id = id;
	this.domElement.appendChild(textArea);
	return textArea;
};

// called every frame; checks if this element should be drawn and then does so
UIWindow.prototype.refreshVisibility = function()
{
	if(this.active && this.condition())
	{
		if(this.wasActiveLastFrame)
			return this.blocksCanvas;
		
		this.wasActiveLastFrame = true;
		this.domElement.style.display = "inline";
		
		// if the window contains an input, set focus on it
		var inputs = this.domElement.getElementsByTagName('input');
		if(inputs[0])
		{
			inputs[0].focus();
			var val = inputs[0].value;
			inputs[0].value = "-";
			inputs[0].value = val;
		}
		return this.blocksCanvas;
	}
	
	if(!this.wasActiveLastFrame)
		return false;
	
	this.wasActiveLastFrame = false;
	this.domElement.style.display = "none";
	return false;
};
// input manager, manages all the inputs
function KeyManager()
{
	this.keys = new Array(300); // stores which keys are pressed atm (for active button effect) (index = asci code, true for button is pressed)
	this.drawBox = false; // use to check if selection box has to be drawn
	this.leftMouse = false; // is leftmouse is pressed down atm, for button pressed graphic effect
	this.middleMouse = false; // if true, activate map scrolling
	this.minimapScroll = false; // if clicking in the minimap, set this true as long as leftmouse is true
	this.timeOfLastKeyPressed = 0; // to check for double press
	this.lastKeyPressed = 0;
	this.commandCardWhenPressStart = 0;
	
	this.x = 0; // x mouse pos
	this.y = 0; // y mouse pos
	this.startX = 0; // when box is drawn, store start X
	this.startY = 0; // when box is drawn, store start Y
	this.command = null; // active command
	
	this.controlGroups = new Array(11);
	this.cameraLocations = new Array(11);
	for(var i = 0; i < this.controlGroups.length; i++)
		this.controlGroups[i] = [];
};

KeyManager.prototype.draw = function()
{
	if(this.drawBox && (game_state != GAME.EDITOR || !editor.dragging)) // Leftmouse is pressed, so we draw a box
	{
		c.fillStyle = "rgba(150, 190, 255, 0.4)";
		c.fillRect(this.x, this.y, this.startX - this.x, this.startY - this.y);
		c.strokeStyle = "rgba(0, 50, 133, 0.8)";
		c.strokeRect(this.x, this.y, this.startX - this.x, this.startY - this.y);
	}
	
	// Aoe cursor
	if(this.command && this.command.useAoeCursor && game.selectedUnits[0])
	{
		var radius = this.command.getValue("aoeRadius", game.selectedUnits[0]) * FIELD_SIZE;
		drawCircle(this.x, this.y, radius, null, "rgba(" + game.theme.line_red + ", " + game.theme.line_green + ", " + game.theme.line_blue + ", 0.4)", 0.8);
	}
	
	// call editor click function every frame (as if we would click all the time, because editor can draw multiple stuff, when mouse is clicked)
	if(game_state == GAME.EDITOR && this.leftMouse)
		editor.click(this.x, this.y, false, 1);
};

// create object
var keyManager = new KeyManager();

document.onkeyup = function(e)
{
	keyManager.keys[keyManager.getKeyCode(e)] = false;
	return false;
};

document.onkeydown = function(e)
{
	if(!e.repeat)
		keyManager.commandCardWhenPressStart = interface_.commandCard;
	
	var key = keyManager.getKeyCode(e);
	
	if(key == KEY.F8)
		toggleFullscreen(document.documentElement);
	
	// if theres ui windows open, return because no delegation to the game
	if(document.activeElement && ((document.activeElement.nodeName == "INPUT" && document.activeElement.type == "text") || document.activeElement.nodeName == "TEXTAREA") && document.activeElement.style.visibility != "hidden" && document.activeElement.offsetParent !== null)
		return true;
	
	uimanager.onKey(key);
	
	// if were not ingame, return, because no delegation to the game
	if(game_state != GAME.PLAYING && game_state != GAME.EDITOR)
		return true;
	
	keyManager.keys[key] = true;
	
	// zoom via keys
	if((game_state == GAME.PLAYING || game_state == GAME.EDITOR) && key == otherKeys[0])
		zoom(120);
	
	if((game_state == GAME.PLAYING || game_state == GAME.EDITOR) && key == otherKeys[1])
		zoom(-120);
	
	if(game_state == GAME.EDITOR)
	{
		editor.keyPressed(key);
		return false;
	}
	
	// map ping
	if(game_state == GAME.PLAYING && network_game && key == otherKeys[2])
	{
		var f = null;
		
		if(keyManager.x < MINIMAP_WIDTH && keyManager.y > HEIGHT - MINIMAP_HEIGHT) // if click in minimap
			f = game.minimap.getFieldFromClick(keyManager.x, keyManager.y);
		
		else if(keyManager.y < HEIGHT - INTERFACE_HEIGHT) // if click in main screen map
			f = game.getFieldFromPos();
		
		if(f)
			network.send("map-ping<<$" + f.x + "<<$" + f.y);
	}
	
	// open ingame chat input and set all/allies dropdown
	if(game_state == GAME.PLAYING && key == KEY.ENTER && !uimanager.ingameInput.active)
	{
		uimanager.ingameInput.active = true;
		
		// check, if playing player has allies
		var playingPlayerHasAllies = false;
		for(var i = 1; i < game.players.length; i++)
			if(game.players[i] && game.players[i] != PLAYING_PLAYER && !game.players[i].isEnemyOfPlayer(PLAYING_PLAYER) && game.players[i].controller != CONTROLLER.SPECTATOR && game.players[i].isAlive)
				playingPlayerHasAllies = true;
		
		// if is spectator, then always send to all
		if(PLAYING_PLAYER.controller == CONTROLLER.SPECTATOR)
			playingPlayerHasAllies = false;
		
		// if shift pressed, set the opposite
		var setDropdown = keyManager.keys[KEY.SHIFT] ? !playingPlayerHasAllies : playingPlayerHasAllies;
		
		$('#ingameChatDropdown')[0].selectedIndex = setDropdown ? 1 : 0;
	}
	
	// tell interface, a key has been pressed
	if(interface_ && keyManager.commandCardWhenPressStart == interface_.commandCard)
		interface_.keyPressed(key);
	
	// pause
	if(key == KEY.PAUSE && game_state == GAME.PLAYING)
		pauseGame();
	
	// if camera location hotkey stuff
	if(game_state == GAME.PLAYING && cameraHotkeys[key] >= 1)
	{
		var nr = cameraHotkeys[key];
		
		if(nr < keyManager.cameraLocations.length)
		{
			
			// if strg pressed, set camera location
			if(keyManager.keys[KEY.STRG] || keyManager.keys[KEY.SHIFT])
				keyManager.cameraLocations[nr] = new Field((game.cameraX + WIDTH / 2) / FIELD_SIZE, (game.cameraY + HEIGHT / 2) / FIELD_SIZE, true);
			
			// else, go to camera location
			else if(keyManager.cameraLocations[nr])
			{
				game.cameraX = keyManager.cameraLocations[nr].px * FIELD_SIZE - WIDTH / 2;
				game.cameraY = keyManager.cameraLocations[nr].py * FIELD_SIZE - HEIGHT / 2;
			}
			
		}
	}
	
	// if ctrl group stuff
	if(game_state == GAME.PLAYING && ctrlGroupKeys[key] >= 1)
	{
		var nr = ctrlGroupKeys[key];
		
		// create new ctrl grp
		if(keyManager.keys[KEY.STRG] && game.humanUnitsSelected())
			keyManager.controlGroups[nr] = game.selectedUnits;
		
		// add units to ctrl grp
		else if(keyManager.keys[KEY.SHIFT] && game.humanUnitsSelected())
		{
			for(var i = 0; i < game.selectedUnits.length; i++)
			{
				var contains = false;
				for(var k = 0; k < keyManager.controlGroups[nr].length; k++)
					if(game.selectedUnits[i] == keyManager.controlGroups[nr][k])
						contains = true;
				
				if(!contains && game.selectedUnits[i].owner == PLAYING_PLAYER && (keyManager.controlGroups[nr].length == 0 || keyManager.controlGroups[nr][0].type.isBuilding == game.selectedUnits[i].type.isBuilding))
					keyManager.controlGroups[nr].push(game.selectedUnits[i]);
			}
		}
		
		// select ctrl grp
		else if(keyManager.controlGroups[nr].length > 0)
		{
			var oldType = game.selectedUnits[0] ? game.selectedUnits[0].type : null;
			game.selectedUnits = keyManager.controlGroups[nr].slice();
			
			interface_.unitsTab = 0;
			
			keyManager.resetCommand();
			
			// deselct units, that are currently "not active" (= means, they are in buildings for example)
			for(var i = 0; i < game.selectedUnits.length; i++)
				if(!game.selectedUnits[i].isActive)
				{
					game.selectedUnits.splice(i, 1);
					i--;
				}
			
			interface_.commandCard = 0; // reset command card (in case we were in the building submenu)
			interface_.unitTypeWithCurrentTabPrio = null; // reset command card prio
			
			// if double pressed this ctrl grp, jump camera there
			if(keyManager.lastKeyPressed == key && keyManager.timeOfLastKeyPressed + 350 > timestamp && game.selectedUnits.length > 0)
			{
				var point = game.getCenterOfUnits(game.selectedUnits);
				
				var nextUnit = null;
				var closestDistance = 9999;
				for(var i = 0; i < game.selectedUnits.length; i++)
				{
					var distance = point.distanceTo2(game.selectedUnits[i].pos);
					if(distance < closestDistance)
					{
						closestDistance = distance;
						nextUnit = game.selectedUnits[i];
					}
				}
				
				game.cameraX = nextUnit.pos.px * FIELD_SIZE - WIDTH / 2;
				game.cameraY = nextUnit.pos.py * FIELD_SIZE - HEIGHT / 2;
			}
			
			keyManager.changeUnitSelection(oldType);
		}
		
	}
	
	keyManager.timeOfLastKeyPressed = timestamp;
	keyManager.lastKeyPressed = key;
	
	return false;
};

KeyManager.prototype.changeUnitSelection = function(oldType)
{
	if((game.selectedUnits[0] && game.selectedUnits[0].type == oldType) || game_state != GAME.PLAYING)
		return;
	
	if(oldType && oldType.clickSound)
	{
		while(soundManager.buildingClickSound.length > 1)
		{
			soundManager.buildingClickSound[0].sound.pause();
			soundManager.buildingClickSound[0].sound.volume = 0;
			soundManager.buildingClickSound[0].sound.currentTime = 0;
			soundManager.buildingClickSound.splice(0, 1);
		}
		
		if(soundManager.buildingClickSound[0])
		{
			soundManager.buildingClickSound[0].fadeOut = true;
			setTimeout(soundFaceOut, 1);
		}
	}
	
	if(game.selectedUnits[0] && game.selectedUnits[0].owner == PLAYING_PLAYER && game.selectedUnits[0].type.clickSound)
		soundManager.playSound(
			game.selectedUnits[0].isUnderConstruction ? SOUND.BUILD : game.selectedUnits[0].type.clickSound,
			null,
			game.selectedUnits[0].isUnderConstruction ? 0.5 : game.selectedUnits[0].type.clickSoundVolume,
			true
		);
}

// IE9, Chrome, Safari, Opera
canvas.addEventListener("mousewheel", MouseWheelHandler, false);

// Firefox
canvas.addEventListener("DOMMouseScroll", MouseWheelHandler, false);

function MouseWheelHandler(e)
{
	// set zoom level
	if(game_state == GAME.PLAYING || game_state == GAME.EDITOR)
	{
		var e = window.event || e;
		zoom(e.wheelDelta || -e.detail);
	}
};

function zoom(direction)
{
	// middle of camera
	var middle_x = (game.cameraX + WIDTH / 2) / FIELD_SIZE;
	var middle_y = (game.cameraY + HEIGHT / 2) / FIELD_SIZE;
	
	if(direction > 0)
		SCALE_FACTOR = Math.min(SCALE_FACTOR + 1, 10);
	else
		SCALE_FACTOR = Math.max(SCALE_FACTOR - 1, 2);
	
	FIELD_SIZE = 16 * SCALE_FACTOR;
	
	// adjust camera
	game.cameraX = middle_x * FIELD_SIZE - WIDTH / 2;
	game.cameraY = middle_y * FIELD_SIZE - HEIGHT / 2;
	
	writeCookie();
}

canvas.onmousedown = function(e)
{
	if(game_paused && PLAYING_PLAYER.controller != CONTROLLER.SPECTATOR)
		return;
	
	// leftmouse
	if(keyManager.getKeyCode(e) == 1)
		keyManager.leftMouse = true;
	
	// if click in minimap
	if(keyManager.x < MINIMAP_WIDTH && keyManager.y > HEIGHT - MINIMAP_HEIGHT && (game_state == GAME.PLAYING || game_state == GAME.EDITOR))
	{
		var clickedPos = game.minimap.getFieldFromClick(keyManager.x, keyManager.y);
		
		// leftmouse
		if(keyManager.getKeyCode(e) == 1)
		{
			// if no command is active, set minimap scroll enabled
			if(!keyManager.command)
				keyManager.minimapScroll = true;
			
			// if attack order has been issued
			else if(keyManager.command.type == COMMAND.ATTACK && game.humanUnitsSelected())
			{
				game.issueOrderToUnits(game.selectedUnits, lists.types.amove, clickedPos, keyManager.keys[KEY.SHIFT]);
				new GroundOrder({from: clickedPos.add3(0, Y_OFFSET)});
				keyManager.resetCommand();
			}
		}
		
		// rightmouse & no command active, order move command
		else if(keyManager.getKeyCode(e) == 3 && !keyManager.command && game.humanUnitsSelected())
		{
			game.issueOrderToUnits(game.selectedUnits, lists.types.move, clickedPos, keyManager.keys[KEY.SHIFT]);
			new GroundOrder({from: clickedPos.add3(0, Y_OFFSET)});
		}
		
		// return false;
		return;
	}
	
	// if editor, delegate there
	if(game_state == GAME.EDITOR)
		editor.click(keyManager.x, keyManager.y, true, keyManager.getKeyCode(e));
	
	// if left click in interface and hit something (returns true), return
	if(!keyManager.command && keyManager.getKeyCode(e) == 1 && game_state == GAME.PLAYING && interface_.leftClick(keyManager.x, keyManager.y))
		return;
	
	// if right click in interface and hit something (returns true), return
	if(!keyManager.command && keyManager.getKeyCode(e) == 3 && game_state == GAME.PLAYING && interface_.rightClick(keyManager.x, keyManager.y))
		return;
	
	// if click in screen map
	if((keyManager.y < HEIGHT - INTERFACE_HEIGHT || keyManager.command) && (game_state == GAME.PLAYING || game_state == GAME.EDITOR))
	{
		var field = game.getFieldFromPos();
		
		// activate map scrolling
		if(keyManager.getKeyCode(e) == 2)
			keyManager.middleMouse = true;
		
		// leftmouse
		else if(keyManager.getKeyCode(e) == 1)
		{
			
			// if no active command && if editor, then only when no button selected
			if((game_state == GAME.PLAYING && !keyManager.command) || (game_state == GAME.EDITOR && !editor.selectedItemType && editor.terrainModifier == 0))
			{
				keyManager.drawBox = true;
				keyManager.startX = keyManager.x;
				keyManager.startY = keyManager.y;
			}
			
			// attack order has been issued
			else if(keyManager.command && keyManager.command.type == COMMAND.ATTACK && game.humanUnitsSelected())
			{
				var targetUnit = (interface_ && interface_.currentHoverUnit) ? interface_.currentHoverUnit : game.getUnitAtPosition((keyManager.x + game.cameraX) / FIELD_SIZE, (keyManager.y + game.cameraY) / FIELD_SIZE);
				
				// AMove
				if(!targetUnit || targetUnit.getValue("noShow"))
				{
					game.issueOrderToUnits(game.selectedUnits, lists.types.amove, field.add3(0, -Y_OFFSET), keyManager.keys[KEY.SHIFT]);
					new GroundOrder({from: new Field((keyManager.x + game.cameraX) / FIELD_SIZE, (keyManager.y + game.cameraY + 3) / FIELD_SIZE, true)});
				}
				
				// Attack specific unit order
				else
				{
					game.issueOrderToUnits(game.selectedUnits, lists.types.attack, targetUnit, keyManager.keys[KEY.SHIFT]);
					targetUnit.blink();
				}
				
				keyManager.resetCommand();
			}
			
			// make building order has been issued
			else if(keyManager.command && keyManager.command.type == COMMAND.MAKEBUILDING && game.humanUnitsSelected())
			{
				// get building type and field
				var building = keyManager.command.unitType;
				var field = building.getFieldFromMousePos();
				
				// if building has space, issue order
				if(building.couldBePlacedAt(field, true))
				{
					var cost = PLAYING_PLAYER.getCostOfNextInstanceForBuilding(building);
					
					// player has enough gold to make building
					if(PLAYING_PLAYER.gold >= cost)
					{
						if(!building.supply || building.supply <= PLAYING_PLAYER.maxSupply - PLAYING_PLAYER.supply)
						{
							game.issueOrderToUnits(game.selectedUnits, keyManager.command, field, keyManager.keys[KEY.SHIFT]);
							
							if(!keyManager.keys[KEY.SHIFT])
								keyManager.resetCommand();
							
							soundManager.playSound(SOUND.PLACE);
						}
						
						else
						{
							interface_.addMessage("not enough supply", "red", imgs.attentionmark);
							soundManager.playSound(SOUND.NEGATIVE);
						}
					}
					
					else
					{
						interface_.addMessage("not enough gold (" + Math.ceil(cost - PLAYING_PLAYER.gold) + " missing)", "red", imgs.attentionmark);
						soundManager.playSound(SOUND.NEGATIVE);
					}
				}
				
				// if no space for building at this position, display warning msg and play sound
				else
				{
					interface_.addMessage("no space", "red", imgs.attentionmark);
					soundManager.playSound(SOUND.NEGATIVE);
				}
			}
			
			// if unload
			else if(keyManager.command && keyManager.command.type == COMMAND.UNLOAD && game.humanUnitsSelected())
			{
				var targetUnit = (interface_ && interface_.currentHoverUnit) ? interface_.currentHoverUnit : game.getUnitAtPosition((keyManager.x + game.cameraX) / FIELD_SIZE, (keyManager.y + game.cameraY) / FIELD_SIZE);
				game.issueOrderToUnits(game.selectedUnits, keyManager.command, (targetUnit && game.selectedUnits.contains(targetUnit)) ? targetUnit : field, keyManager.keys[KEY.SHIFT]);
				if(!targetUnit || !game.selectedUnits.contains(targetUnit))
					new GroundOrder({from: new Field((keyManager.x + game.cameraX) / FIELD_SIZE, (keyManager.y + game.cameraY + 3) / FIELD_SIZE, true)});
				keyManager.resetCommand();
			}
			
			// if target is point
			else if(keyManager.command && (keyManager.command.targetIsPoint || keyManager.command.type == COMMAND.TELEPORT) && game.humanUnitsSelected())
			{
				game.issueOrderToUnits(game.selectedUnits, keyManager.command, field, keyManager.keys[KEY.SHIFT]);
				new GroundOrder({from: new Field((keyManager.x + game.cameraX) / FIELD_SIZE, (keyManager.y + game.cameraY + 3) / FIELD_SIZE, true)});
				keyManager.resetCommand();
			}
			
			else if(keyManager.command && keyManager.command.targetIsUnit && game.humanUnitsSelected())
			{
				var targetUnit = (interface_ && interface_.currentHoverUnit) ? interface_.currentHoverUnit : game.getUnitAtPosition((keyManager.x + game.cameraX) / FIELD_SIZE, (keyManager.y + game.cameraY) / FIELD_SIZE, keyManager.command.targetRequiremementsArray.length > 0 ? keyManager.command : null);
				
				if(targetUnit && targetUnit.getValue("noShow"))
					targetUnit = null;
				
				if(targetUnit && keyManager.command.type == COMMAND.LOAD && targetUnit.owner != game.selectedUnits[0].owner)
				{
					interface_.addMessage("can only target own units", "red", imgs.attentionmark);
					soundManager.playSound(SOUND.NEGATIVE);
				}
				
				else if(targetUnit)
				{
					game.issueOrderToUnits(game.selectedUnits, keyManager.command, targetUnit, keyManager.keys[KEY.SHIFT]);
					targetUnit.blink();
					keyManager.resetCommand();
				}
				else
				{
					interface_.addMessage("must target unit", "red", imgs.attentionmark);
					soundManager.playSound(SOUND.NEGATIVE);
				}
			}
		}
		
		// rightmouse (and were ingame; rightmouse only works when ingame)
		if(keyManager.getKeyCode(e) == 3 && game_state == GAME.PLAYING)
		{
			
			e.preventDefault();
			e.stopPropagation();
			// if no command has been clicked -> move / attack / waypoint
			if(!keyManager.command && game && game.humanUnitsSelected())
			{
				var targetUnit = game.getUnitAtPosition((keyManager.x + game.cameraX) / FIELD_SIZE, (keyManager.y + game.cameraY) / FIELD_SIZE);
				
				if(targetUnit && targetUnit.getValue("noShow"))
					targetUnit = null;
				
				// if theres an enemy unit at this point, attack
				if(targetUnit && targetUnit.owner.isEnemyOfPlayer(PLAYING_PLAYER))
				{
					game.issueOrderToUnits(game.selectedUnits, lists.types.attack, targetUnit, keyManager.keys[KEY.SHIFT]);
					targetUnit.blink();
				}
				
				// if theres a friendly or neutral unit, moveto or mine
				else if(targetUnit && !targetUnit.owner.isEnemyOfPlayer(PLAYING_PLAYER) && ((game.selectedUnits[0].type.isBuilding || targetUnit.type.isBuilding) || (game.selectionContainsCargoUnits() && targetUnit.type.cargoUse) || (targetUnit.type.isMechanical && game.selectionContainsWorkers()) || targetUnit.canLoad()))
				{
					game.issueOrderToUnits(game.selectedUnits, lists.types.moveto, targetUnit, keyManager.keys[KEY.SHIFT]);
					targetUnit.blink();
				}
				
				// if theres no enemy unit => move / waypoint
				else
				{
					game.issueOrderToUnits(game.selectedUnits, lists.types.move, field.add3(0, -Y_OFFSET), keyManager.keys[KEY.SHIFT]);
					new GroundOrder({from: new Field((keyManager.x + game.cameraX) / FIELD_SIZE, (keyManager.y + game.cameraY + 3) / FIELD_SIZE, true)});
				}
			}
		}
	}
	
	// rightmouse
	if(keyManager.getKeyCode(e) == 3)
		keyManager.resetCommand();
	
	return false;
};
document.addEventListener('mousedown', function(e) { if (e.button == 2) { e.preventDefault(); } }, false);
// this prevents the context menu when shift right clicking (at least for some browsers)
document.onclick = function(e)
{
	var b = keyManager.getKeyCode(e);
	
	if((b == 2 || b == 3) && (game_state == GAME.PLAYING || game_state == GAME.EDITOR))
	{
		e.preventDefault();
		e.stopPropagation();
		return false;
	}
};

// replace the cursor with tho normal one
KeyManager.prototype.resetCommand = function()
{
	this.command = null;
	document.body.style.cursor = "url(imgs/cursor.cur), auto";
};

// a command is started
KeyManager.prototype.order = function(cmd, learn)
{
	if(learn)
	{
		game.issueOrderToUnits(game.selectedUnits, cmd, null, this.keys[KEY.SHIFT], false, null, true);
		return;
	}
	
	// check for cooldown
	var units = cmd.cooldown2 ? game.getUnitsWithRdyCooldown(cmd) : game.selectedUnits;
	
	if(units.length == 0)
	{
		interface_.addMessage("Cooldown not ready", "red", imgs.attentionmark);
		soundManager.playSound(SOUND.NEGATIVE);
		return;
	}
	
	if(!this.keys[KEY.SHIFT])
		this.resetCommand();
	
	if(cmd.type == COMMAND.SWITCH_CC)
		interface_.commandCard = cmd.targetCC;
	
	// instant order: execute them
	else if(cmd.isInstant)
		game.issueOrderToUnits(units, cmd, null, this.keys[KEY.SHIFT]);
	
	else if(game.selectedUnitsCanPerformOrder(cmd, interface_.unitTypeWithCurrentTabPrio))
	{
		if(cmd.cursor)
			document.body.style.cursor = cmd.cursor + ", auto";
		
		if(cmd.type == COMMAND.MAKEBUILDING && PLAYING_PLAYER.gold < cmd.unitType.getValue("cost", PLAYING_PLAYER))
		{
			interface_.addMessage("not enough gold (" + Math.ceil(cmd.unitType.getValue("cost", PLAYING_PLAYER) - PLAYING_PLAYER.gold) + " missing)", "red", imgs.attentionmark);
			soundManager.playSound(SOUND.NEGATIVE);
		}
		
		else if(cmd.type == COMMAND.MAKEBUILDING && cmd.unitType.supply && cmd.unitType.supply > PLAYING_PLAYER.maxSupply - PLAYING_PLAYER.supply)
		{
			interface_.addMessage("not enough supply", "red", imgs.attentionmark);
			soundManager.playSound(SOUND.NEGATIVE);
		}
		
		else
			this.command = cmd;
	}
};

canvas.onmouseup = function(e)
{
	if(keyManager.getKeyCode(e) == 1) // leftmouse
	{
		// if we were drawing a box
		if(keyManager.drawBox && ((game_state == GAME.PLAYING && !keyManager.command) || (game_state == GAME.EDITOR && !editor.dragging && !editor.selectedItemType && editor.terrainModifier == 0)))
		{
			var oldType = game.selectedUnits[0] ? game.selectedUnits[0].type : null;
			
			var x1 = (keyManager.x + game.cameraX) / FIELD_SIZE;
			var y1 = (keyManager.y + game.cameraY) / FIELD_SIZE;
			var x2 = (keyManager.startX + game.cameraX) / FIELD_SIZE
			var y2 = (keyManager.startY + game.cameraY) / FIELD_SIZE;
			
			var x1n = Math.min(x1, x2);
			var x2n = Math.max(x1, x2);
			var y1n = Math.min(y1, y2);
			var y2n = Math.max(y1, y2);
			
			var units = game.getSelection(x1n, y1n, x2n, y2n, keyManager.keys[KEY.STRG]);
			
			// deselect units that we cant see
			for(var i = 0; i < units.length; i++)
				if(!PLAYING_PLAYER.team.canSeeUnit(units[i], true))
				{
					units.splice(i, 1);
					i--;
				}
			
			// if were in editor and no units selected, check for selected tiles
			if(units.length == 0 && game_state == GAME.EDITOR)
			{
				for(var i = 0; i < game.blockingTiles.length; i++)
					if(game.blockingTiles[i].isInBox(x1n, y1n, x2n, y2n))
						units.push(game.blockingTiles[i]);
				
				// deselect cliffs
				for(var i = 0; i < units.length; i++)
					if(units[i].type.isCliff)
					{
						units.splice(i, 1);
						i--;
					}
				
				// if we still selected nothing, check if we selected ground tiles
				if(units.length == 0)
					for(var i = 0; i < game.groundTiles2.length; i++)
						if(!game.groundTiles2[i].type.isCliff && game.groundTiles2[i].isInBox(x1n, y1n, x2n, y2n))
							units.push(game.groundTiles2[i]);
			}
			
			// if shift is pressed, add units instead of replacing them
			if(keyManager.keys[KEY.SHIFT])
				game.addUnitsToSelection(game.selectedUnits, units);
			
			// if we selected something, replace the old selection with the new one
			else if(units.length > 0)
			{
				game.selectedUnits = units;
				game.timeOfLastSelection = timestamp;
				interface_.commandCard = 0; // reset command card (in case we were in the building submenu)
				interface_.unitTypeWithCurrentTabPrio = null; // reset command card prio
				interface_.unitsTab = 0;
			}
			
			// if editor and something is selected, set player dropdown box to owning player
			if(game.selectedUnits.length > 0 && game_state == GAME.EDITOR)
			{
				$('#playerDropdown')[0].selectedIndex = game.selectedUnits[0].owner.number;
				editor.player = game.selectedUnits[0].owner.number;
			}
			
			// sort selected units
			game.selectedUnits = _.sortBy(game.selectedUnits, function(o){ return -o.type.tabPriority; });
			
			keyManager.changeUnitSelection(oldType);
		}
		
		keyManager.leftMouse = false;
		keyManager.drawBox = false;
		keyManager.minimapScroll = false;
	}
	
	// middleMouse
	else if(keyManager.getKeyCode(e) == 2)
		keyManager.middleMouse = false;
	
	return false;
};

// when mouse is moved, store position
document.onmousemove = function(e)
{
	// Calculate pageX/Y if missing and clientX/Y available
	if(e.pageX == null && e.clientX != null)
	{
		var doc = document.documentElement;
		var body = document.body;
		e.pageX = e.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
		e.pageY = e.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
	}
	
	// if middlemouse is pressed, scroll
	if(keyManager.middleMouse && game && (!game_paused || PLAYING_PLAYER.controller == CONTROLLER.SPECTATOR))
	{
		game.cameraX += (keyManager.x - e.pageX) * 1.5 * (mmScrollInvert ? -1 : 1);
		game.cameraY += (keyManager.y - e.pageY) * 1.5 * (mmScrollInvert ? -1 : 1);
	}
	
	keyManager.x = e.pageX;
	keyManager.y = e.pageY;
	
	// fix shift bug that sometimes happens (special thanks to pox)
	if(!e)
		e = document.event;
	
	if(!e.shiftKey)
		keyManager.keys[KEY.SHIFT] = false;
};

KeyManager.prototype.getKeyCode = function(e)
{
	return e.which || e.keyCode;
};
function Interface()
{
	this.messages = []; // active chat messages are stores here
	
	this.commandCard = 0; // command card 0 => normal commands; command card 1 => buildings, ...
	
	this.unitTypeWithCurrentTabPrio = null; // prio of the command card that is currently displayed (if more than 1 unit type is selected, only the cc of one unit type can be displayd, can be tabbed with tab key by user)
	
	// create all the command buttons
	this.buttons = [];
	
	this.currentHoverUnit = null;
	
	this.idleWorkersButtonIsActive = false;
	
	this.idleWorkerIndex = 0;
	
	this.timeOflastGoldMsg = -9999;
	
	this.unitsTab = 0;
};

// add a message
Interface.prototype.addMessage = function(msg, font, img, whiteShadow)
{
	if(msg.slice(0, 15) == "not enough gold" || msg.slice(0, 15) == "This spell need")
	{
		if(this.timeOflastGoldMsg + 3000 < timestamp)
			this.timeOflastGoldMsg = timestamp;
		
		else
			return;
	}
	
	this.messages.splice(0, 0, {
		msg: msg,
		font: font,
		img: img ? img.img : null,
		creationTime: timestamp,
		shadow: whiteShadow ? "white" : "black"
	});
};

// add a chat message
Interface.prototype.chatMsg = function(msg, noSound)
{
	var str = msg.split(": ");
	
	var color = "white";
	var playerName = str[0].indexOf(" [") >= 0 ? (str[0].split(" ["))[0] : str[0];
	for(var i = 0; i < game.players.length; i++)
		if(game.players[i] && game.players[i].name == playerName && game.players[i].controller != CONTROLLER.SPECTATOR && playerColors[game.players[i].number - 1])
			color = game.players[i].number == 5 ? "gray" : game.players[i].getColor();
	
	if(str[1] == "showfps")
		show_fps = !show_fps;
	
	else if(str[1] == "showunitdetails" && !network_game)
		show_unit_details = !show_unit_details;
	
	this.addMessage(msg, color, null, color == "black");
	
	if(!noSound)
		soundManager.playSound(SOUND.POSITIVE);
};

Interface.prototype.draw = function()
{
	// chat msg width
	var width = Math.max(WIDTH - 500, 200);
	
	var offset = -1;
	
	// set font so we can measure the text correctly
	c.font = "bold 24px LCDSolid";
	
	// messages
	for(var i = 0; i < this.messages.length; i++)
	{
		var msg = this.messages[i];
		
		var age = timestamp - msg.creationTime;
		
		// if more than 10 msges or time expired, kill msg
		if(i > 10 || age > 10000)
		{
			this.messages.splice(i, 1);
			i--;
		}
		
		// draw msg
		else
		{
			// measure text
			var textWidth = c.measureText(msg.msg).width;
			var predictedAmountOfLines = Math.ceil(textWidth / width);
			offset += predictedAmountOfLines * 28;
			
			// calculate alpha (if older than a )
			var alpha = age < 8000 ? 1 : Math.max(10000 - age, 0.001) / 2000;
			
			// if msg contains an icon, draw it
			if(msg.img)
			{
				c.globalAlpha = alpha;
				c.drawImage(miscSheet[0], msg.img.x, msg.img.y, msg.img.w, msg.img.h, 334 - msg.img.w * 2, HEIGHT - INTERFACE_HEIGHT - 70 - offset, msg.img.w * 2, msg.img.h * 2);
				c.globalAlpha = 1;
			}
			
			// draw text
			drawText(c, " " + msg.msg, msg.font, "bold 24px LCDSolid", 300 + (msg.img ? msg.img.w * 2 + 6 : 0), HEIGHT - INTERFACE_HEIGHT - 40 - offset, width, "left", alpha, "rgba(0, 0, 0, 0.5)", msg.shadow, 24);
		}
	}
	
	if(game_state == GAME.PLAYING)
	{
		// draw background
		c.fillStyle = "#4E4A4E";
		c.fillRect(MINIMAP_WIDTH, HEIGHT - INTERFACE_HEIGHT, WIDTH - MINIMAP_WIDTH, INTERFACE_HEIGHT);
		c.lineWidth = 4;
		c.strokeStyle = "#757161";
		c.strokeRect(MINIMAP_WIDTH + 2, HEIGHT - INTERFACE_HEIGHT + 2, WIDTH - MINIMAP_WIDTH, INTERFACE_HEIGHT);
		
		// small black line below the top boarder
		c.lineWidth = 1;
		c.strokeStyle = "rgba(0, 0, 0, 0.8)";
		c.beginPath();
		c.moveTo(MINIMAP_WIDTH + 4, HEIGHT - INTERFACE_HEIGHT + 4.5);
		c.lineTo(WIDTH, HEIGHT - INTERFACE_HEIGHT + 4.5);
		c.stroke();
	}
	
	var unitNfoX = (WIDTH - 780) / 2;
	
	this.currentHoverUnit = null;
	
	var unit0 = game.selectedUnits[0] ? game.selectedUnits[0] : null;
	
	// imgs
	if(game_state == GAME.PLAYING)
		c.drawImage(miscSheet[0], imgs.interfaceRight.img.x, imgs.interfaceRight.img.y, imgs.interfaceRight.img.w, imgs.interfaceRight.img.h, WIDTH - 510, 0, imgs.interfaceRight.img.w * 2, imgs.interfaceRight.img.h * 2);
	
	c.drawImage(miscSheet[0], imgs.interfaceLeft.img.x, imgs.interfaceLeft.img.y, imgs.interfaceLeft.img.w, imgs.interfaceLeft.img.h, -346, 0, imgs.interfaceRight.img.w * 2, imgs.interfaceRight.img.h * 2);
	
	if(game_state == GAME.PLAYING)
		c.drawImage(miscSheet[0], imgs.interfaceButtonDiv.img.x, imgs.interfaceButtonDiv.img.y, imgs.interfaceButtonDiv.img.w, imgs.interfaceButtonDiv.img.h, WIDTH - 390, HEIGHT - 170, imgs.interfaceButtonDiv.img.w * 2, imgs.interfaceButtonDiv.img.h * 2);
	
	c.drawImage(miscSheet[0], imgs.interfaceMapBorder.img.x, imgs.interfaceMapBorder.img.y, imgs.interfaceMapBorder.img.w, imgs.interfaceMapBorder.img.h, -16, HEIGHT - 200, imgs.interfaceMapBorder.img.w * 2, imgs.interfaceMapBorder.img.h * 2);
	
	if(game_state == GAME.PLAYING)
		c.drawImage(miscSheet[0], imgs.interfaceUnitInfo.img.x, imgs.interfaceUnitInfo.img.y, imgs.interfaceUnitInfo.img.w, imgs.interfaceUnitInfo.img.h, unitNfoX , HEIGHT - 152, imgs.interfaceUnitInfo.img.w * 2, imgs.interfaceUnitInfo.img.h * 2);
	
	
	var units = game.selectedUnits;
	
	// unit data / stats, if only 1 unit is selected
	if(units.length == 1)
	{
		var u = units[0];
		var isInvincible = u.getValue("isInvincible");
		
		this.drawUnitInfo(u);
		
		var countBars = (!isInvincible ? 1 : 0) + (u.type.mana ? 1 : 0) + (u.type.experienceLevels && u.type.experienceLevels.length > 0 ? 1 : 0);
		var x = countBars == 3 ? HEIGHT - 136 : HEIGHT - 130;
		var step = countBars == 3 ? 26 : 30;
		
		// hp bar (if not invincible)
		if(!isInvincible)
		{
			u.drawHealthbar(unitNfoX + 350 - 70, x, 180, 20);
			drawText(c, Math.floor(u.hp) + " / " + u.getValue("hp"), "black", "bold 16px LCDSolid", unitNfoX + 370, x + 16, 200, "center", 1, null, "white");
		}
		
		// mana bar (if has mana)
		if(u.type.mana)
		{
			x += step;
			u.drawManabar(unitNfoX + 350 - 70, x, 180, 20);
			drawText(c, Math.floor(u.mana) + " / " + u.getValue("mana"), "black", "bold 16px LCDSolid", unitNfoX + 370, x + 16, 200, "center", 1, null, "white");
		}
		
		// exp bar
		if(u.type.experienceLevels && u.type.experienceLevels.length > 0)
		{
			x += step;
			u.drawExpbar(unitNfoX + 350 - 70, x, 180, 20);
			drawText(c, "Level " + u.level + " (" + Math.floor(Math.min(u.exp, u.type.experienceLevels[u.type.experienceLevels.length - 1])) + " / " + u.getXP4NextLevel() + " exp)", "black", "bold 16px LCDSolid", unitNfoX + 370, x + 16, 200, "center", 1, null, "white");
		}
		
		// buildings queue
		if((game.humanUnitsSelected() || PLAYING_PLAYER.controller == CONTROLLER.SPECTATOR) && u.queue[0])
		{
			c.lineWidth = 2;
			c.strokeStyle = "white";
			
			for(var i = 0; i < 5; i++)
			{
				c.strokeRect(unitNfoX + 188 + i * 70, HEIGHT - 94, 64, 64);
				
				if(u.queue[i])
				{
					var img = u.queue[i].getTitleImage(u.owner);
					var scale = 64 / Math.max(img.w, img.h);
					c.drawImage(img.file, img.x, img.y, img.w, img.h, unitNfoX + 188 + i * 70 + 32 - img.w * scale / 2, HEIGHT - 94 + 32 - img.h * scale / 2, img.w * scale, img.h * scale);
				}
				else
					drawText(c, (i + 1).toString(), "white", "bold 38px LCDSolid", unitNfoX + 212 + i * 70, HEIGHT - 46);
			}
			
			// bar
			var percentage = u.queueStarted ? ((u.currentBuildTime - (u.queueFinish - ticksCounter)) / u.currentBuildTime) : 0;
			drawBar(unitNfoX + 188, HEIGHT - 22, 344, 14, Math.min(percentage, 1), "rgba(0, 160, 230, 1)");
		}
		
		// under construction
		else if(u.isUnderConstruction && (game.humanUnitsSelected() || PLAYING_PLAYER.controller == CONTROLLER.SPECTATOR))
		{
			var dots = "";
			for(var i = 200; i < timestamp % 1000; i += 200)
				dots += ".";
			drawText(c, "Constructing" + dots, "white", "bold 38px LCDSolid", unitNfoX + 190, HEIGHT - 56);
			var percentage = (u.type.getValue("buildTime", unit0.owner) - u.buildTicksLeft) / u.type.getValue("buildTime", unit0.owner);
			drawBar(unitNfoX + 188, HEIGHT - 40, 344, 14, percentage, "rgba(0, 160, 230, 1)");
		}
		
		// else if unit has cargo
		else if(u.cargo && u.cargo.length > 0 && (u.owner == PLAYING_PLAYER || PLAYING_PLAYER.controller == CONTROLLER.SPECTATOR))
		{
			c.fillStyle = "rgba(255, 255, 255, 0.2)";
			
			var spc = Math.min(u.type.cargoSpace, 10);
			c.fillRect(unitNfoX + 249, HEIGHT - 98, Math.ceil(spc / 2) * 47, spc == 1 ? 48 : 98);
			
			var sortedCargo = _.sortBy(u.cargo, function(e){ return -e.type.cargoUse; });
			
			c.strokeStyle = "white";
			c.lineWidth = 2;
			c.fillStyle = "rgba(255, 255, 255, 0.5)";
			
			var cargo = 0;
			
			for(var i = 0; i < sortedCargo.length && i < 10; i++)
			{
				var type = sortedCargo[i].type;
				
				if(cargo + type.cargoUse <= 10)
				{
					var x = unitNfoX + 254 + Math.floor(cargo / 2) * 46;
					var y = HEIGHT - 94 + (cargo % 2) * 46;
					var w = Math.ceil((type.cargoUse - 0.5) / 2) * 40;
					var h = type.cargoUse <= 1 ? 40 : 80;
					
					c.strokeRect(x, y, w, h);
					var img = type.getTitleImage(u.owner);
					var scale = Math.max(w / img.w, h / img.h);
					c.drawImage(img.file, img.x, img.y, img.w, img.h, x + w / 2 - img.w * scale / 2, y + h / 2 - img.h * scale / 2, img.w * scale, img.h * scale);
					
					// hover
					if(keyManager.x > x && keyManager.y > y && keyManager.x < x + w && keyManager.y < y + h)
						c.fillRect(x, y, w, h);
					
					cargo += type.cargoUse;
				}
				
				else
					i = sortedCargo.length;
			}
		}
		
		// display attributes
		else
		{
			
			// if damage not 0, display damage value and range
			if(u.type.dmg > 0 && !u.isUnderConstruction)
			{
				c.font = "bold 20px LCDSolid";
				
				// dmg
				var bonusDamage = u.owner.getValueModifier("dmg", u.type) + (u.modifierMods["dmg"] ? u.modifierMods["dmg"] : 0);
				var basicText = "Damage: " + u.type.dmg;
				drawText(c, basicText, "white", "16px LCDSolid", unitNfoX + 170, HEIGHT - 42);
				var pointer = unitNfoX + 170 + c.measureText(basicText).width + 6;
				
				if(bonusDamage)
				{
					var text = " (" + (bonusDamage > 0 ? "+" : "") + bonusDamage + ")";
					drawText(c, text, bonusDamage > 0 ? "#34DA34" : "#FF0000", "16px LCDSolid", pointer, HEIGHT - 42);
					pointer += c.measureText(text).width + 6;
				}
				
				var basicDmg = u.getValue("dmg");
				var modifiersObj = {};
				if(u.type.dmgModifierAttributes)
					for(var i = 0; i < u.type.dmgModifierAttributes.length; i++)
					{
						var att = u.type.dmgModifierAttributes[i];
						
						if(u.type.dmgModifierMultiplier && u.type.dmgModifierMultiplier[i])
							modifiersObj[att] = modifiersObj[att] ? ((modifiersObj[att] + basicDmg) * (u.type.dmgModifierMultiplier[i] - 1)) : ((u.type.dmgModifierMultiplier[i] - 1) * basicDmg);
						
						if(u.type.dmgModifierAddition && u.type.dmgModifierAddition[i])
							modifiersObj[att] = modifiersObj[att] ? (modifiersObj[att] + u.type.dmgModifierAddition[i]) : u.type.dmgModifierAddition[i];
					}
				
				var modifierStr = "";
				_.each(modifiersObj, function(val, att){
					if(val)
					{
						var text = " (" + (val > 0 ? "+" : "") + val + " vs " + att + ")";
						drawText(c, text, val > 0 ? "#34DA34" : "#FF0000", "16px LCDSolid", pointer, HEIGHT - 42);
						pointer += c.measureText(text).width + 8;
					}
				});
				
				// range
				var bonusRange = u.owner.getValueModifier("range", u.type) + (u.modifierMods["range"] ? u.modifierMods["range"] : 0);
				basicText = "Range: " + (u.type.range > 1 ? u.type.range : "Melee") + (u.type.minRange > 0 ? " (min: " + u.type.minRange + ")" : "");
				drawText(c, basicText, "white", "16px LCDSolid", unitNfoX + 170, HEIGHT - 60);
				if(bonusRange)
					drawText(c, " (" + (bonusRange > 0 ? "+" : "") + bonusRange + ")", bonusRange > 0 ? "#34DA34" : "#FF0000", "16px LCDSolid", unitNfoX + 170 + c.measureText(basicText).width + 6, HEIGHT - 60);
				
				// kills
				drawText(c, "Kills: " + u.kills, "white", "16px LCDSolid", unitNfoX + 170, HEIGHT - 24);
				
				// dmg hover
				if(keyManager.x > unitNfoX + 170 && keyManager.y > HEIGHT - 58 && keyManager.x < unitNfoX + 280 && keyManager.y < HEIGHT - 42)
				{
					this.drawHoverBox();
					drawText(c, "This is the damage this unit deals everytime it hits another unit. Attack speed: " + (Math.round(u.getValue("weaponCooldown") / 20 * 100) / 100) + " sec", "white", "18px LCDSolid", WIDTH - 340, HEIGHT - INTERFACE_HEIGHT - 270, 310, null, null, null, null, 18);
				}
				
				// range hover
				if(keyManager.x > unitNfoX + 170 && keyManager.y > HEIGHT - 76 && keyManager.x < unitNfoX + 280 && keyManager.y < HEIGHT - 60)
				{
					this.drawHoverBox();
					drawText(c, "This is the range this unit can shoot.", "white", "18px LCDSolid", WIDTH - 340, HEIGHT - INTERFACE_HEIGHT - 270, 310, null, null, null, null, 18);
				}
			}
			
			// stati
			var stati = "";
			
			if(u.type.flying)
				stati += "flying, ";
			
			if(u.type.isBiological)
				stati += "biological, ";
			
			if(u.type.isMechanical)
				stati += "mechanical, ";
			
			if(u.getValue("hasDetection"))
				stati += "detection, ";
			
			if(u.type.isUndead)
				stati += "undead, ";
			
			drawText(c, stati.slice(0, stati.length - 2), "white", "16px LCDSolid", unitNfoX + 320, HEIGHT - 24);
			
			// modifiers
			if(u.modifiers.length > 0)
			{
				var k = 0;
				for(var i = 0; i < u.modifiers.length && k < 5; i++)
					if(u.modifiers[i].modifier.image)
					{
						var img = u.modifiers[i].modifier.getTitleImage();
						c.drawImage(img.file, img.x, img.y, img.w, img.h, unitNfoX + 554, HEIGHT - INTERFACE_HEIGHT + 37 + k * 22, 20, 20);
						
						// hover
						if(keyManager.x > unitNfoX + 554 && keyManager.y > HEIGHT - INTERFACE_HEIGHT + 37 + k * 22 && keyManager.x < unitNfoX + 554 + 20 && keyManager.y < HEIGHT - INTERFACE_HEIGHT + 37 + k * 22 + 20)
						{
							this.drawHoverBox();
							
							var duration = (u.modifiers[i].removeAt && u.modifiers[i].removeAt > ticksCounter) ? (Math.ceil((u.modifiers[i].removeAt - ticksCounter) / 20) + " sec left") : null;
							
							drawText(c, u.modifiers[i].modifier.name, "yellow", "22px LCDSolid", WIDTH - 340, HEIGHT - INTERFACE_HEIGHT - 270, 310);
							
							if(duration)
								drawText(c, duration, "grey", "16px LCDSolid", WIDTH - 340, HEIGHT - INTERFACE_HEIGHT - 248, 310);
							
							var str = interpreteString(u.modifiers[i].modifier.description, u).split("#BR");
							for(var j = 0; j < str.length; j++)
								drawText(c, str[j], "white", "18px LCDSolid", WIDTH - 340, HEIGHT - INTERFACE_HEIGHT - 246 + (duration ? 28 : 0) + j * 22, 310, null, null, null, null, 18);
						}
						
						k++;
					}
			}
			
			// if has gold (= is Mine), display remaining gold amount
			if(u.type.startGold)
				drawText(c, "Gold remaining: " + u.gold, u.gold ? "white" : "red", "20px LCDSolid", unitNfoX + 170, HEIGHT - 60);
			
			// armor
			if(!isInvincible)
			{
				var bonusArmor = u.owner.getValueModifier("armor", u.type) + (u.modifierMods["armor"] ? u.modifierMods["armor"] : 0);
				c.font = "bold 20px LCDSolid";
				var basicText = "Armor: " + u.type.armor;
				drawText(c, basicText, "white", "16px LCDSolid", unitNfoX + 170, HEIGHT - 78);
				if(bonusArmor)
					drawText(c, " (" + (bonusArmor > 0 ? "+" : "") + bonusArmor + ")", bonusArmor > 0 ? "#34DA34" : "#FF0000", "16px LCDSolid", unitNfoX + 160 + c.measureText(basicText).width + 16, HEIGHT - 78);
				
				// armor hover
				if(keyManager.x > unitNfoX + 160 && keyManager.y > HEIGHT - 94 && keyManager.x < unitNfoX + 280 && keyManager.y < HEIGHT - 78)
				{
					this.drawHoverBox();
					drawText(c, "This is the units' armor. 1 armor reduces the incoming damage by 1.", "white", "18px LCDSolid", WIDTH - 340, HEIGHT - INTERFACE_HEIGHT - 270, 310, null, null, null, null, 18);
				}
			}
			
			// speed
			if(u.getValue("movementSpeed"))
			{
				var bonusSpeed = Math.round((u.owner.getValueModifier("movementSpeed", u.type) + (u.modifierMods["movementSpeed"] ? u.modifierMods["movementSpeed"] : 0)) * 20 * 100) / 100;
				c.font = "bold 20px LCDSolid";
				var basicText = "Speed: " + (Math.round(u.type.movementSpeed * 20 * 100) / 100);
				drawText(c, basicText, "white", "16px LCDSolid", unitNfoX + 170, HEIGHT - 96);
				if(bonusSpeed)
					drawText(c, " (" + (bonusSpeed > 0 ? "+" : "") + bonusSpeed + ")", bonusSpeed > 0 ? "#34DA34" : "#FF0000", "16px LCDSolid", unitNfoX + 160 + c.measureText(basicText).width + 16, HEIGHT - 96);
				
				// speed hover
				if(keyManager.x > unitNfoX + 160 && keyManager.y > HEIGHT - 112 && keyManager.x < unitNfoX + 280 && keyManager.y < HEIGHT - 96)
				{
					this.drawHoverBox();
					drawText(c, "This is the units' movement speed.", "white", "18px LCDSolid", WIDTH - 340, HEIGHT - INTERFACE_HEIGHT - 270, 310, null, null, null, null, 18);
				}
			}
			
		}
		
		// description hover
		if(keyManager.x > unitNfoX && keyManager.y > HEIGHT - 140 && keyManager.x < unitNfoX + 150)
		{
			this.drawHoverBox();
			drawText(c, u.type.description, "white", "18px LCDSolid", WIDTH - 340, HEIGHT - INTERFACE_HEIGHT - 270, 310, null, null, null, null, 18);
		}
		
	}
	
	// if more than 1 units selected
	else if(units.length > 1)
	{
		var x_ = unitNfoX + 160;
		var y_ = HEIGHT - 142;
		
		for(var i = this.unitsTab * 27; i < units.length; i++)
		{
			var u = units[i];
			
			// active
			if(u.type == this.unitTypeWithCurrentTabPrio)
			{
				c.fillStyle = "rgba(255, 255, 255, 0.2)";
				c.fillRect(x_ + 1.5, y_ + 1.5, 37, 40);
			}
			
			// unit img
			var img = u.type.getTitleImage(u.owner);
			var scale = Math.min(40 / img.w, 40 / img.h);
			var x = (40 - img.w * scale) / 2;
			var y = (40 - img.h * scale) / 2;
			
			c.drawImage(img.file, img.x, img.y, img.w, img.h, x_ + x, y_ + y, img.w * scale, img.h * scale);
			
			// hp bar (if not invincible)
			if(!isInvincible)
				u.drawHealthbar(x_ + 2, y_ + 39, 36, 4);
			
			// mana bar (if has mana)
			if(u.type.mana)
				u.drawManabar(x_ + 2, y_ + 32, 36, 4);
			
			// small building queue
			if((u.owner == PLAYING_PLAYER || PLAYING_PLAYER.controller == CONTROLLER.SPECTATOR) && u.queue && u.queue[0])
			{
				c.strokeStyle = "white";
				c.lineWidth = 1;
				
				for(var k = 0; k < BUILDING_QUEUE_LEN; k++)
				{
					c.strokeRect(x_ + 2.5 + k * 7, y_ + 28.5, 7, 7);
					c.fillStyle = u.queue[k] ? "rgba(0, 160, 230, 1)" : "rgba(255, 255, 255, 0.5)";
					c.fillRect(x_ + k * 7 + 3.5, y_ + 29.5, 5, 5);
				}
			}
			
			// hover
			if(keyManager.x > x_ && keyManager.y > y_ && keyManager.x < x_ + 40 && keyManager.y < y_ + 40)
			{
				this.drawHoverBox();
				drawText(c, u.type.description, "white", "18px LCDSolid", WIDTH - 340, HEIGHT - INTERFACE_HEIGHT - 270, 310, null, null, null, null, 18);
				
				this.drawUnitInfo(u);
				
				// box
				c.strokeStyle = "white";
				c.lineWidth = 1;
				c.strokeRect(x_ - 0.5, y_ - 0.5, 41, 44);
				
				this.currentHoverUnit = u;
			}
			
			x_ += 44;
			if(x_ > unitNfoX + 540)
			{
				x_ = unitNfoX + 160;
				y_ += 44;
				
				if(y_ > HEIGHT - 20)
					break;
			}
		}
		
		if(units.length > 27)
			for(var i = 0; i * 27 < units.length && i <= 4; i++)
			{
				var _x = unitNfoX + 594;
				var _y = HEIGHT - 139 + i * 24;
				
				// box
				c.strokeStyle = "white";
				c.fillStyle = (keyManager.x > _x && keyManager.y > _y && keyManager.x < _x + 20 && keyManager.y < _y + 20) ? "rgba(255, 255, 255, 0.8)" : "rgba(255, 255, 255, 0.5)";
				c.lineWidth = 2;
				c.strokeRect(_x, _y, 20, 20);
				c.fillRect(_x, _y, 20, 20);
				
				drawText(c, i + 1, "white", "bold 18px LCDSolid", unitNfoX + 606, HEIGHT - 122 + i * 24, 20, "center");
			}
	}
	
	
	// draw building @cursorpos, if ordering building placement right now
	var placedBuilding = keyManager.command && keyManager.command.type == COMMAND.MAKEBUILDING && keyManager.command.unitType;
	if(placedBuilding && placedBuilding.isBuilding)
	{
		var field = placedBuilding.getFieldFromMousePos();
		var hm = game.getHMValue4(field.x, field.y);
		
		c.globalAlpha = 0.6;
		placedBuilding.draw(field.x, field.y - hm * CLIFF_HEIGHT);
		c.globalAlpha = 1;
		var gap = FIELD_SIZE / 24;
		
		// draw red box with alpha over the image when blocked, otherwise white alpha, for every grid field the building covers
		for(x = field.x - 2; x < field.x + placedBuilding.size + 2; x++)
			for(y = field.y - 2; y < field.y + placedBuilding.size + 2; y++)
			{
				var f = new Field(x, y);
				var distanceAllowed = true;
				var nextGoldmine = game.getNextBuildingOfType(f, null, false, "startGold");
				var nextCC = game.getNextBuildingOfType(f, null, false, "takesGold");
				
				if(placedBuilding.takesGold && nextGoldmine && nextGoldmine.pos.distanceTo2(f) < game.globalVars.mineDist)
					distanceAllowed = false;
				
				if(placedBuilding.startGold && nextCC && nextCC.pos.distanceTo2(field) < game.globalVars.mineDist)
					distanceAllowed = false;
				
				if(PLAYING_PLAYER.team.fieldIsBlocked(f.x, f.y) || !distanceAllowed)
					c.fillStyle = "rgba(200, 0, 0, 0.25)";
				
				else if(x >= field.x && x < field.x + placedBuilding.size && y >= field.y && y < field.y + placedBuilding.size)
					c.fillStyle = "rgba(255, 255, 255, 0.45)";
				
				else
					c.fillStyle = "rgba(122, 255, 122, 0.2)";
				
				c.fillRect((f.x - 1) * FIELD_SIZE - game.cameraX + gap / 2, (f.y - 1 - hm * CLIFF_HEIGHT) * FIELD_SIZE - game.cameraY + gap / 2, FIELD_SIZE - gap, FIELD_SIZE - gap);
			}
	}
	
	var goldDisplay = "";
	var supplyDisplay = "";
	var maxSupplyDisplay = "";
	
	if(PLAYING_PLAYER.controller == CONTROLLER.SPECTATOR)
	{
		if(unit0 && unit0.owner.number > 0)
		{
			goldDisplay = Math.floor(unit0.owner.gold);
			supplyDisplay = Math.floor(unit0.owner.supply);
			maxSupplyDisplay = Math.floor(unit0.owner.maxSupply);
		}
		
		else
		{
			goldDisplay = "";
			supplyDisplay = "";
			maxSupplyDisplay = "";
		}
	}
	
	else
	{
		goldDisplay = Math.floor(PLAYING_PLAYER.gold);
		supplyDisplay = Math.floor(PLAYING_PLAYER.supply);
		maxSupplyDisplay = Math.floor(PLAYING_PLAYER.maxSupply);
	}
	
	if(game_state == GAME.PLAYING)
	{
		drawText(c, goldDisplay, "white", "bold 24px LCDSolid", WIDTH - 264, 35);
		
		var supplyFontColor = (PLAYING_PLAYER.supply < PLAYING_PLAYER.maxSupply || PLAYING_PLAYER.controller == CONTROLLER.SPECTATOR) ? "white" : "red";
		
		// supply
		drawText(c, supplyDisplay + " / " + maxSupplyDisplay, supplyFontColor, "bold 24px LCDSolid", WIDTH - 120, 35);
		
		// supply hover info
		if(keyManager.x > WIDTH - 168 && keyManager.y < 47)
		{
			this.drawHoverBox();
			drawText(c, "This is your supply count. The left number is your current supply ( = how many units you have). The right number is your maximum supply. If you reach it, you can't spawn any more units. You can build Houses or Castles to increase your max supply count up to " + game.globalVars.maxSupply + ".", "white", "18px LCDSolid", WIDTH - 340, HEIGHT - INTERFACE_HEIGHT - 270, 310, null, null, null, null, 18);
		}
		
		// timer
		var sec_total = Math.floor(ticksCounter * 50 / 1000);
		var min = Math.floor(sec_total / 60);
		var sec = sec_total % 60;
		sec = sec < 10 ? "0" + sec : sec;
		drawText(c, min + ":" + sec, "white", "bold 24px LCDSolid", WIDTH - 442, 35);
		
		// idle workers button
		if(game.playerHasIdleWorkers(PLAYING_PLAYER))
		{
			this.idleWorkersButtonIsActive = true;
			
			c.fillStyle = "rgba(155, 155, 155, 0.6)";
			c.fillRect(20, HEIGHT - MINIMAP_HEIGHT - 93, 70, 70);
			
			var img = lists.types.worker.getTitleImage(PLAYING_PLAYER);
			c.drawImage(img.file, img.x, img.y, img.w, img.h, 10, HEIGHT - MINIMAP_HEIGHT - 103, 90, 90);
			
			// hover
			if(keyManager.x > 20 && keyManager.x < 90 && keyManager.y > HEIGHT - MINIMAP_HEIGHT - 93 && keyManager.y < HEIGHT - MINIMAP_HEIGHT - 23)
			{
				c.fillRect(20, HEIGHT - MINIMAP_HEIGHT - 93, 70, 70);
				this.drawHoverBox();
				drawText(c, "You have idle workers. Click this button to select one of them.", "white", "18px LCDSolid", WIDTH - 340, HEIGHT - INTERFACE_HEIGHT - 270, 310, null, null, null, null, 18);
			}
		}
		else
			this.idleWorkersButtonIsActive = false;
	}
	
	// draw buttons
	if(game.humanUnitsSelected())
	{
		// check if tab prio is ok
		var currentTabPrioIsFine = false;
		for(var i = 0; i < units.length; i++)
			if(units[i].type == this.unitTypeWithCurrentTabPrio)
				currentTabPrioIsFine = true;
		
		// if prio has to be re-set
		if(!currentTabPrioIsFine)
		{
			this.unitTypeWithCurrentTabPrio = units[0].type;
			for(var i = 1; i < units.length; i++)
				if(units[i].type.tabPriority > this.unitTypeWithCurrentTabPrio.tabPriority)
					this.unitTypeWithCurrentTabPrio = units[i].type;
		}
		
		for(var i = 0; i < this.buttons.length; i++)
			if(this.buttons[i].isVisible(this.unitTypeWithCurrentTabPrio))
				this.buttons[i].draw(keyManager.x, keyManager.y);
	}
	
	// fps
	if(show_fps)
		drawText(c, fps.toString(), "white", "30px LCDSolid", 20, HEIGHT - INTERFACE_HEIGHT - 114);
	
	// spectator stuff: show supply and gold
	if(PLAYING_PLAYER.controller == CONTROLLER.SPECTATOR)
	{
		// supply icon
		c.drawImage(miscSheet[0], imgs.supply.img.x, imgs.supply.img.y, imgs.supply.img.w, imgs.supply.img.h, WIDTH - 190, HEIGHT - 150, imgs.supply.img.w * 2, imgs.supply.img.h * 2);
		
		// gold icon
		c.drawImage(miscSheet[0], imgs.gold.img.x, imgs.gold.img.y, imgs.gold.img.w, imgs.gold.img.h, WIDTH - 100, HEIGHT - 150, imgs.gold.img.w * 2, imgs.gold.img.h * 2);
		
		var nr = 0;
		
		for(var i = 0; i < game.players.length && nr < 2; i++)
			if(game.players[i])
			{
				var p = game.players[i];
				
				if(p.controller != CONTROLLER.SPECTATOR && p.controller != CONTROLLER.NONE)
				{
					// rect to indicate player nr
					var arr = playerColors[p.number - 1][3];
					c.fillStyle = "rgb(" + arr[0] + ", " + arr[1] + ", " + arr[2] + ")";
					c.fillRect(WIDTH - 354, HEIGHT - 96 + nr * 40, 342, 30);
					
					// name
					drawText(c, p.name, "white", "20px LCDSolid", WIDTH - 340, HEIGHT - 74 + nr * 40);
					
					// supply
					drawText(c, p.supply + " / " + p.maxSupply, "white", "20px LCDSolid", WIDTH - 200, HEIGHT - 74 + nr * 40);
					
					// gold
					drawText(c, Math.floor(p.gold), "white", "20px LCDSolid", WIDTH - 90, HEIGHT - 74 + nr * 40);
					
					nr++;
				}
			}
	}
};

Interface.prototype.drawUnitInfo = function(unit)
{
	// img
	var img = unit.type.getTitleImage(unit.owner);
	var scale = Math.min(INTERFACE_UNIT_IMG_SIZE / img.w, INTERFACE_UNIT_IMG_SIZE / img.h);
	var x = (INTERFACE_UNIT_IMG_SIZE - img.w * scale) / 2;
	var y = (INTERFACE_UNIT_IMG_SIZE - img.h * scale) / 2;
	c.drawImage(img.file, img.x, img.y, img.w, img.h, (WIDTH - 780) / 2 + 78 - img.w * scale / 2, HEIGHT - 140 + y, img.w * scale, img.h * scale);
	
	// name
	var name = (unit.type.name == "Archer" && unit.owner.getUpgradeLevel(lists.types.upgspeed) >= 2) ? "Ranger" : unit.type.name; // special: if archer and speed upg at least 3, name is "Ranger"
	var fontSize = Math.max(Math.min(30 - (name.length - 6) * 3, 30), 14);
	drawText(c, name, "white", "bold " + fontSize + "px LCDSolid", (WIDTH - 783) / 2 + 78, HEIGHT - 14, 150, "center", null, null, null, fontSize);
};

// draw a box at the bottom right (above the interface), where the button hover text for command buttons is placed in
Interface.prototype.drawHoverBox = function()
{
	// rect
	c.fillStyle = "#4E4A4E";
	c.lineWidth = 4;
	c.strokeStyle = "#757161";
	c.fillRect(WIDTH - 350, HEIGHT - INTERFACE_HEIGHT - 300, 342, 292);
	c.strokeRect(WIDTH - 350, HEIGHT - INTERFACE_HEIGHT - 300, 342, 292);
	
	// small black line below the top boarder
	c.lineWidth = 1;
	c.strokeStyle = "rgba(0, 0, 0, 0.8)";
	c.beginPath();
	c.moveTo(WIDTH - 348, HEIGHT - INTERFACE_HEIGHT - 297.5);
	c.lineTo(WIDTH - 10, HEIGHT - INTERFACE_HEIGHT - 297.5);
	c.stroke();
	
	// small black line right the left border
	c.strokeStyle = "rgba(0, 0, 0, 0.4)";
	c.beginPath();
	c.moveTo(WIDTH - 347.5, HEIGHT - INTERFACE_HEIGHT - 297.5);
	c.lineTo(WIDTH - 347.5, HEIGHT - INTERFACE_HEIGHT - 110);
	c.stroke();
};

Interface.prototype.rightClick = function(x, y)
{
	for(var i = 0; i < this.buttons.length; i++)
	{
		var b = this.buttons[i];
		
		if(b.contains(x, y) && b.isVisible(this.unitTypeWithCurrentTabPrio) && b.command.hasAutocast)
		{
			if(game.humanUnitsSelected())
			{
				soundManager.playSound(SOUND.INGAMECLICK);
				game.issueOrderToUnits(game.selectedUnits, b.command, null, null, true, !game.selectedUnits[0].autocast.contains(b.command.id));
			}
			
			return true;
		}
	}
};

// gets called on left click; check if a button was clicked, do stuff and return true, if yes
Interface.prototype.leftClick = function(x, y)
{
	// check, if a unit was clicked
	if(this.currentHoverUnit)
	{
		// if strg is pressed, select all units of that type
		if(keyManager.keys[KEY.STRG])
		{
			// if shift pressed, remove all units of that type
			if(keyManager.keys[KEY.SHIFT])
			{
				for(var i = 0; i < game.selectedUnits.length; i++)
					if(game.selectedUnits[i].type == this.currentHoverUnit.type)
					{
						game.selectedUnits.splice(i, 1);
						i--;
					}
			}
			
			// if no shift pressed, select all units of that type
			else
			{
				var units = [];
				for(var i = 0; i < game.selectedUnits.length; i++)
					if(game.selectedUnits[i].type == this.currentHoverUnit.type)
						units.push(game.selectedUnits[i]);
				game.selectedUnits = units;
				this.unitsTab = 0;
			}
		}
		
		// if shift pressed, remove this unit
		else if(keyManager.keys[KEY.SHIFT])
			game.selectedUnits.erease(this.currentHoverUnit);
		
		// if nothing pressed, just select the clicked unit
		else
		{
			game.selectedUnits = [this.currentHoverUnit];
			this.unitsTab = 0;
		}
		
		soundManager.playSound(SOUND.INGAMECLICK);
		
		while(this.unitsTab * 27 + 1 > game.selectedUnits.length && this.unitsTab > 0)
			this.unitsTab--;
	}
	
	else if(game.selectedUnits.length > 27)
		for(var i = 0; i * 27 < game.selectedUnits.length && i <= 4; i++)
		{
			var _x = (WIDTH - 780) / 2 + 594;
			var _y = HEIGHT - 139 + i * 24;
			
			if(keyManager.x > _x && keyManager.y > _y && keyManager.x < _x + 20 && keyManager.y < _y + 20)
			{
				this.unitsTab = i;
				soundManager.playSound(SOUND.INGAMECLICK);
			}
		}
	
	for(var i = 0; i < this.buttons.length; i++)
	{
		var b = this.buttons[i];
		
		if(b.contains(x, y) && b.isVisible(this.unitTypeWithCurrentTabPrio))
		{
			var requirement_text = PLAYING_PLAYER.getCommandRequirementText(b.command, game.selectedUnits, null, b.learn);
			
			// if requirements of the corresponding command are met
			if(!requirement_text)
			{
				keyManager.order(b.command, b.learn);
				soundManager.playSound(SOUND.INGAMECLICK, null, 0.7);
				return true;
			}
			else
			{
				soundManager.playSound(SOUND.NEGATIVE, null, 0.6);
				this.addMessage(requirement_text, "red", imgs.attentionmark);
				return true;
			}
		}
	}
	
	// idleworkers button is active and has been clicked
	if(this.idleWorkersButtonIsActive && keyManager.x > 20 && keyManager.x < 90 && keyManager.y > HEIGHT - MINIMAP_HEIGHT - 93 && keyManager.y < HEIGHT - MINIMAP_HEIGHT - 23)
	{
		c.fillStyle = "rgba(155, 155, 155, 0.5)";
		c.fillRect(20, HEIGHT - MINIMAP_HEIGHT - 93, 70, 70);
		
		// get all idle workers
		var workers = [];
		for(var i = 0; i < game.units.length; i++)
			if(game.units[i].owner == PLAYING_PLAYER && game.units[i].type == lists.types.worker && game.units[i].order && game.units[i].order.type == COMMAND.IDLE)
				workers.push(game.units[i]);
		
		if(workers.length > 0)
		{
			// if strg is pressed, select all workers
			if(keyManager.keys[KEY.STRG])
			{
				game.selectedUnits = workers;
				this.unitsTab = 0;
				
				var centerPosition = game.getCenterOfUnits(workers);
				
				// jump the camera to the worker
				game.cameraX = centerPosition.px * FIELD_SIZE - WIDTH / 2;
				game.cameraY = centerPosition.py * FIELD_SIZE - HEIGHT / 2;
			}
			
			// else, only select one worker
			else
			{
				// increase the index and select the worker
				this.idleWorkerIndex = (this.idleWorkerIndex + 1) % workers.length;
				var worker = workers[this.idleWorkerIndex];
				game.selectedUnits = [worker];
				this.unitsTab = 0;
				
				// jump the camera to the worker
				game.cameraX = worker.pos.px * FIELD_SIZE - WIDTH / 2;
				game.cameraY = worker.pos.py * FIELD_SIZE - HEIGHT / 2;
			}
		}
		
		// play sound
		soundManager.playSound(SOUND.CLICK2);
		
		return true;
	}
	
	var unitNfoX = (WIDTH - 780) / 2;
	
	// if unit has cargo
	if(game.selectedUnits && game.selectedUnits.length == 1 && game.selectedUnits[0].cargo && game.selectedUnits[0].cargo.length > 0 && game.selectedUnits[0].owner == PLAYING_PLAYER)
	{
		var sortedCargo = _.sortBy(game.selectedUnits[0].cargo, function(e){ return -e.type.cargoUse; });
		
		var cargo = 0;
		
		for(var i = 0; i < sortedCargo.length && i < 10; i++)
		{
			if(cargo + sortedCargo[i].type.cargoUse <= 10)
			{
				var x = unitNfoX + 254 + Math.floor(cargo / 2) * 46;
				var y = HEIGHT - 94 + (cargo % 2) * 46;
				var w = Math.ceil((sortedCargo[i].type.cargoUse - 0.5) / 2) * 40;
				var h = sortedCargo[i].type.cargoUse <= 1 ? 40 : 80;
				
				if(keyManager.x > x && keyManager.y > y && keyManager.x < x + w && keyManager.y < y + h)
					for(var k = 0; k < game.selectedUnits[0].cargo.length; k++)
						if(game.selectedUnits[0].cargo[k] == sortedCargo[i])
						{
							game.issueOrderToUnits(game.selectedUnits, lists.types.directunload, k);
							soundManager.playSound(SOUND.CLICK2);
							return true;
						}
				
				cargo += sortedCargo[i].type.cargoUse;
			}
			
			else
				i = sortedCargo.length;
		}
	}
	
	return false;
};

// gets called on key pressed
Interface.prototype.keyPressed = function(key)
{
	if(key == KEY.F10)
	{
		if($('#optionsWindow')[0].style.display == "none")
			fadeIn($('#optionsWindow'));
		else
			fadeOut($('#optionsWindow'));
	}
	
	if(key == KEY.F9)
	{
		if($('#chatHistoryWindow')[0].style.display == "none")
			fadeIn($('#chatHistoryWindow'));
		else
			fadeOut($('#chatHistoryWindow'));
	}
	
	// set current tab prio to the next lower one
	if(key == KEY.TAB && this.unitTypeWithCurrentTabPrio && game.humanUnitsSelected())
	{
		var currentPrio = this.unitTypeWithCurrentTabPrio.tabPriority;
		
		var units = game.selectedUnits;
		
		var newType = null;
		for(var i = 0; i < game.selectedUnits.length; i++)
			if(units[i].type.tabPriority < currentPrio && (!newType || units[i].type.tabPriority > newType.typPrio))
				newType = units[i].type;
		
		// the current prio is the lowest, so new use now the highest
		if(!newType)
		{
			newType = units[0];
			for(var i = 1; i < units.length; i++)
				if(units[i].type.tabPriority > newType.typPrio)
					newType = units[i].type;
		}
		
		if(newType)
			this.unitTypeWithCurrentTabPrio = newType;
	}
	
	// check if a command button has this key as a hotkey, and press it in case
	for(var i = 0; i < this.buttons.length; i++)
	{
		var cmd = this.buttons[i].command;
		
		if(cmd.hotkey == key && this.buttons[i].isVisible(this.unitTypeWithCurrentTabPrio) && game.humanUnitsSelected())
		{
			// if requirement met
			var requirement_text = PLAYING_PLAYER.getCommandRequirementText(cmd, game.selectedUnits);
			
			if(!requirement_text)
			{
				keyManager.order(cmd);
				soundManager.playSound(SOUND.INGAMECLICK, null, 0.7);
			}
			else
			{
				soundManager.playSound(SOUND.NEGATIVE, null, 0.6);
				this.addMessage(requirement_text, "red", imgs.attentionmark);
			}
		}
	}
};
// represents an ingame command button (attack, make unit, ...)
function Button(command, learn)
{
	this.init(command, learn);
};

Button.prototype.init = function(command, learn)
{
	this.command = command; // the command, this buttons refers to
	this.learn = learn;
	
	if(learn)
	{
		this.x = (5 - command.learnInterfacePosX) * 72 + 4; // x distance to the right screen border
		this.y = (2 - command.learnInterfacePosY) * 72 + 4; // x distance to the right screen border
		this.hotkey = command.learnHotkey;
	}
	
	else
	{
		this.x = (5 - command.interfacePosX) * 72 + 4; // x distance to the right screen border
		this.y = (2 - command.interfacePosY) * 72 + 4; // x distance to the right screen border
		this.hotkey = command.hotkey;
	}
};

Button.prototype.getCC = function()
{
	return this.command.getValue(this.learn ? "learnCommandCard" : "commandCard", game.selectedUnits[0]);
};

Button.prototype.draw = function(mouseX, mouseY)
{
	// if learn and all levels learned, dont draw shit
	if(this.learn)
	{
		var canLearn = false;
		for(var i = 0; i < game.selectedUnits.length; i++)
			if(game.selectedUnits[i].type.commands[this.command.id_string] && game.selectedUnits[i].abilityLevels[this.command.id] < this.command.requiredLevels.length)
				canLearn = true;
		
		if(!canLearn)
			return;
	}
	
	// check lvl
	var maxLvl = 0;
	if(this.command.requiredLevels && this.command.requiredLevels > 0)
	{
		for(var i = 0; i < game.selectedUnits.length; i++)
			if(game.selectedUnits[i].abilityLevels)
				maxLvl = Math.max(game.selectedUnits[i].abilityLevels[this.command.id], maxLvl);
		
		if(maxLvl == 0 && !this.learn)
			return;
	}
	
	// check if the button is pressed / active
	var pressed = (keyManager.command == this.command || ((keyManager.keys[this.hotkey] || (this.contains(mouseX, mouseY) && keyManager.leftMouse)) && keyManager.commandCardWhenPressStart == this.getCC()));
	
	// calculate total width / height of the image
	var d = imgs.button.img.w;
	
	// draw border img
	var borderImg = pressed ? imgs.button2.img : imgs.button.img;
	c.drawImage(miscSheet[0], borderImg.x, borderImg.y, borderImg.w, borderImg.h, WIDTH - this.x, HEIGHT - this.y, borderImg.w, borderImg.h);
	
	// check if requirement is met; if not, use greyscaled image
	var requirement_text = PLAYING_PLAYER.getCommandRequirementText(this.command, game.selectedUnits, null, this.learn);
	var img = this.command.getTitleImage(requirement_text ? (MAX_PLAYERS + 1) : PLAYING_PLAYER.number);
	
	// draw button img itself
	var scale = Math.min((d * 0.95) / img.w, (d * 0.95) / img.h);
	scale = scale > 1 ? Math.floor(scale) : scale;
	var x = Math.floor(WIDTH - this.x + (pressed ? 1 : 0) + (d - img.w * scale) / 2);
	var y = Math.floor(HEIGHT - this.y + (pressed ? 1 : 0) + (d - img.h * scale) / 2);
	
	c.drawImage(img.file, img.x, img.y, img.w, img.h, x, y, img.w * scale, img.h * scale);
	
	// if autocast is on
	if(!this.learn && this.command.hasAutocast && game.selectedUnits[0].autocast.contains(this.command.id))
		drawText(c, "auto", "yellow", "bold 22px LCDSolid" , x + (pressed ? 4 : 3), y + (pressed ? 50 : 49));
	
	// draw hotkey
	drawText(c, "[" + getKeyName(this.hotkey) + "]", "white", "bold 20px LCDSolid", WIDTH - this.x + (pressed ? 4 : 3), HEIGHT - this.y + (pressed ? 22 : 21));
	
	// if cooldowning, draw cooldown
	if(!this.learn && this.command.cooldown2)
	{
		// get shortest cooldown
		var shortestCD = 9999999;
		for(var i = 0; i < game.selectedUnits.length; i++)
			if(game.selectedUnits[i].type == interface_.unitTypeWithCurrentTabPrio)
				shortestCD = Math.min(game.selectedUnits[i].lastTickAbilityUsed[this.command.id] + this.command.getValue("cooldown2", game.selectedUnits[i]) - ticksCounter, shortestCD);
		
		if(shortestCD < 9999999 && shortestCD > 0)
		{
			c.fillStyle = "rgba(0, 0, 0, 0.55)";
			c.fillRect(pressed ? WIDTH - this.x + SCALE_FACTOR : WIDTH - this.x, pressed ? HEIGHT - this.y + SCALE_FACTOR : HEIGHT - this.y, d, d);
			drawText(c, Math.ceil(shortestCD / 20), "white", "bold 20px LCDSolid", WIDTH - this.x + (pressed ? 4 : 3) + 30, HEIGHT - this.y + (pressed ? 22 : 21) + 20, 60, "center");
		}
	}
	
	// if hover
	if(this.contains(mouseX, mouseY))
	{
		// draw button hover effect
		c.fillStyle = "rgba(255, 255, 255, 0.15)";
		c.fillRect(pressed ? WIDTH - this.x + SCALE_FACTOR : WIDTH - this.x, pressed ? HEIGHT - this.y + SCALE_FACTOR : HEIGHT - this.y, d, d);
		
		interface_.drawHoverBox();
		
		// draw command name
		drawText(c, this.command.name, "white", "bold 26px LCDSolid", WIDTH - 340, HEIGHT - INTERFACE_HEIGHT - 270);
		
		// draw command description
		var offset = 0;
		var desc = interpreteString(this.command.description, game.selectedUnits[0]).split("#BR");
		for(var i = 0; i < desc.length; i++)
			offset += 24 * drawText(c, desc[i], "yellow", "16px LCDSolid", WIDTH - 340, HEIGHT - INTERFACE_HEIGHT - 234 + offset, 320, null, null, null, null, 16);
		
		// mana cost
		var unit = null;
		for(var i = 0; i < game.selectedUnits.length; i++)
			if(game.selectedUnits[i].type == interface_.unitTypeWithCurrentTabPrio)
				unit = game.selectedUnits[i];
		
		if(unit && this.command.getValue("manaCost", unit))
			offset += 28 + 28 * drawText(c, "Mana Cost: " + this.command.getValue("manaCost", unit), "rgba(200, 0, 200, 1)", "20px LCDSolid", WIDTH - 340, HEIGHT - INTERFACE_HEIGHT - 234 + offset, 320);
		
		// draw condition (if not met)
		if(requirement_text)
			offset += 28 * drawText(c, requirement_text, "red", "20px LCDSolid", WIDTH - 340, HEIGHT - INTERFACE_HEIGHT - 234 + offset, 320);
		
		// draw lvl
		if(maxLvl > 0 || this.learn)
			offset += 28 * drawText(c, "Level: " + maxLvl, "white", "20px LCDSolid", WIDTH - 340, HEIGHT - INTERFACE_HEIGHT - 234 + offset, 320);
				
	}
};

// returns, if a button is visible; argument is the current selected unit type
Button.prototype.isVisible = function(unitType)
{
	if(unitType && game.selectedUnitsCanPerformOrder(this.command, unitType) && interface_.commandCard == this.getCC())
	{
		if(this.command.upgrade && this.command.upgrade.maxLevel && (PLAYING_PLAYER.getUpgradeLevel(this.command.upgrade) + PLAYING_PLAYER.upgradeCountInResearch(this.command.upgrade)) >= this.command.upgrade.maxLevel)
			return false;
		
		if(this.command.type == COMMAND.BUILDING_UPGRADE && this.command.improvedBuilding)
		{
			for(var i = 0; i < game.selectedUnits.length; i++)
				if(!game.selectedUnits[i].hasInQueue(this.command.improvedBuilding))
					return true;
			return false;
		}
		
		return true;
	}
	
	return false;
};

// checks if button contains the specified coordinates
Button.prototype.contains = function(x, y)
{
	return x >= WIDTH - this.x && y >= HEIGHT - this.y && x <= WIDTH - this.x + imgs.button.img.w && y <= HEIGHT - this.y + imgs.button.img.h;
};
// does the flying white-yellow-green showish-looking stuff
function Enviroment()
{
	this.dots = [];
	this.img = null;
	this.countDots = 190;
	this.pixel = document.createElement("canvas");
	this.pixel.width = 1;
	this.pixel.height = 1;
};

Enviroment.prototype.draw = function()
{
	for(var i = 0; i < this.dots.length; i++)
		if(!this.dots[i].draw())
			this.dots.splice(i, 1);
	
	while(this.dots.length < this.countDots / SCALE_FACTOR)
		this.dots.push(new Dot(Math.random() * WIDTH, Math.random() * HEIGHT, this.alpha));
};

Enviroment.prototype.setFromTheme = function(theme)
{
	this.pixel.getContext("2d").fillStyle = theme.particleColor;
	this.pixel.getContext("2d").fillRect(0, 0, 1, 1);
	this.countDots = theme.countDots;
};


function Dot(x, y, alpha)
{
	this.x = x;
	this.y = y;
	this.vx = 4;
	this.vy = 4;
	this.timeToLive = 3 + Math.random() * 3;
	this.size = 1;
	this.alpha = alpha;
};

Dot.prototype.draw = function()
{
	if(!game_paused)
	{
		this.alpha = Math.max(Math.min(this.alpha + Math.random() * 0.02 - 0.01, env.alpha + 0.15), env.alpha - 0.15);
		this.vx += (Math.random() - 0.5);
		this.vy += (Math.random() - 0.5);
		this.x += this.vx * gameTimeDiff * 10;
		this.y += this.vy * gameTimeDiff * 10;
		this.timeToLive -= gameTimeDiff;
	}
	
	var camX = game ? game.cameraX : 0;
	var camY = game ? game.cameraY : 0;
	
	while(this.x > camX + WIDTH)
		this.x -= WIDTH;
	
	while(this.x < camX)
		this.x += WIDTH;
	
	while(this.y > camY + HEIGHT)
		this.y -= HEIGHT;
	
	while(this.y < camY)
		this.y += HEIGHT;
	
	// draw
	c.globalAlpha = Math.max(Math.min(this.timeToLive, 1), 0);
	c.drawImage(env.pixel, this.x - camX, this.y - camY, this.size * SCALE_FACTOR, this.size * SCALE_FACTOR);
	c.globalAlpha = 1;
	return this.timeToLive > 0;
};
// does the flying white-yellow-green showish-looking stuff
function Rain()
{
	this.drops = [];
	this.img = null;
	this.countDrops = 500;
	
	this.middleX = 0;
	this.middleY = 0;
	
	this.lastRainSoundStart = -999;
};

Rain.prototype.draw = function()
{
	if (noRain)
	{
		musicManager.rain[0].volume = 0;
		musicManager.rain[1].volume = 0;
		return;
	}
	var time = ticksCounter / 20 / 60;
	
	var period = null;
	// Each tick, work out if we're in a rain period
	for(var i = 0; i < game.rainTime.length; i++)
	{
		if(game.rainTime[i].start < time && game.rainTime[i].end > time)
		{
			period = game.rainTime[i];
			i = game.rainTime.length;
		}
	}
	
	// If we're not in a rain period, disable the sound and exit
	if(!period)
	{
		musicManager.rain[0].volume = 0;
		musicManager.rain[1].volume = 0;
		return;
	}
	
	var dropCountDensity = 1;
	
	if(time < period.start + 0.1)
		dropCountDensity = (time - period.start) / 0.1;
	
	else if(time > period.end - 0.1)
		dropCountDensity = (period.end - time) / 0.1;
	
	musicManager.rain[0].volume = 0.6 * sound_volume * dropCountDensity;
	musicManager.rain[1].volume = 0.6 * sound_volume * dropCountDensity;
	
	if(this.lastRainSoundStart + 2000 < timestamp && (musicManager.rain[0].currentTime <= 0 || musicManager.rain[0].currentTime >= musicManager.rain[0].duration - 0.1) && (musicManager.rain[1].currentTime <= 0 || musicManager.rain[1].currentTime >= musicManager.rain[1].duration - 0.1))
	{
		if(musicManager.rain[0].currentTime >= musicManager.rain[0].duration - 0.1)
		{
			musicManager.rain[1].src = musicManager.rain[1].src;
			musicManager.rain[1].play();
		}
		
		else
		{
			musicManager.rain[0].src = musicManager.rain[0].src;
			musicManager.rain[0].play();
		}
		
		this.lastRainSoundStart = timestamp;
	}
	
	c.strokeStyle = "rgba(255, 255, 255, 1)";
	c.beginPath();
	
	var vert = (WIDTH > (HEIGHT * 2) ? WIDTH : (HEIGHT * 2));
	this.countDrops = Math.floor(WIDTH * 0.5 * dropCountDensity);
	vert *= 3 / SCALE_FACTOR;
	var hori = vert / 2;
	
	this.middleX = game.cameraX + WIDTH * 0.4;
	this.middleY = game.cameraY + hori * 0.3;
	
	for(var i = 0; i < this.drops.length; i++)
		if(!this.drops[i].draw(this))
			this.drops.splice(i, 1);
	
	c.globalAlpha = 1;
	
	while(this.drops.length < this.countDrops / SCALE_FACTOR)
		this.drops.push(new Drop());
};


function Drop()
{
	this.x = Math.random() * WIDTH;
	this.y = Math.random() * WIDTH;
	this.z = 1 + Math.random();
};

Drop.prototype.draw = function(rain)
{
	if(!game_paused)
		this.z -= gameTimeDiff * 1.0;
	
	while(this.x > game.cameraX + WIDTH)
		this.x -= WIDTH;
	
	while(this.x < game.cameraX)
		this.x += WIDTH;
	
	while(this.y > game.cameraY + HEIGHT)
		this.y -= HEIGHT;
	
	while(this.y < game.cameraY)
		this.y += HEIGHT;
	
	// draw
	if(this.z > 0)
	{
		var z1 = this.z * SCALE_FACTOR / 3;
		
		var topX = this.x + (this.x - rain.middleX) * (0.7 - SCALE_FACTOR / 20);
		var topY = this.y + (this.y - rain.middleY) * 0.8;
		var z2 = z1 + 0.004 * SCALE_FACTOR;
		
		var x1 = (this.x + (topX - this.x) * z1) - game.cameraX;
		var y1 = (this.y + (topY - this.y) * z1) - game.cameraY - z1 * HEIGHT;
		
		if(y1 > -10 && y1 < (HEIGHT - INTERFACE_HEIGHT) && x1 > -10 && x1 < (WIDTH + 10))
		{
			c.lineWidth = 1 + SCALE_FACTOR * 0.25 + SCALE_FACTOR * 0.25 * Math.min(this.z, 1);
			c.globalAlpha = 0.4 * Math.max(Math.min(z1 * 3, 1), 0.01);
			
			c.beginPath();
			c.moveTo(x1, y1);
			c.lineTo((this.x + (topX - this.x) * z2) - game.cameraX, (this.y + (topY - this.y) * z2) - game.cameraY - z2 * HEIGHT);
			c.stroke();
		}
		
		return true;
	}
	
	return false;
};
// the minimap at the bottom left of the screen
function Minimap(game, x, y)
{
	if(!game)
		throw "Game is not defined or null. Game must be defined when creating Minimap!";
	
	this.game = game;
	this.x = x;
	this.y = y;
	
	this.mapPings = [];
	
	this.x_scale = MINIMAP_WIDTH / game.x;
	this.y_scale = MINIMAP_HEIGHT / game.y;
	
	// create additional canvas for fog
	this.canvas = document.createElement('canvas');
	this.canvas.width = MINIMAP_WIDTH;
	this.canvas.height = MINIMAP_HEIGHT;
	
	// create additional canvas for screen fog
	this.screenCanvas = document.createElement('canvas');
	this.screenCanvas.width = (game.x + DEAD_MAP_SPACE) * FIELD_SIZE / SCALE_FACTOR;
	this.screenCanvas.height = (game.y + DEAD_MAP_SPACE) * FIELD_SIZE / SCALE_FACTOR;
	
	// editor screen fog
	this.editorCanvas = document.createElement('canvas');
	this.editorCanvas.width = (game.x + DEAD_MAP_SPACE) * FIELD_SIZE / SCALE_FACTOR;
	this.editorCanvas.height = (game.y + DEAD_MAP_SPACE) * FIELD_SIZE / SCALE_FACTOR;
	
	// darker border
	this.screenCanvas.getContext("2d").fillStyle = "rgba(0, 0, 0, 0.85)";
	this.screenCanvas.getContext("2d").fillRect(0, this.screenCanvas.height - (DEAD_MAP_SPACE + game.getHMValue2(1, 1) * CLIFF_HEIGHT) * 16, this.screenCanvas.width, DEAD_MAP_SPACE * 16); // bottom
	this.screenCanvas.getContext("2d").fillRect(this.screenCanvas.width - DEAD_MAP_SPACE * 16, 0, DEAD_MAP_SPACE * 16, this.screenCanvas.height - (DEAD_MAP_SPACE + game.getHMValue2(1, 1) * CLIFF_HEIGHT) * 16); // right
	
	// darker border screen fog
	this.editorCanvas.getContext("2d").fillStyle = "rgba(0, 0, 0, 0.8)";
	this.editorCanvas.getContext("2d").fillRect(0, this.editorCanvas.height - DEAD_MAP_SPACE * 16, this.editorCanvas.width, DEAD_MAP_SPACE * 16); // bottom
	this.editorCanvas.getContext("2d").fillRect(this.editorCanvas.width - DEAD_MAP_SPACE * 16, 0, DEAD_MAP_SPACE * 16, this.editorCanvas.height - DEAD_MAP_SPACE * 16); // right
	
	// create additional canvas for tiles (groundtiles and doodads)
	this.canvasTiles = document.createElement('canvas');
	this.canvasTiles.width = MINIMAP_WIDTH;
	this.canvasTiles.height = MINIMAP_HEIGHT;
	
	// create additional canvas for default groundtiles
	this.groundTiles = document.createElement('canvas');
	this.groundTiles.width = MINIMAP_WIDTH;
	this.groundTiles.height = MINIMAP_HEIGHT;
	
	// attack ping stuff
	this.tickOfLastAttackPing = -999;
	this.positionOfLastAttackPing = null;
};

Minimap.prototype.refreshTilesCanvas = function()
{
	var ctx = this.canvasTiles.getContext('2d');
	
	ctx.drawImage(this.groundTiles, 0, 0);
	
	var tiles = this.game.groundTiles2.concat(this.game.blockingTiles);
	
	for(var i = 1; i < tiles.length; i++)
		if(!tiles[i].type.ignoreGrid || true)
		{
			ctx.fillStyle = tiles[i].type.minimapColor;
			ctx.fillRect(Math.floor((tiles[i].x - 1) * this.x_scale), Math.floor((tiles[i].y - 1) * this.y_scale), Math.ceil(this.x_scale * tiles[i].type.sizeX), Math.ceil(this.y_scale * tiles[i].type.sizeY));
		}
};

// gets called when the player gets attacked, so he can display warning stuff
Minimap.prototype.attackPingAt = function(pos)
{
	// if last msg is more than 10 sec ago and msg is not in screen
	if(this.tickOfLastAttackPing + 200 < ticksCounter && !(pos.px > (game.cameraX / FIELD_SIZE) && pos.px < ((game.cameraX + WIDTH) / FIELD_SIZE) && pos.py > (game.cameraY / FIELD_SIZE) && pos.py < ((game.cameraY + HEIGHT) / FIELD_SIZE)))
	{
		this.tickOfLastAttackPing = ticksCounter;
		this.positionOfLastAttackPing = pos;
		
		// message
		interface_.addMessage("We are under attack", "red", imgs.underAttack);
		soundManager.playSound(SOUND.UNDER_ATTACK);
	}
};

Minimap.prototype.getFieldFromClick = function(x, y)
{
	return new Field(x / this.x_scale + 1, (y - HEIGHT + MINIMAP_HEIGHT) / this.y_scale);
};

Minimap.prototype.draw = function()
{
	var y_start = this.y < 0 ? HEIGHT + this.y : this.y;
	
	// draw tiles image
	c.drawImage(this.canvasTiles, this.x, y_start, MINIMAP_WIDTH, MINIMAP_HEIGHT);
	
	// buildings
	for(var i = 0; i < this.game.buildings2.length; i++)
		if(this.game.buildings2[i].seenBy[PLAYING_PLAYER.team.number])
		{
			var x = this.x_scale * (this.game.buildings2[i].x - 1);
			x -= x % this.x_scale;
			var y = this.y_scale * (this.game.buildings2[i].y - 1);
			y -= y % this.y_scale;
			c.fillStyle = (this.game.buildings2[i].owner.controller == CONTROLLER.NONE && !this.game.buildings2[i].type.startGold) ? "rgba(77, 166, 174, 0.9)" : this.game.buildings2[i].owner.getAllyColor();
			c.fillRect(x + this.x, y + y_start, this.x_scale * this.game.buildings2[i].type.size, this.y_scale * this.game.buildings2[i].type.size);
		}
	
	// units
	for(var i = 0; i < this.game.units.length; i++)
		if(PLAYING_PLAYER.team.canSeeUnit(this.game.units[i]) && PLAYING_PLAYER.team.canSeeUnitInvisible(this.game.units[i]))
		{
			var x = this.x_scale * (this.game.units[i].pos.x - 1);
			x -= x % this.x_scale;
			var y = this.y_scale * (this.game.units[i].pos.y - 1);
			y -= y % this.y_scale;
			c.fillStyle = this.game.units[i].owner.getAllyColor();
			c.fillRect(x + this.x, y + y_start, this.x_scale * 1.5, this.y_scale * 1.5);
		}
	
	// draw fog canvas
	if(game_state == GAME.PLAYING)
		c.drawImage(this.canvas, this.x, y_start, MINIMAP_WIDTH, MINIMAP_HEIGHT);
	
	// draw attack ping
	if(this.tickOfLastAttackPing + 100 > ticksCounter && this.positionOfLastAttackPing)
	{
		// calculate coords of pos on minimap
		var x = this.positionOfLastAttackPing.px * this.x_scale;
		var y = this.positionOfLastAttackPing.py * this.y_scale + y_start;
		var age = ticksCounter - this.tickOfLastAttackPing;
		
		// set drawing attributes
		c.strokeStyle = "red";
		c.lineWidth = 2;
		
		// draw horizontal line
		c.beginPath();
		c.moveTo(0, y);
		c.lineTo(MINIMAP_WIDTH, y);
		c.stroke();
		
		// draw vertical line
		c.beginPath();
		c.moveTo(x, y_start);
		c.lineTo(x, WIDTH);
		c.stroke();
		
		var offset = Math.max(50 - age * 4, 7);
		c.strokeRect(Math.max(x - offset, 0), Math.max(y - offset, y_start), Math.min(offset * 2, MINIMAP_WIDTH - (x - offset)), Math.min(offset * 2, HEIGHT - (y - offset)));
		
		if(age > 10)
		{
			c.fillStyle = "red";
			c.globalAlpha = 0.8 - (age / 10) % 0.8;
			c.fillRect(Math.max(x - 6, 0), Math.max(y - 6, y_start), Math.min(6 * 2, MINIMAP_WIDTH - (x - 6)), Math.min(6 * 2, HEIGHT - (y - 6)));
			c.globalAlpha = 1;
		}
	}
	
	// player pings
	for(var i = 0; i < this.mapPings.length; i++)
	{
		var age = Date.now() - this.mapPings[i].time;
		
		if(age > 7000) //ping is too old, kill it
		{
			this.mapPings.splice(i, 1);
			i--;
		}
		
		else
		{
			var ageAlpha = age > 5000 ? ((7000 - age) / 2000) : 1;
			
			c.globalAlpha = ageAlpha;
			
			var x = this.mapPings[i].field.x * this.x_scale;
			var y = this.mapPings[i].field.y * this.y_scale + y_start;
			
			c.strokeStyle = "yellow";
			c.lineWidth = 2;
			c.beginPath();
			c.moveTo(0, y);
			c.lineTo(MINIMAP_WIDTH, y);
			c.stroke();
			c.beginPath();
			c.moveTo(x, y_start);
			c.lineTo(x, HEIGHT);
			c.stroke();
			var d = Math.max(50 - age / 15, 7);
			c.strokeRect(Math.max(x - d, 0), Math.max(y - d, y_start), Math.min(d * 2, MINIMAP_WIDTH - (x - d)), Math.min(d * 2, HEIGHT - (y - d)));
			
			if(age > 10)
			{
				c.fillStyle = "yellow";
				c.globalAlpha = (0.8 - (age / 600) % 0.8) * ageAlpha;
				c.fillRect(Math.max(x - 6, 0), Math.max(y - 6, y_start), Math.min(6 * 2, MINIMAP_WIDTH - (x - 6)), Math.min(6 * 2, HEIGHT - (y - 6)));
				c.globalAlpha = 1;
			}
		}
	}
	
	// screen borders
	c.lineWidth = 2;
	c.strokeStyle = "white";
	
	var x1 = this.x_scale * game.cameraX / FIELD_SIZE;
	x1 -= x1 % this.x_scale;
	var y1 = this.y_scale * game.cameraY / FIELD_SIZE;
	y1 -= y1 % this.y_scale;
	var x2 = this.x_scale * (game.cameraX + WIDTH) / FIELD_SIZE;
	x2 -= x2 % this.x_scale;
	var y2 = this.y_scale * (game.cameraY + HEIGHT) / FIELD_SIZE;
	y2 -= y2 % this.y_scale;
	
	c.strokeRect(x1 + this.x, Math.max(y1, 0) + y_start, Math.min(x2 - x1, MINIMAP_WIDTH), Math.min(y2 - y1, MINIMAP_HEIGHT));
	
	if(game_state == GAME.EDITOR)
		c.drawImage(miscSheet[0], imgs.interfaceMapBorder.img.x, imgs.interfaceMapBorder.img.y, imgs.interfaceMapBorder.img.w, imgs.interfaceMapBorder.img.h, -16, HEIGHT - 200, imgs.interfaceMapBorder.img.w * 2, imgs.interfaceMapBorder.img.h * 2);
};

// true: fog, false: no fog
Minimap.prototype.setFog = function(x, y, fog)
{
	var alpha = (game.globalVars && game.globalVars.useDarkMask) ? darkFogMaskAlpha[fog] : fogMaskAlpha[fog];
	
	var h = this.game.getHMValue2(x, y);
	
	var x_ = (x - 1) * 16;
	var y_ = (y - 1 - h * CLIFF_HEIGHT) * 16;
	
	var h_ = 16;
	
	if(this.game.getHMValue2(x, y - 1) > h)
	{
		y_ -= CLIFF_HEIGHT * 16;
		h_ += CLIFF_HEIGHT * 16;
	}
	
	for(var i = 0; i < CLIFF_HEIGHT; i++)
		if(this.game.getHMValue2(x, y + 1 + i) > h)
			h_ = Math.max(h_ - (CLIFF_HEIGHT - i) * 16, 0);
	
	if(alpha == 0)
	{
		this.canvas.getContext('2d').clearRect(Math.floor((x - 1) * this.x_scale), Math.floor((y - 1) * this.y_scale), Math.ceil(this.x_scale), Math.ceil(this.y_scale));
		
		this.screenCanvas.getContext('2d').clearRect(x_, y_, 16, h_);
	}
	
	else
	{
		this.canvas.getContext('2d').fillStyle = "rgba(0, 0, 0, " + alpha + ")";
		this.canvas.getContext('2d').clearRect(Math.floor((x - 1) * this.x_scale), Math.floor((y - 1) * this.y_scale), Math.ceil(this.x_scale), Math.ceil(this.y_scale));
		this.canvas.getContext('2d').fillRect(Math.floor((x - 1) * this.x_scale), Math.floor((y - 1) * this.y_scale), Math.ceil(this.x_scale), Math.ceil(this.y_scale));
		
		this.screenCanvas.getContext('2d').fillStyle = "rgba(0, 0, 0, " + alpha + ")";
		this.screenCanvas.getContext('2d').clearRect(x_, y_, 16, h_);
		this.screenCanvas.getContext('2d').fillRect(x_, y_, 16, h_);
	}
};
// plays and manages all the sounds
function SoundManager()
{
	this.sounds = [];
	
	this.sounds[SOUND.FLESH] = this.loadSound([
		"sounds/hit05.ogg",
		"sounds/hit08.ogg",
		"sounds/hit13.ogg",
		"sounds/hit14.ogg"
	]);
	
	this.sounds[SOUND.LADDER_START] = this.loadSound([
		"sounds/ladder-start.ogg"
	]);
	
	this.sounds[SOUND.ARCHIVEMENT] = this.loadSound([
		"sounds/archivement.ogg"
	]);
	
	this.sounds[SOUND.ARCHIVEMENT2] = this.loadSound([
		"sounds/archivement2.ogg"
	]);
	
	this.sounds[SOUND.ARCHIVEMENT3] = this.loadSound([
		"sounds/archivement3.ogg"
	]);
	
	this.sounds[SOUND.WARP] = this.loadSound([
		"sounds/warp-totem.ogg",
		"sounds/warp-totem.ogg"
	]);
	
	this.sounds[SOUND.OPEN_WINDOW] = this.loadSound([
		"sounds/zip-new.ogg"
	]);
	
	this.sounds[SOUND.PAIN] = this.loadSound([
		"sounds/pain1.ogg",
		"sounds/pain2.ogg",
		"sounds/pain5.ogg",
		"sounds/pain1.ogg"
	]);
	
	this.sounds[SOUND.WOLF_PAIN] = this.loadSound([
		"sounds/wolf-pain.ogg",
		"sounds/wolf-pain-2.ogg",
		"sounds/wolf-pain.ogg",
		"sounds/wolf-pain-2.ogg"
	]);
	
	this.sounds[SOUND.BIRD_SPAWN] = this.loadSound([
		"sounds/bird1.ogg"
	]);
	
	this.sounds[SOUND.BIRD_YES] = this.loadSound([
		"sounds/bird2.ogg"
	]);
	
	this.sounds[SOUND.BIRD_DEATH] = this.loadSound([
		"sounds/bird3.ogg"
	]);
	
	this.sounds[SOUND.BIRD_SLAM] = this.loadSound([
		"sounds/bird-slam.ogg"
	]);
	
	this.sounds[SOUND.DEATH] = this.loadSound([
		"sounds/die1.ogg",
		"sounds/die2.ogg",
		"sounds/die1.ogg"
	]);
	
	this.sounds[SOUND.WOLF_DEATH] = this.loadSound([
		"sounds/wolf-die.ogg",
		"sounds/wolf-die-2.ogg"
	]);
	
	this.sounds[SOUND.WOLF_HIT] = this.loadSound([
		"sounds/wolf-hit.ogg",
		"sounds/wolf-hit-2.ogg",
		"sounds/wolf-hit.ogg"
	]);
	
	this.sounds[SOUND.SWING] = this.loadSound([
		"sounds/swing.ogg",
		"sounds/swing2.ogg",
		"sounds/swing4.ogg"
	]);
	
	this.sounds[SOUND.READY] = this.loadSound([
		"sounds/voices/ready1.ogg",
		"sounds/voices/ready2.ogg",
		"sounds/voices/ready3.ogg",
		"sounds/voices/ready4.ogg",
		"sounds/voices/ready5.ogg",
		"sounds/voices/ready7.ogg",
		"sounds/voices/ready8.ogg"
	]);
	
	this.sounds[SOUND.YES] = this.loadSound([
		"sounds/voices/yes1.ogg",
		"sounds/voices/yes2.ogg",
		"sounds/voices/yes3.ogg",
		"sounds/voices/yes4.ogg",
		"sounds/voices/yes5.ogg"
	]);
	
	this.sounds[SOUND.WOLF_YES] = this.loadSound([
		"sounds/voices/wolf-yes.ogg",
		"sounds/voices/wolf-yes-2.ogg"
	]);
	
	this.sounds[SOUND.WOLF_READY] = this.loadSound([
		"sounds/voices/wolf-spawn.ogg"
	]);
	
	this.sounds[SOUND.SWORD] = this.loadSound([
		"sounds/sword.ogg",
		"sounds/sword.ogg",
		"sounds/sword.ogg",
		"sounds/sword.ogg"
	]);
	
	this.sounds[SOUND.PLACE] = this.loadSound([
		"sounds/clic02.ogg"
	]);
	
	this.sounds[SOUND.NEGATIVE] = this.loadSound([
		"sounds/negative_2.ogg"
	]);
	
	this.sounds[SOUND.POSITIVE] = this.loadSound([
		"sounds/misc_menu.ogg"
	]);
	
	this.sounds[SOUND.CLICK] = this.loadSound([
		"sounds/click1.ogg"
	]);
	
	this.sounds[SOUND.CLICK2] = this.loadSound([
		"sounds/click.ogg"
	]);
	
	this.sounds[SOUND.BUILD] = this.loadSound([
		"sounds/build.ogg"
	]);
	
	this.sounds[SOUND.BUILDING_DEATH] = this.loadSound([
		"sounds/building_destroy.ogg",
		"sounds/building_destroy.ogg",
		"sounds/building_destroy.ogg"
	]);
	
	this.sounds[SOUND.REPAIR] = this.loadSound([
		"sounds/hammer1.ogg",
		"sounds/hammer2.ogg",
		"sounds/hammer3.ogg",
		"sounds/hammer1.ogg",
		"sounds/hammer2.ogg"
	]);
	
	this.sounds[SOUND.INGAMECLICK] = this.loadSound([
		"sounds/mouseclick1.ogg"
	]);
	
	this.sounds[SOUND.BUILDING_FINISHED] = this.loadSound([
		"sounds/building_finished.ogg",
		"sounds/building_finished.ogg"
	]);
	
	this.sounds[SOUND.UNDER_ATTACK] = this.loadSound([
		"sounds/under-attack.ogg"
	]);
	
	this.sounds[SOUND.VICTORY] = this.loadSound([
		"sounds/yeah.ogg"
	]);
	
	this.sounds[SOUND.DEFEAT] = this.loadSound([
		"sounds/defeat.ogg"
	]);
	
	this.sounds[SOUND.FLAMESTRIKE_LAUNCH] = this.loadSound([
		"sounds/flamestrike-throw.ogg",
		"sounds/flamestrike-throw.ogg",
		"sounds/flamestrike-throw.ogg"
	]);
	
	this.sounds[SOUND.FLAMESTRIKE_IMPACT] = this.loadSound([
		"sounds/flamestrike-impact.ogg",
		"sounds/flamestrike-impact.ogg",
		"sounds/flamestrike-impact.ogg"
	]);
	
	this.sounds[SOUND.MAGE_IMPACT] = this.loadSound([
		"sounds/mage-impact.ogg",
		"sounds/mage-impact.ogg",
		"sounds/mage-impact.ogg"
	]);
	
	this.sounds[SOUND.MAGE_ATTACK] = this.loadSound([
		"sounds/mage-attack.ogg",
		"sounds/mage-attack.ogg",
		"sounds/mage-attack.ogg"
	]);
	
	this.sounds[SOUND.GUN] = this.loadSound([
		"sounds/gun.ogg",
		"sounds/gun.ogg"
	]);
	
	this.sounds[SOUND.CATA_HIT] = this.loadSound([
		"sounds/cata-hit.ogg",
		"sounds/cata-hit.ogg"
	]);
	
	this.sounds[SOUND.CATA_LAUNCH] = this.loadSound([
		"sounds/catapult-launch.ogg",
		"sounds/catapult-launch-2.ogg",
		"sounds/catapult-launch.ogg",
		"sounds/catapult-launch-2.ogg"
	]);
	
	this.sounds[SOUND.CATA_IMPACT] = this.loadSound([
		"sounds/catapult-impact.ogg",
		"sounds/catapult-impact-2.ogg",
		"sounds/catapult-impact-3.ogg",
		"sounds/catapult-impact-4.ogg"
	]);
	
	this.sounds[SOUND.BUILDING_PAIN] = this.loadSound([
		"sounds/building-hit.ogg",
		"sounds/building-hit-3.ogg",
		"sounds/building-hit.ogg",
		"sounds/building-hit-3.ogg"
	]);
	
	this.sounds[SOUND.CATA_DEATH] = this.loadSound([
		"sounds/catapult_death.ogg",
		"sounds/catapult_death.ogg"
	]);
	
	this.sounds[SOUND.GAME_START] = this.loadSound([
		"sounds/gamestart.ogg"
	]);
	
	this.sounds[SOUND.HEAL] = this.loadSound([
		"sounds/heal.ogg",
		"sounds/heal.ogg"
	]);
	
	this.sounds[SOUND.BING] = this.loadSound([
		"sounds/bing2.ogg"
	]);
	
	this.sounds[SOUND.BING2] = this.loadSound([
		"sounds/bing.ogg"
	]);
	
	this.sounds[SOUND.SWITCH] = this.loadSound([
		"sounds/switch.ogg"
	]);
	
	this.sounds[SOUND.ZIP] = this.loadSound([
		"sounds/zip.ogg"
	]);
	
	this.sounds[SOUND.ZIP3] = this.loadSound([
		"sounds/zip3.ogg"
	]);
	
	this.sounds[SOUND.SPELL] = this.loadSound([
		"sounds/spell.ogg",
		"sounds/spell.ogg"
	]);
	
	this.sounds[SOUND.DRAGON_SPAWN] = this.loadSound([
		"sounds/dragon_spawn.ogg",
		"sounds/dragon_spawn.ogg"
	]);
	
	this.sounds[SOUND.DRAGON_DEATH] = this.loadSound([
		"sounds/dragon_death.ogg",
		"sounds/dragon_death.ogg"
	]);
	
	this.sounds[SOUND.DRAGON_YES] = this.loadSound([
		"sounds/dragon_yes_1.ogg",
		"sounds/dragon_yes_2.ogg",
		"sounds/dragon_yes_3.ogg"
	]);
	
	this.sounds[SOUND.FALL] = this.loadSound([
		"sounds/fall.ogg",
		"sounds/fall.ogg"
	]);
	
	this.sounds[SOUND.DRAGON_FIRE] = this.loadSound([
		"sounds/dragon_fire_1.ogg",
		"sounds/dragon_fire_2.ogg",
		"sounds/dragon_fire_1.ogg",
		"sounds/dragon_fire_2.ogg"
	]);
	
	this.sounds[SOUND.MINE] = this.loadSound([
		"sounds/mine1.ogg",
		"sounds/mine2.ogg",
		"sounds/mine3.ogg",
		"sounds/mine1.ogg",
		"sounds/mine2.ogg"
	]);
	
	this.sounds[SOUND.ROUNDHOUSE] = this.loadSound([
		"sounds/roundhouse.ogg",
		"sounds/roundhouse.ogg"
	]);
	
	this.sounds[SOUND.BIGHIT] = this.loadSound([
		"sounds/big-hit.ogg",
		"sounds/big-hit-2.ogg",
		"sounds/big-hit.ogg",
		"sounds/big-hit-2.ogg"
	]);
	
	this.sounds[SOUND.STRONG_HIT] = this.loadSound([
		"sounds/strong-hit.ogg",
		"sounds/strong-hit-2.ogg"
	]);
	
	this.sounds[SOUND.BEAST_READY] = this.loadSound([
		"sounds/beast-ready.ogg"
	]);
	
	this.sounds[SOUND.BEAST_YES] = this.loadSound([
		"sounds/beast-yes.ogg",
		"sounds/beast-yes-2.ogg"
	]);
	
	this.sounds[SOUND.BEAST_DIE] = this.loadSound([
		"sounds/beast-die.ogg"
	]);
	
	this.sounds[SOUND.FLAK] = this.loadSound([
		"sounds/flak1.ogg",
		"sounds/flak2.ogg",
		"sounds/flak3.ogg"
	]);
	
	this.sounds[SOUND.SHOCKWAVE] = this.loadSound([
		"sounds/shockwave.ogg",
		"sounds/shockwave.ogg"
	]);
	
	this.sounds[SOUND.FIREBALL] = this.loadSound([
		"sounds/fireball.ogg",
		"sounds/fireball.ogg"
	]);
	
	this.sounds[SOUND.SKELETON_PAIN] = this.loadSound([
		"sounds/skeleton-hit.ogg",
		"sounds/skeleton-hit.ogg"
	]);
	
	this.sounds[SOUND.SKELETON_YES] = this.loadSound([
		"sounds/skeleton1.ogg",
		"sounds/skeleton3.ogg"
	]);
	
	this.sounds[SOUND.SKELETON_SPAWN] = this.loadSound([
		"sounds/skeleton2.ogg",
		"sounds/skeleton2.ogg"
	]);
	
	this.sounds[SOUND.AURA_HEAL] = this.loadSound([
		"sounds/heal-aura.ogg",
		"sounds/heal-aura.ogg"
	]);
	
	this.sounds[SOUND.PLASMA_SHIELD] = this.loadSound([
		"sounds/plasma-shield.ogg",
		"sounds/plasma-shield2.ogg",
		"sounds/plasma-shield3.ogg"
	]);
	
	this.sounds[SOUND.BATTLE_FANFARE] = this.loadSound([
		"sounds/battle-fanfare.ogg"
	]);
	
	this.sounds[SOUND.A_WS] = this.loadSound([
		"sounds/buildings/advanced_Workshop.ogg"
	]);
	
	this.sounds[SOUND.CC] = this.loadSound([
		"sounds/buildings/cc.ogg"
	]);
	
	this.sounds[SOUND.CHURCH] = this.loadSound([
		"sounds/buildings/church.ogg"
	]);
	
	this.sounds[SOUND.DRAGONS_LAIR] = this.loadSound([
		"sounds/buildings/dragons_lair.ogg"
	]);
	
	this.sounds[SOUND.FORGE] = this.loadSound([
		"sounds/buildings/forge.ogg"
	]);
	
	this.sounds[SOUND.HOUSE] = this.loadSound([
		"sounds/buildings/house.ogg"
	]);
	
	this.sounds[SOUND.LAB] = this.loadSound([
		"sounds/buildings/lab.ogg"
	]);
	
	this.sounds[SOUND.MAGES_GUILD] = this.loadSound([
		"sounds/buildings/magesguild.ogg"
	]);
	
	this.sounds[SOUND.RAX] = this.loadSound([
		"sounds/buildings/rax.ogg"
	]);
	
	this.sounds[SOUND.WW_DEN] = this.loadSound([
		"sounds/buildings/ww_den.ogg"
	]);
	
	this.sounds[SOUND.W_DEN] = this.loadSound([
		"sounds/buildings/w_den.ogg"
	]);
	
	this.sounds[SOUND.WORKSHOP] = this.loadSound([
		"sounds/buildings/workshop.ogg"
	]);
	
	
	this.buildingClickSound = [];
};

SoundManager.prototype.loadSound = function(files)
{
	var target = [];
	
	for(var i = 0; i < files.length; i++)
		target.push(new Audio(files[i]));
	
	return target;
};

SoundManager.prototype.getVolumeModifier = function(pos)
{
	var volume = 1;
	
	var left = game.cameraX / FIELD_SIZE;
	var top = game.cameraY / FIELD_SIZE;
	var right = (game.cameraX + WIDTH) / FIELD_SIZE;
	var bottom = (game.cameraY + HEIGHT - INTERFACE_HEIGHT) / FIELD_SIZE;
	
	var distX = 0;
	if(pos.px < left || pos.px > right)
		distX = Math.min(Math.abs(pos.px - left), Math.abs(pos.px - right));
	
	var distY = 0;
	if(pos.py < top || pos.py > bottom)
		distY = Math.min(Math.abs(pos.py - top), Math.abs(pos.py - bottom));
	
	var dist = Math.sqrt(distX * distX + distY * distY);
	
	if(dist > 0)
		volume = 1 - dist / 5;
	
	// make sounds a little bit lower, when zoomed out
	volume *= Math.min(SCALE_FACTOR / 15 + 0.6, 1);
	
	return volume;
}

// pos has influence on the volume; if a pos is given, the distance from the screen to pos is checked, and the volume is lower, the higher the distance is
SoundManager.prototype.playSound = function(sound, pos, volumeModifier, isUnitClickSound)
{
	// if sound is disabled (by the user in options) return
	if(!(sound_volume > 0) || !this.sounds[sound])
		return;
	
	// check distance => volume
	var volume = pos ? this.getVolumeModifier(pos) : 1;
	
	volume = volumeModifier ? volume * volumeModifier : volume;
	
	if(volume <= 0)
		return;
	
	var s = this.sounds[sound];
	var readySounds = [];
	
	// find sound(s), which are / is ready
	for(var i = 0; i < s.length; i++)
		if(s[i].currentTime >= s[i].duration || s[i].currentTime == 0 || !s[i].currentTime)
			readySounds.push(s[i]);
	
	// all sounds still in use, return
	if(readySounds.length == 0)
		return;
	
	// random one of the ready sounds
	var soundToPlay = readySounds[Math.floor(Math.random() * readySounds.length)];
	
	// play sound
	// soundToPlay.load();
	soundToPlay.loop = false;
	soundToPlay.src = soundToPlay.src;
	// soundToPlay.currentTime = 0;
	soundToPlay.play();
	soundToPlay.volume = volume * sound_volume * globalSoundModifier;
	
	if(isUnitClickSound)
		this.buildingClickSound.push({
			sound: soundToPlay,
			maxVolume: soundToPlay.volume
		});
};
function MapEditor()
{
	game = new Game();
	
	var map = {
		"name": "unnamed",
		"x": 64,
		"y": 64,
		"units": [],
		"buildings": [],
		"tiles": [],
		"defaultTiles": ["Ground n 6", "Ground n 7", "Ground n 8", "Ground n 5", "Ground n 1", "Ground n 2", "Ground n 3", "Ground n 4"]
	};
	
	game.loadMap(map);
	
	worker.postMessage({what: "start-game", map: map, network_game: false, game_state: game_state, networkPlayerName: networkPlayerName});
	
	this.selectedItemType = null; // type of the selected unit / building / doodad (when clicked on a button in the interface)
	this.terrainModifier = 0;
	this.player = 1; // current selected player
	this.dragging = false;
	this.almostDragging = false;
	this.draggStartPos = null;
	this.draggingUnitsOriginalpositions = [];
	this.startHeight = 0;
	this.lastClickedField = null;
	this.randomTree = false;
	
	
	this.createButtons();
	
	// reset html elements
	$('#mapNameInput')[0].value = "";
	$('#mapDescriptionInput')[0].value = "";
	$("#useBlackFogCheckbox").prop('checked', false);
	$("#mapOpenCheckbox").prop('checked', true);
	$("#maxSupplyInput")[0].value = MAX_SUPPLY;
	$("#startGoldInput")[0].value = START_GOLD;
	$("#mineDistInput")[0].value = MINE_DIST;
	
	// clipboard for history, copy and paste
	this.clipboard = new MapEditorClipboard();
};


MapEditor.prototype.createButtons = function()
{
	this.trees = {
		fullList: []
		//1_1 : []
		//2_2 : []
		//3_3 : []
	};

	// ICONS (i could not use lists... 'lists' are empty, lists.buildingTypes for example are empty too..)
	this.unitsIcon = game.unitTypes[0]; // soldier
	this.buildingIcon = game.buildingTypes[4]; // house
	this.treeIcon = tileTypes[0]; // tree 1
	this.tileIcon = tileTypes[30]; // stone 4
	this.decorationIcon = tileTypes[69]; // grass 22

	// dividing tiles into blocking and non-blocking
	var blocking = [];
	var nonblocking = [];
	// building tree lists for the random trees as well

	for(var i = 0 ; i < tileTypes.length; i ++) {
		if(tileTypes[i].blocking && !tileTypes[i].isTree) // if its not a tree
			blocking.push(tileTypes[i]);
		else if(tileTypes[i].isTree)
		{
			this.trees.fullList.push(tileTypes[i]);
			
			var listName = tileTypes[i].sizeX + "_" + tileTypes[i].sizeY;
			
			if(!this.trees[listName])
				this.trees[listName] = [];
			
			this.trees[listName].push(tileTypes[i]);
			
			tileTypes[i].randomTree = true; // flag
		}
		else
			nonblocking.push(tileTypes[i]);
	}
	
	// create ui
	var types = [game.unitTypes, game.buildingTypes, this.trees.fullList, blocking, nonblocking];
	var typesDescription = ["Units",  "Buildings", "Trees", "Tiles", "Decoration"];
	var icons = [this.unitsIcon, this.buildingIcon, this.treeIcon, this.tileIcon, this.decorationIcon];
	
	$("#typesWindow").remove();
	var typesWindows = document.createElement("div");
	typesWindows.style.cssText = "position: absolute; left: 10px; top: 2px; height: 64px; right: 450px;";
	typesWindows.id = "typesWindow";
	$('#mapEditorInterface').append(typesWindows);

	for(var i = 0; i < types.length; i++)
	{
		$('#mapEditorTypeButtons' + i).remove();
		var win = document.createElement('div');
		win.id = "mapEditorTypeButtons" + i;
		win.className = "editorTypeClass";
		win.style.cssText = "position: absolute; left: 10px; top: " + (1 * 64 + 6) + "px; height: 128px; right: 500px; overflow: auto;";
		$('#mapEditorInterface').append(win);
		if(i!=0)
			$(win).hide();
		
		// creating the types buttons
		var firstElement = types[i][0];
		var typeButton = document.createElement("button");
		typeButton.id = "editorTypeButton_" +  i;
		typeButton.className = "editorTypeButton";
		typeButton.title = typesDescription[i];
		if(i!=0)
			$(typeButton).css("background-color", "#99cccc");
		else {
			$(typeButton).css("background-color", "#ccffcc");
			$(typeButton).addClass("TabSelected");
		}

		var img = icons[i].getTitleImage();
		var w = img.w;
		var h = img.h;
		
		if(w > h)
		{
			h = 60 * (h / w);
			w = 60;
		}
		else
		{
			w = 60 * (w / h);
			h = 60;
		}
		
		var w2 = img.file.width * (w / img.w);
		var h2 = img.file.height * (h / img.h);
		var x = img.x * (w2 / img.file.width);
		var y = img.y * (h2 / img.file.height);
		
		typeButton.innerHTML = "<div style='width: " + w + "px; height: " + h + "px;'><img style='position: absolute; left: " + -x + "px; top: " + -y + "px; width: " + w2 + "px; height: " + h2 + "px;' src='" + (img.file.toDataURL ? img.file.toDataURL() : img.file.src) + "' /></div>";
		$(typesWindow).append(typeButton);
		typeButton.onclick = function() {
			$(".TabSelected").css("background-color", "#99cccc");
			$(".editorTypeButton").removeClass("TabSelected");
			$(this).addClass("TabSelected");
			$(this).css("background-color", "#ccffcc");
			var id = this.id.split("_")[1];
			$(".editorTypeClass").hide();
			$("#mapEditorTypeButtons"+id).show();
			editor.selectedItemType = undefined;
			editor.randomTree = false;
			game.selectedUnits = [];
			soundManager.playSound(SOUND.CLICK);
		};
		
		for(var k = 0; k < types[i].length; k++)
			if(!types[i][k].isDefault && types[i][k].getTitleImage) // not generate buttons for default (= default ground textures), they are created randomly at map load and can not be placed manually
			{
				var img = types[i][k].getTitleImage();
				var button = document.createElement("button");
				win.appendChild(button);
				button.id = "editorTypeButton_" + i + "_" + k;
				button.className = "editorTypeButton";
				button.title = types[i][k].name + (types[i][k].description ? " - " + types[i][k].description : "");
				button.type_ = types[i][k];
				
				var w = img.w;
				var h = img.h;
				if(w > h)
				{
					h = 60 * (h / w);
					w = 60;
				}
				else
				{
					w = 60 * (w / h);
					h = 60;
				}
				
				var w2 = img.file.width * (w / img.w);
				var h2 = img.file.height * (h / img.h);
				var x = img.x * (w2 / img.file.width);
				var y = img.y * (h2 / img.file.height);
				button.innerHTML = "<div style='width: " + w + "px; height: " + h + "px;'><img style='position: absolute; left: " + -x + "px; top: " + -y + "px; width: " + w2 + "px; height: " + h2 + "px;' src='" + (img.file.toDataURL ? img.file.toDataURL() : img.file.src) + "' /></div>";
			
				button.onclick = function(){
					editor.randomTree = false;
					editor.selectedItemType = this.type_;
					game.selectedUnits = [];
					soundManager.playSound(SOUND.CLICK);
				};
			}
	}
	
	for(var treeIndex in this.trees)
		if(treeIndex != "fullList")
		{
			var tree = this.trees[treeIndex][0];
			var treeSize = tree.sizeX;
			var treeIconIndex = 0;
			var button = document.createElement("button");
			if(treeSize == 1)
				treeIconIndex = 0;
			else if(treeSize == 2)
				treeIconIndex = 5;
			else if(treeSize == 3) 
				treeIconIndex = 7;
			button.randomTree = true;
			button.title = "Places a " + treeSize + "x" + treeSize + " random tree!";
			button.className = "editorTypeButton";
			button.randomTreeSize = treeSize;
			button.treeIconIndex = treeIconIndex;
			button.type_ = tree;
			
			$('#mapEditorTypeButtons2').append(button);
			
			var img = tree.getTitleImage();
			var w = img.w;
			var h = img.h
			
			if(w > h)
			{
				h = 60 * (h / w);
				w = 60;
			}
			else
			{
				w = 60 * (w / h);
				h = 60;
			}
			var w2 = img.file.width * (w / img.w);
			var h2 = img.file.height * (h / img.h);
			var x = img.x * (w2 / img.file.width);
			var y = img.y * (h2 / img.file.height);
			button.innerHTML = "<div style='width: " + w + "px; height: " + h + "px;'><img style='position: absolute; left: " + -x + "px; top: " + -y + "px; width: " + w2 + "px; height: " + h2 + "px;' src='" + (img.file.toDataURL ? img.file.toDataURL() : img.file.src) + "' /></div><span style='position: absolute; top: 0; left: 0; font-size: 16px;'>Random " + treeSize + "x" + treeSize + " tree</span>";
			
			button.onclick = function(){
				editor.randomTree = true;
				editor.selectedItemType = this.type_;
				game.selectedUnits = [];
				soundManager.playSound(SOUND.CLICK);
			};
		}
};

// remove a unity/entity/tile/building (MapObject) from all context
// accepts a single entity or an array
MapEditor.prototype.removeObjects = function(mapObjects, saveHistory) {
	
	var units = [];
	if(mapObjects.constructor === Array) {

		for(var i = 0; i < mapObjects.length; i++) {
			var u = mapObjects[i];

			if(saveHistory)
				editor.clipboard.history.addObject(u, "DeleteMapObject");

			if(u.id)
				units.push({hasId: true, id: u.id});

			else
				units.push({hasId: false, x: u.pos.px, y: u.pos.py, type: u.type.name});

			if(u.type.isBuilding)
			{
				game.buildings.erease(u);
				game.buildings2.erease(u);
			}

			else if(u.type.isUnit)
				game.units.erease(u);

			else if(u.type.isGround)
				game.groundTiles2.erease(u);

			else if(u.type.blocking)
				game.blockingTiles.erease(u);

				// unblock fields in game block array (if building or tile and non-blocking)
				if((u.type.isBuilding || u.type.isTile) && !u.type.ignoreGrid)
					u.switchBlockingTotal(false);
			}
			worker.postMessage({what: "deleteUnitEditor", units: units});
		} else {
			var u = mapObjects;
			if(u.id)
				units.push({hasId: true, id: u.id});	
			else
				units.push({hasId: false, x: u.pos.px, y: u.pos.py, type: u.type.name});
			
			if(u.type.isBuilding)
			{
				game.buildings.erease(u);
				game.buildings2.erease(u);
			}
			else if(u.type.isUnit)
				game.units.erease(u);
			
			else if(u.type.isGround)
				game.groundTiles2.erease(u);
			
			else if(u.type.blocking)
				game.blockingTiles.erease(u);
			
			// unblock fields in game block array (if building or tile and non-blocking)
			if((u.type.isBuilding || u.type.isTile) && !u.type.ignoreGrid)
				u.switchBlockingTotal(false);
			worker.postMessage({what: "deleteUnitEditor", units: units});
	}
};

// gets called every frame, newClick = true, when onmousedown
MapEditor.prototype.click = function(x, y, newClick, code)
{
	if(y < HEIGHT - 212) // if click in map
	{
		var field = game.getFieldFromPos((x + game.cameraX) / FIELD_SIZE, (y + game.cameraY) / FIELD_SIZE, this.terrainModifier == 0 || this.selectedItemType);
		
		if(code == 1) // if left click
		{

			// get field
			var blocked = false;
			
			if(this.clipboard.copyclipboard) {
				this.clipboard.copyclipboard = null;
				return; // wont need to waste 
			}

			var tree = undefined;
			if(this.randomTree && this.selectedItemType) {
				var listName = this.selectedItemType.sizeX+"_"+this.selectedItemType.sizeY;
				tree = this.trees[listName][Math.floor(Math.random()*this.trees[listName].length)];
			}
			
			var msg = {
				what: "editorClick",
				x: field.px,
				y: field.py,
				type: this.selectedItemType ? this.selectedItemType.name : null,
				playerIndex: this.player,
				heightMod: this.terrainModifier,
				startHeight: this.startHeight,
				newClick: newClick
			};
			
			if(tree!=undefined)
				msg.type = tree.name;
			worker.postMessage(msg);

			// if we clicked on a unit, that is selected, enable dragging
			if(newClick)
			{
				var clickedUnit = game.getUnitAtPosition((x + game.cameraX) / FIELD_SIZE, (y + game.cameraY) / FIELD_SIZE);
				this.almostDragging = clickedUnit && clickedUnit.type.isUnit && game.selectedUnits.contains(clickedUnit);
				this.dragging = false;
				this.draggStartPos = new Field(x, y, true);
				
				// save all original positions
				this.draggingUnitsOriginalpositions = [];
				for(var i = 0; i < game.selectedUnits.length; i++)
					this.draggingUnitsOriginalpositions.push(game.selectedUnits[i].pos.getCopy());
			}
			
			if(this.almostDragging && (x != this.draggStartPos.px || y != this.draggStartPos.py))
			{
				this.almostDragging = false;
				this.dragging = true;
			}
			
			if(this.dragging)
			{
				var offsetp = new Field((x - this.draggStartPos.x) / FIELD_SIZE, (y - this.draggStartPos.y) / FIELD_SIZE, true);
				var offset = new Field(Math.floor((x - this.draggStartPos.x) / FIELD_SIZE), Math.floor((y - this.draggStartPos.y) / FIELD_SIZE));
				
				for(var i = 0; i < game.selectedUnits.length; i++)
				{
					var unit = game.selectedUnits[i];
					if(unit.type.isUnit)
					{
						var field = unit.type.getNextFreePositionFrom(this.draggingUnitsOriginalpositions[i].add(offsetp));
						worker.postMessage({what: "changeUnitPos", x: field.px, y: field.py, id: unit.id});
					}
				}
			}
		}
		
		else if(code == 3) // right click (set waypoint, if possible)
		{
			for(var i = 0; i < game.selectedUnits.length; i++)
				if(game.selectedUnits[i].type.canHaveWaypoint)
				{
					var u = game.selectedUnits[i];
					
					if(keyManager.keys[KEY.SHIFT])
					{
						if(u.waypoint.length < 19)
							u.waypoint.push(field);
					}
					else
						u.waypoint = [field];
					
					var arr = [];
					for(var k = 0; k < u.waypoint.length; k++)
						arr.push(u.waypoint.px, u.waypoint.py);
					
					worker.postMessage({what: "setWP", id: game.selectedUnits[i].id, waypoint: arr});
				}
			}
		}
	};

MapEditor.prototype.keyPressed = function(key)
{
	// if delete key or e key, remove the selected objects
	if(key == KEY.DELETE || key == KEY.E)
		this.removeObjects(game.selectedUnits, true);
	
	/*
	if(key == KEY.U)
		this.clipboard.history.undo();
	
	
	// for debugging
	//else if(key==KEY.Q)
	//	this.clipboard.history.debug();

	else if(key==KEY.G) {
		this.clipboard.history.debug();
	}
	*/
	
	if(key == KEY.A)
		killRamp();
	
	else if(key == KEY.S)
		addRamp();
	
	else if(key == KEY.D)
		higherTerrain();
	
	else if(key == KEY.F)
		lowerTerrain();
	
	else if(key == KEY.Q)
		testMap();
};

MapEditor.prototype.draw = function()
{
	game.draw();
	
	// if im with some copy on my clipboard
	// disabled for now, this will aways be null for now

	if(this.clipboard.copyclipboard) {
		/*
		var selected = this.clipboard.copyclipboard.units;
		var relativeUnit = this.clipboard.copyclipboard.relativeUnit; // this will be used to coordinates to other guys
		var references = this.clipboard.copyclipboard.reference;

		var ct = selected.length; // recursive while loop, way faster then for loops for JS. good for rendering
		while(ct--) {

			var thisUnit = selected[ct].type;
			var field = thisUnit.getFieldFromMousePos();
			var hm = game.getHMValue4(field.x, field.y);

			var difX = references[ct].x;
			var difY = references[ct].y;
			// if its a building or a doodle
			if(thisUnit.isBuilding || thisUnit.isTile)
			{
				c.globalAlpha = 0.5;
				thisUnit.draw(thisUnit.ignoreGrid ? keyManager.x + game.cameraX : field.x, thisUnit.ignoreGrid ? keyManager.y + game.cameraY : field.y - hm * CLIFF_HEIGHT);
				c.globalAlpha = 1;
			// its a unit
			
			
		} 
		else 
		{
			c.globalAlpha = 0.5;
			thisUnit.draw(keyManager.x + game.cameraX + difX, keyManager.y + game.cameraY + difY);
			c.globalAlpha = 1;
		}
		
		vtester called this
		i will remove when implemented
		
	}
	*/
	}
	// draw current Item @ mouse pos, if we have selected a type
	else if(this.selectedItemType && keyManager.y < HEIGHT - 212)
	{
		// if its a building or doodad
		if(this.selectedItemType.isBuilding || this.selectedItemType.isTile)
		{
			var field = this.selectedItemType.getFieldFromMousePos();
			var hm = game.getHMValue4(field.x, field.y);
			
			// draw
			c.globalAlpha = 0.5;
			this.selectedItemType.draw(this.selectedItemType.ignoreGrid ? keyManager.x + game.cameraX : field.x, this.selectedItemType.ignoreGrid ? keyManager.y + game.cameraY : field.y - hm * CLIFF_HEIGHT);
			c.globalAlpha = 1;
			
			// draw red box with alpha over the image when blocked, otherwise white alpha, for every grid field the building covers
			if(!this.selectedItemType.ignoreGrid)
				for(x = field.x; x < field.x + this.selectedItemType.sizeX; x++)
					for(y = field.y; y < field.y + this.selectedItemType.sizeY; y++)
					{
						var f = new Field(x, y);
						var distanceAllowed = true;
						var nextGoldmine = game.getNextBuildingOfType(f, null, false, "startGold");
						var nextCC = game.getNextBuildingOfType(f, null, false, "takesGold");
						
						if(this.selectedItemType.takesGold && nextGoldmine && nextGoldmine.pos.distanceTo2(f) < game.globalVars.mineDist)
							distanceAllowed = false;
						
						if(this.selectedItemType.startGold && nextCC && nextCC.pos.distanceTo2(f) < game.globalVars.mineDist)
							distanceAllowed = false;
						
						c.fillStyle = (game.fieldIsBlockedForBuilding(f.x, f.y) || !distanceAllowed) ? "rgba(200, 0, 0, 0.25)" : "rgba(" + game.theme.line_red + ", " + game.theme.line_green + ", " + game.theme.line_blue + ", 0.3)";
						c.fillRect((f.x - 1) * FIELD_SIZE - game.cameraX, (f.y - 1 - hm * CLIFF_HEIGHT) * FIELD_SIZE - game.cameraY, FIELD_SIZE, FIELD_SIZE);
					}

				}

		// if its a unit
		else
		{
			c.globalAlpha = 0.5;
			this.selectedItemType.draw(keyManager.x + game.cameraX, keyManager.y + game.cameraY);
			c.globalAlpha = 1;
		}
	}
	// terrain editor transparent tile to show where its gonna be built
	else if(this.terrainModifier != 0)
	{
		var f = "Tree 1".toUnitType().getFieldFromMousePos();
		
		c.fillStyle = "rgba(" + game.theme.line_red + ", " + game.theme.line_green + ", " + game.theme.line_blue + ", 0.3)";
		c.fillRect((f.x - 1) * FIELD_SIZE - game.cameraX, (f.y - 1 - game.getHMValue4(f.x, f.y) * CLIFF_HEIGHT) * FIELD_SIZE - game.cameraY, FIELD_SIZE, FIELD_SIZE);
	}
	
	// refresh mouse cursor pos display
	var field = game.getFieldFromPos();
	$('#cursorPosDiv').html("X: " + (Math.round(field.px * 100) / 100) + "<br />Y: " + (Math.round((field.py - 0.2) * 100) / 100));
};
function MapEditorClipboard()
{
	this.history = new History();
	this.copyclipboard = null;
	this.date = new Date();
}

// controls history for mapeditor
function History() {
	this.actions = [];
}

// places a Tile object (code/Tile.js) on a history to be removed on control.z later
History.prototype.addObject = function(tileObject, actionType) {

	//// Disabled UNDO for height , as its not 100 %
	//if(actionType=="ChangeHeight")
		//return;
	if(actionType==null || actionType == undefined)
		actionType = "PlaceMapObject";
	var historyObject = {
		obj:tileObject, 
		type:actionType,
		time: editor.clipboard.date.getTime()
	};
	this.actions.push(historyObject);
	if(this.actions.length > 100) { // max history saved
		this.actions.shift();
	}
}

// disabled, button is commented in UI
// its not fully working yet
MapEditorClipboard.prototype.copy = function() {
	if(game.selectedUnits==null || game.selectedUnits==undefined || game.selectedUnits.length==0)
		return;
	// calculating X Y differences for reference
	var differences = [];
	for(var x = 0 ; x < game.selectedUnits.length; x++) {
		var unit = game.selectedUnits[x];
		differences.push({
			x: unit.pos.px - game.selectedUnits[0].pos.px,
			y: unit.pos.py - game.selectedUnits[0].pos.py
		});
	}
	var copy = {
		multiSelect: true,
		units: game.selectedUnits,
		relativeUnit: game.selectedUnits[0],
		reference: differences
	};
	this.copyclipboard = copy;
}

History.prototype.debug = function() {
	    console.log("------------");
		for(var x = 0; x < this.actions.length ; x++) {
				var action = this.actions[x];
				console.log(action);
		}
}

History.prototype.undo = function() {
	if(this.actions.length > 0) {
		var action = this.actions[this.actions.length - 1];
		var u = action.obj;
		if(action.type==undefined || action.type=="PlaceMapObject") {
			editor.removeObjects(u);
			// undoing a delete action
		} else if(action.type=="DeleteMapObject") {
			soundManager.playSound(SOUND.PLACE);
			var field = u.pos;
			var type = u.type;
			var owner = u.owner;
			var newObj = null;
			if(u.type.isUnit) {	
				newObj = new Unit({x: field.px, y: field.py, type: type, owner:owner, noHistory:true});
			} else if(u.type.isBuilding) {
				newObj = new Building({x: field.x, y: field.y, type: type, owner: owner, noHistory:true});
			} else if(u.type.isGround || u.type.blocking) {
				newObj = new Tile({x: field.x, y: field.y, type: type, dontRefreshNBs: false, noHistory:true});
				newObj.pos.px = u.pos.px;
				newObj.pos.py = u.pos.py;
				if(u.type.isGround) {
					var img = u.type.getTitleImage();
					game.groundTilesCanvas.getContext("2d").drawImage(img.file, img.x, img.y, img.w, img.h, Math.floor(u.drawPos.px * 16 - img.width / 2), Math.floor((u.drawPos.py + 2) * 16 - img.height / 2), img.w, img.h);
				} else if(u.type.blocking) {
					game.refreshBlockingTilesCanvas(field.y);
					game.sortTiles();
				}
				
			}	

			// searching if this placement is in history
			// so the new created object keep tracks of its older action
			// with its new instance, so the undo will work as if the instance was the same
			for(var x = 0; x < this.actions.length ; x++) {
				var action = this.actions[x];
				if(action.type=="PlaceMapObject" || action.type==undefined) {
					if(action.obj == u) {
						this.actions[x] = {
							obj:newObj, type:"PlaceMapObject"
						};
					}
					
				}
			}
		} else if(action.type=="ChangeHeight") {
			var change = u;
			game.setHMValue(change.x, change.y, change.oldHeight, true);
			worker.postMessage("setHMValue$" + change.x + "$" + change.y + "$" + change.oldHeight);
			worker.postMessage("cliffSBeenPlaced2$" + change.x + "$" + change.y + "$" + change.oldHeight);

			// a tricky part here
			// we are going to look for other HM changes in the past 100ms and undo them too !
			// because each change height, gets called about 5 times 
			var ct = this.actions.length;
			ct -= 1; // removing this current action
			var indexesToRemove = [];
			while(ct--) {
				var older = this.actions[ct];
				if(older.type=="ChangeHeight" && (editor.clipboard.date.getTime() - older.time)<100) {
					indexesToRemove.push(ct);
					game.setHMValue(change.x, change.y, change.oldHeight, true);
					worker.postMessage("setHMValue$" + change.x + "$" + change.y + "$" + change.oldHeight);
					worker.postMessage("cliffSBeenPlaced2$" + change.x + "$" + change.y + "$" + change.oldHeight);
				}
			}
			// removing from history the undone HM changes
			for(var i = 0 ; i < indexesToRemove.length ; i++) {

				this.actions.splice(indexesToRemove[i], 1);
			}
			game.makeCliffs(change.x - 2, change.y -2 , change.x + 2, change.y + 2);
			console.log(game.getHMValue(change.x, change.y));
			//worker.postMessage("setHMValue$" + change.x+ "$" + change.y+ "$" + change.oldHeight);
			//worker.postMessage("cliffSBeenPlaced2$" + change.x + "$" + change.y + "$" + change.oldHeight);
			//game.sortTiles();
		}
		var index = this.actions.indexOf(action);
		this.actions.splice(index, 1);
	}
	
}
// playes music
function MusicManager(musicVolume, soundVolume)
{
	this.ingameMusic = [
		new Audio("music/ingame1.ogg"),
		new Audio("music/ingame3.ogg"),
		new Audio("music/ingame5.ogg"),
		new Audio("music/ingame6.ogg"),
		new Audio("music/opening.ogg"),
		new Audio("music/BrightGameTheme.ogg"),
		new Audio("music/TheOldGods.ogg"),
		new Audio("music/Vengeance.ogg")
	];
	
	this.defeatMusic = [
		new Audio("music/defeat.ogg")
	];
	
	this.victoryMusic = [
		new Audio("music/victory.ogg")
	];
	
	this.menuMusic = [
		new Audio("music/menu.ogg")
	];
	
	this.ambient = [
		new Audio("sounds/ambient/ambient1.ogg")
	];
	
	this.rain = [
		new Audio("sounds/ambient/rain.ogg"),
		new Audio("sounds/ambient/rain.ogg")
	];
	
	this.currentMusic = null;
	this.lastGameState = null;
	
	this.setMusicVolume(musicVolume);
	this.setSoundVolume(soundVolume);
};

// is called once after object creation. Cannot be done in constructor itself, becauses it needs methods of the object (is that even true ?)
MusicManager.prototype.bindEvents = function()
{
	_.each([this.ingameMusic, this.defeatMusic, this.menuMusic], function(musics){
		
		for(var i = 0; i < musics.length; i++)
		{
			musics[i].addEventListener("ended", function(){ setTimeout(function(){ musicManager.playMusic(); }, 3000); });
			
			musics[i].addEventListener("canplaythrough", function(){
				if(!musicManager.currentMusic)
					musicManager.playMusic();
			});
			
			musics[i].volume = 0.5;
			musics[i].loop = false;
		}
		
	});
	
	this.ambient[0].loop = true;
};

MusicManager.prototype.setMusicVolume = function(volume)
{
	_.each([this.ingameMusic, this.defeatMusic, this.menuMusic], function(musics){
		for(var i = 0; i < musics.length; i++)
			musics[i].volume = 0.7 * music_volume;
	});
};

MusicManager.prototype.setSoundVolume = function(volume)
{
	this.ambient[0].volume = 0.4 * sound_volume;
};

// start playing a song; checks which song has to be played and plays it; gets called on game start or when music is turned on
MusicManager.prototype.playMusic = function()
{
	if(!(music_volume > 0))
		return;
	
	var music = this.getMusicFromGameState();
	
	if(!music)
		return;
	
	var rand = Math.floor(Math.random() * 1000) % music.length;
	for(var i = 0; i < music.length; i++)
	{
		var musicPiece = music[(rand + i) % music.length];
		if(musicPiece.readyState == 4)
		{
			musicPiece.currentTime = 0;
			musicPiece.play();
			
			i = 999;
			this.currentMusic = music;
		}
	}
};

// stop playing music (called when music is turned off)
MusicManager.prototype.stopMusic = function()
{
	_.each([this.ingameMusic, this.defeatMusic, this.victoryMusic, this.menuMusic], function(musics){
		for(var i = 0; i < musics.length; i++)
			musics[i].pause();
	});
	
	this.currentMusic = null;
};

// return the array which holds the music that is to be played, depending on the current game state
MusicManager.prototype.getMusicFromGameState = function()
{
	if(game_state == GAME.SKIRMISH || game_state == GAME.LOBBY || game_state == GAME.LOGIN || game_state == GAME.REGISTER || game_state == GAME.RECOVERY)
		return noMainMenuMusic ? null : this.menuMusic;
	
	if(game_state == GAME.EDITOR)
		return null;
	
	if(game_state == GAME.PLAYING && game.gameHasEnded && game.playingPlayerWon)
		return this.victoryMusic;
	
	if(game_state == GAME.PLAYING && game.gameHasEnded && !game.playingPlayerWon)
		return this.defeatMusic;
	
	return this.ingameMusic;
};

// is called every frame, doesnt really "draw" anythiing, but checks if music has to be switched
MusicManager.prototype.draw = function()
{
	// get state of game (regarding the music)
	var newMusic = this.getMusicFromGameState();
	
	var gameStateHasChangedAndItsIngameMusic = game_state != this.lastGameState && newMusic == this.ingameMusic;
	
	// ambient sound has to start (we entered a game)
	if(game_state == GAME.PLAYING && this.lastGameState != GAME.PLAYING && sound_volume > 0)
		this.ambient[0].play();
	
	// ambient sound has to stop (we left a game)
	if(game_state != GAME.PLAYING && this.lastGameState == GAME.PLAYING)
	{
		this.ambient[0].pause();
		this.rain[0].pause();
		this.rain[0].src = this.rain[0].src;
		this.rain[1].pause();
		this.rain[1].src = this.rain[1].src;
	}
	
	// save this game state for next time
	this.lastGameState = game_state;
	
	if(!(music_volume > 0))
		return;
	
	// if game state has changed, music has to change
	if(newMusic != this.currentMusic || gameStateHasChangedAndItsIngameMusic)
	{
		this.stopMusic();
		
		if(newMusic)
			this.playMusic();
	}
};
function Network()
{
	this.connected = false;
	
	this.pings = []; // contains the last ~10 ping values, when a new one comes, the oldest one gets killed
	
	this.game = {id: 0, name: ""}; // the game, were currently in
	
	this.players = {};
	
	this.EXTRA_DELAY = 2;
	
	this.authedAndLogged = false; // this becomes true, when logged in as a registered user (and not as a guest)
	alphabetize_Players = [];

	// connect to server and define all the callbacks
	try
	{
		this.socket = new WebSocket(SERVER_ADRESS);
	}
	catch(e)
	{
		alert("You browser seems to not support Websockets. Websockets, however, are required to run this game.");
		throw new Error("No Websockets supported.");
	}
	
	var scope = this;
	
	this.socket.onmessage = function(data) {scope.onmessage(data);};
	this.socket.onopen = function() {scope.onopen();};
	this.socket.onclose = function() {scope.onclose();};
};

Network.prototype.onopen = function()
{
	this.connected = true;
	
	if($('#loginWindowState')[0])
		sendActivationCode();
	
	if(getCookieValue)
	{
		var expVal = getCookieValue(document.cookie, "exp");
		var expVal2 = localStorage.exp;
		
		if(expVal || expVal2)
			this.send("exp-update<<$" + expVal + "<<$" + expVal2);
	}
	
	instantLogin();
};

Network.prototype.onclose = function()
{
	this.connected = false;
};

Network.prototype.onmessage = function(data, flags)
{
	var msg = data.data;
	var splitMsg = msg.split("<<$");
	console.log(`msg: ${splitMsg[0]} state ${game_state}`);
	// server msg
	if(splitMsg[0] == "server-info")
		displayInfoMsg(splitMsg[1]);
	
	else if(game_state == GAME.LOGIN)
	{
		if(splitMsg[0] == "really-log-in")
		{
			const loginInput = $('#loginWindowUsername')[0];
			if (loginInput)
			{
				var username = loginInput.value;
				var killSessions = (username == getUserNameFromCookie());
				$('#loginWindowState').html(`<br />There seem to be existing sessions for this account. Continuing will log out any existing sessions. <button onclick='formLogin(\"${killSessions ? "yes" : "no"}\");'>login</button>`);	
			}
			else
			{
				console.log(`Autologin failed, logging in as guest`);
				network.send("logout<<$pls");
				instantLogin(true);
			}
		}
			
		else if(splitMsg[0] == "logged-in")
		{
			console.log(`logged in`)
			LOGIN_STATE = "PLAYER";
			saveLogin();
			try
			{
				$('#loginWindowPassword')[0].value = "";
			}
			catch (error) {}
			
			networkPlayerName = splitMsg[1];
			const clanName = splitMsg[2];
			game_state = GAME.LOBBY;
			tryShowChangeLog();
			writeCookie();
			this.authedAndLogged = true;
			iAmMod = splitMsg[3] == "1";
			iAmAdmin = splitMsg[4] == "1";
			iAmMod2 = splitMsg[11] == "1";
			league = parseInt(splitMsg[5]);
			ignores = splitMsg[6].length > 0 ? splitMsg[6].toLowerCase().split(",") : [];
			exp = parseInt(splitMsg[7]);
			myAccId = parseInt(splitMsg[13]);
			updatePlayerClanInfo(networkPlayerName, clanName);

			$('#playerGoldWrap')[0].title = goldDescription;
			gold = splitMsg[9];
			$('#playerGoldWrap').html("<span id='playerGold'>" + currencyFormatter(gold) + "</span> <img src='imgs/gold2.png' class='pixelated' style='width: 32px;' /> <button onclick='showBuyGoldWindow(myAccId);'>Get more!</button>");
			
			rfSBTN();
			
			if(league >= 0)
				$('#mainLeagueLink').html(getLeagueLink(league, false, 4));
			
			else
			{
				$('#mainLeagueLink').html("<div id='noRankingYetDiv'>You have no ladder rank yet. Play <span id='rankedGamesLeft'>" + Math.max(5 - splitMsg[7], 1) + "</span> ranked matches to get placed into a division</div>");
				$('#mainLeagueLink').prop('title', '');
			}
			// $('#mainLeagueLink')[0].style.visibility = 'visible';
    		$('#playerGoldWrap')[0].style.visibility = 'visible';
			
			if(splitMsg[9] == "0")
			{
				game_state = GAME.ACCEPT_AGB;
				showAGB2();
			}
			
			// if has premium acc
			if(parseInt(splitMsg[11]) > (Date.now() / 1000))
			{
				$('#div-gpt-ad-1571242603068-0').remove();
				$('#pleaseNoAdblockDiv').remove();
				premium_until = parseInt(splitMsg[11]);
			}
			try
			{
				$('#accGuestMsgDiv')[0].style.visibility = 'hidden';
			}
			catch (error) {}
			addLoginButton('guestLoginPromptButton', 'Log Out', true);
			$('#accInfoWindow')[0].innerHTML += "<div id='mainExpDiv' title='This is your current experience and the experience you need to reach the next level. You get experience from games you play. If you level up, new features will get unlocked.'></div>";
			// $('#accGuestMsgDiv')
			addLoginButton('guestLoginPromptButton', 'Log Out');
			refreshMainExpDiv();
			showPlayerInfo(true);
		}
		
		else if(splitMsg[0] == "logged-in-guest")
		{
			console.log(`logged in guest`)
			LOGIN_STATE = "GUEST";
			networkPlayerName = splitMsg[1];
			game_state = GAME.LOBBY;
			tryShowChangeLog();
			writeCookie();
			this.authedAndLogged = false;
			// $('#playerNameDisplay').html("Welcome " + networkPlayerName);
			$('#playerNameDisplay').html(networkPlayerName);
			$('#friendsSubdiv').html("<div id='friends_guest_div'>If you register an account, you can add other players as friends</div>");
			
			// player info window guest message
			addLoginButton('guestLoginPromptButton', 'Log In');
			$('#accInfoWindow').append("<div id='accGuestMsgDiv'>Log in to get Exp and gold rewards as well as access to friends and ranked play!</div>");

			showPlayerInfo(false);
		}
		
		else if(splitMsg[0] == "register-state" && splitMsg[1])
		{
			console.log(`register-state: ${splitMsg[1]}`);

			// If we got a register state from form login
			const loginInput = $('#loginWindowUsername')[0];
			if (loginInput)
			{
				$('#loginWindowState')[0].innerHTML = splitMsg[1];
			}
			// If we get a register state from auto-login
			else
			{
				console.log(`Autologin failed, logging in as guest`);
				network.send("logout<<$pls");
				instantLogin(true);
			}
		}
		
		if((splitMsg[0] == "logged-in" || splitMsg[0] == "logged-in-guest") && !dontShowFaq)
			$('#faqContainer')[0].innerHTML = "<span id='faqLink'>&nbsp;New here? Read the <a class='underline' onclick='fadeIn($(\"#faqWindow\")); soundManager.playSound(SOUND.CLICK);'>F.A.Q.</a> <button onclick='killFaqMsg0();' id='killFaqMsgButton'>x</button></span>";
	}
	
	else if(game_state == GAME.REGISTER)
	{
		if(splitMsg[0] == "register-state" && splitMsg[1])
			$('#registerWindowState').html(splitMsg[1]);
	}
	
	else if(game_state == GAME.RECOVERY)
	{
		if(splitMsg[0] == "register-state" && splitMsg[1])
			$('#recoveryWindowState').html(splitMsg[1]);
	}
	
	else if(splitMsg[0] == "agb-accept-ok")
	{
		game_state = GAME.LOBBY;
		$('#agbAcceptDiv')[0].style.display = "none";
	}
	
	else if(splitMsg[0] == "add-ignore")
	{
		ignores.push(splitMsg[1].toLowerCase());
		
		if(game_state == GAME.PLAYING)
			interface_.chatMsg("Server" + ": " + splitMsg[1] + " will be ignored");
		else
			addChatMsg("Server", splitMsg[1] + " will be ignored");
	}
	
	else if(splitMsg[0] == "no-ignore")
	{
		if(game_state == GAME.PLAYING)
			interface_.chatMsg("Server" + ": " + splitMsg[1] + " does not exist");
		else
			addChatMsg("Server", splitMsg[1] + " does not exist");
	}
	
	else if(splitMsg[0] == "already-ignore")
	{
		if(game_state == GAME.PLAYING)
			interface_.chatMsg("Server" + ": " + splitMsg[1] + " is already being ignored");
		else
			addChatMsg("Server", splitMsg[1] + " is already being ignored");
	}
	
	else if(splitMsg[0] == "unignore")
	{
		if(game_state == GAME.PLAYING)
			interface_.chatMsg("Server" + ": " + splitMsg[1] + (ignores.erease(splitMsg[1]) ? " will no longer be ignored" : " not found on your ignore list (type /ignorelist to see the whole list)"));
		else
			addChatMsg("Server", splitMsg[1] + (ignores.erease(splitMsg[1]) ? " will no longer be ignored" : " not found on your ignore list"));
	}
	
	else if(splitMsg[0] == "clan-update")
	{
		setClan(splitMsg[1], splitMsg[2], splitMsg[3], splitMsg[4], splitMsg[5], splitMsg[6]);
		updatePlayerClanInfo(networkPlayerName, splitMsg[1]);
	}
	
	else if(splitMsg[0] == "clan-wall")
	{
		setClanWall(splitMsg);
	}
	
	else if(splitMsg[0] == "clan-update-noclan")
	{
		setNoClan(splitMsg[1]);
		updatePlayerClanInfo(networkPlayerName, splitMsg[1]);
	}
	
	else if(splitMsg[0] == "setExp_")
	{
		document.cookie = "exp=" + splitMsg[1] + "; expires=" + getGMTDateString4Days(90);
		localStorage.exp = splitMsg[1];
	}
	
	else if(splitMsg[0] == "unlock-emotes")
	{
		unlockEmote(splitMsg[1], splitMsg[2]);
	}
	
	else if(splitMsg[0] == "achivement-unlocked")
	{
		unlockAchivement(splitMsg[1]);
	}
	
	else if(splitMsg[0] == "level-up")
	{
		levelUp(splitMsg);
	}
	
	else if(splitMsg[0] == "gained-xp")
	{
		exp += parseInt(splitMsg[1]);
		refreshMainExpDiv();
		
		var lvl = getLvlFromXp(exp);
		var xp1 = getXPRequiredForLvl(lvl);
		var xp2 = getXPRequiredForLvl(parseInt(lvl) + 1);
		
		var str = "<div id='xpDiv' class='greenfont' title='You gain experience from multiplayer games. Experience will make you level up and unlock new features'>+ " + splitMsg[1] + " EXP</div>";
		str += "<div class='xpBar'><div style='width: " + (((exp - xp1) / (xp2 - xp1)) * 200) + "px; height: 30px;'></div>";
		str += "<p style='font-size: 24px;'>" + exp + " / " + xp2 + "</p></div><p style='font-size: 14px; position: absolute; left: 300px; bottom: 2px; width: 200px; text-align: center;'>";
		str += xp2 + " exp required for level " + (lvl + 1) + "</p>";
		str += "<div class='LevelText'>Level <span class='greenfont'>" + lvl + "</span></div>";
		
		$('#statisticsTextArea')[0].innerHTML += str;
		xpNfo = str;
	}
	
	else if(splitMsg[0] == "league")
	{
		var str = "<div style='margin: 0 auto; text-align: center;'>" + getLeagueLink(splitMsg[1], false, 4, false) + "</div><br /><table style='margin: 0 auto;'>";
		str += "<tr><td class='tabletop'>Rank</td><td class='tabletop'>Player</td><td class='tabletop'>Points</td><td class='tabletop'>Record</td></tr>";
		
		var players_ = (splitMsg[2] && splitMsg[2].length > 0) ? splitMsg[2].split(" ") : [];
		
		var k = 0;
		for(var i = 0; i < players_.length - 1; i += 4)
		{
			k++;
			var class_ = players_[i] == networkPlayerName ? " class='highlighted' " : "";
			str += "<tr><td " + class_ + ">" + k + "</td><td " + class_ + ">" + getPlayerLink(players_[i]) + "</td><td " + class_ + ">" + players_[i + 1] + "</td><td " + class_ + "><font class='greenfont'>" + players_[i + 2] + "</font> / <font class='redfont'>" + players_[i + 3] + "</font></td></tr>";
		}
		
		str += "</table><button id='showAllLeaguesButton' onclick='showAllDivisions(); soundManager.playSound(SOUND.CLICK);'>All divisions</button>";
		
		uimanager.playerInfoWindow.setTitle("<font style='color: rgb(255, 248, 57);'>" + leagueNames[splitMsg[1]] + "</font>");
		
		$('#addScrollableSubDivTextArea').html(str);
		$('#riderDiv').html("");
		fadeIn($('#playerInfoWindow'));
	}
	
	else if(splitMsg[0] == "query")
	{
		var found = false;
		
		if(ignores.contains(splitMsg[2].toLowerCase()) && splitMsg[2] == splitMsg[3])
		{
			if(splitMsg[4] == 0)
				network.send("query-ignore<<$" + splitMsg[2]);
			return;
		}
		
		var chatMsg_ = getQueryMsg(splitMsg);
		
		if(chatMsg_ && chatMsg_.length > 0)
		{
			// look if a query for this player already exists; if yes, add the msg to this query
			for(var i = 0; i < uimanager.queries.length; i++)
				if(uimanager.queries[i].name == splitMsg[2])
				{
					if(!(open_queries == OPEN_QUERIES.NEVER || (open_queries == OPEN_QUERIES.NOT_INGAME && game_state == GAME.PLAYING)))
					{
						// if it wasnt active, play message sound
						if(uimanager.queries[i].domElement.style.display == "none")
							soundManager.playSound(SOUND.BING, false, 0.8);
						else
							soundManager.playSound(SOUND.ZIP3, false, 1);
						
						uimanager.queries[i].activate();
					}
					
					uimanager.queries[i].addMsg(chatMsg_);
					found = true;
				}
			
			// if a query for this player doesnt exist yet, create it and add the msg as the first msg
			if(!found)
			{
				var q = new Query(splitMsg[2]);
				q.addMsg(chatMsg_);
				uimanager.queries.push(q);
				soundManager.playSound(SOUND.BING, false, 0.8);
			}
		}
	}
	
	else if(splitMsg[0] == "maps-list")
	{
		// clear window
		$('#selectMapArea').html("");
		
		var s = "";
		
		var page = parseInt(splitMsg[1]) + 1;
		var maxPages = parseInt(splitMsg[2]);
		
		if(maxPages > 1)
		{
			var firstPage = page - (16 - Math.min(maxPages - page, 8));
			var lastPage = page + (16 - Math.min(page, 8));
			
			if(firstPage > 1)
				s += "<button onclick='requestCustomMapsPage(0);'>1</button> " + (firstPage > 2 ? "... " : " ");
			
			for(var i = Math.max(firstPage, 1); i <= Math.min(lastPage, maxPages); i++)
			{
				if(i != page)
					s += "<button onclick='requestCustomMapsPage(" + (i - 1) + ");'>" + i + "</button> ";
				
				else
					s += "<span>" + i + "</span> ";
			}
			
			if(lastPage < maxPages)
				s += (lastPage - 1 < maxPages ? "..." : "") + " <button onclick='requestCustomMapsPage(" + (maxPages - 1) + ");'>" + maxPages + "</button> ";
		}
		
		// set pages
		$('#selectMapPages').html(s);
		
		// display maps
		for(var i = 3; i < splitMsg.length; i += 6)
		{
			var b = document.createElement("button");
			b.innerHTML = splitMsg[i] + " [" + splitMsg[i + 3] + "]<br /><img class='mapPreviewImg2' src='" + splitMsg[i + 2] + "' />" + (splitMsg[i + 4] == "Custom mods" ? "<div class='modLabel'>[mod]</div>" : "");
			b.className = splitMsg[i + 4] == "Custom mods" ? "mapButtonMod" : "mapButton";
			b.title = splitMsg[i + 1].substring(0, 300) + (splitMsg[i + 1].length > 300 ? "... " : "") + (splitMsg[i + 4] == "Custom mods" ? "\n\n[This map contains modding elements. It can contain custom or modified units, buildings or abilities and diverse from the normal game]" : "");
			
			if(splitMsg[i + 5] != 0)
				b.title += "\n\n" + splitMsg[i + 5] + " times played in the last 5 days";
			
			b.i_ = splitMsg[i];
			b.mapImg_ = splitMsg[i + 2];
			// If we're making a new game
			if (!this.game.id || this.game.id == 0)
			{
				b.onclick = function(){ createGame(this.i_, this.mapImg_); };
			}
			// If we're updating the lobby map
			else
			{
				b.onclick = function()
				{
					requestNewSkirmishMap(this.i_, this.mapImg_);
					soundManager.playSound(SOUND.CLICK);
					fadeOut($('#pickMapWindow'));
				};
			}
			$('#selectMapArea').append(b);
		}
	}
	
	else if(splitMsg[0] == "custom-map-creation-file")
	{
		network.send("cancel-ladder");
		fadeOut($('#ladderWindow'));
		
		var map = JSON.parse(splitMsg[1]);
		
		// set img
		map.img = getImageFromMap(map);
		
		// desc newlines
		var originDesc = map.description;
		map.description = map.description.replace(/\n/g, '<br />');
		
		if(game_state == GAME.LOBBY)
		{
			if(createdMulti)
			{
				this.game.id = 1;
				this.game.name = map.name;
				
				// clear game lobby chat
				$('#lobbyGameChatTextArea').html("");
				
				lobbyPlayerManager.init(true, map, true);
				
				// set focus on input
				setChatFocus(false);
			}
			
			else
			{
				lobbyPlayerManager.init(false, map);
				game_state = GAME.SKIRMISH;
			}
		}
		
		else if(game_state == GAME.EDITOR)
		{
			if(splitMsg[2] != "false")
			{
				// show loading screen
				uimanager.showLoadingScreen(map);
				
				setTimeout(function(){
					game = new Game();
					game.loadMap(map, null, null, null, true);
					worker.postMessage({what: "start-game", editorLoad: true, map: map, players: null, network_game: network_game, game_state: game_state, networkPlayerName: networkPlayerName});
					
					// kill the "Map by ..." at the end of the description because it will be recreate if the user reuploads the map
					if(originDesc.indexOf("\n\nMap by ") >= 0)
						originDesc = originDesc.split("\n\nMap by ").slice(0, -1).join("\n\nMap by ");
					
					// set form fields name and description
					$('#mapNameInput')[0].value = map.name;
					$('#mapDescriptionInput')[0].value = originDesc;
					$("#mapOpenCheckbox").prop('checked', map.globalVars ? map.globalVars.isOpen : false);
					$("#useBlackFogCheckbox").prop('checked', map.globalVars ? map.globalVars.useDarkMask : false);
					$("#maxSupplyInput")[0].value = map.globalVars ? map.globalVars.maxSupply : false;
					$("#startGoldInput")[0].value = map.globalVars ? map.globalVars.startGold : false;
					$("#mineDistInput")[0].value = map.globalVars ? map.globalVars.mineDist : false;
				}, 50);
			}
			else
				displayInfoMsg("You can only edit your own maps!");
		}
		
		fadeOut($('#pickMapWindow'));
	}
	
	else if(splitMsg[0] == "custom-map-replay-file" && splitMsg[1])
	{
		var map = JSON.parse(splitMsg[1]);
		currentMapImg = splitMsg[2];
		
		r = replayFile;
		
		// check if the map version is the same as the map version was when the replay was made and same for game version
		if(map && map.timestamp == r.mapVersion && r.gameVersion == GAME_VERSION)
		{
			network.send("cancel-ladder");
			fadeOut($('#ladderWindow'));
			
			var p = r.players.concat([{name: networkPlayerName, controller: CONTROLLER.SPECTATOR, team: 0, isPlayingPlayer: true}]);
			
			// show loading screen
			uimanager.showLoadingScreen(map, p);
			hideChat();
			
			setTimeout(function(){
				
				game_state = GAME.PLAYING;
				network.send("leave-lobby");
				
				game = new Game();
				game.loadMap(map, p, r.aiRandomizer, r.ticksCounter, false, r.messages);
				worker.postMessage({
					what: "start-game",
					map: map,
					players: p,
					network_game: network_game,
					game_state: game_state,
					networkPlayerName: networkPlayerName,
					aiRandomizer: r.aiRandomizer,
					ticksCounter: r.ticksCounter,
					incomingOrders: r.orders,
					playerLefts: r.playerLefts
				});
				
				incomingOrders = r.orders;
				playerLefts = r.playerLefts;
				
				mapData = "";
				
				$('#replayShowSpeed').html("1x");
			}, 50);
		}
		else
		{
			if(r.gameVersion != GAME_VERSION)
				displayInfoMsg("This replay was recorded with an older game version (" + r.gameVersion + "). The current game version is " + GAME_VERSION + ". You can check <a href='/old_versions'><span style='text-decoration: underline;'>the old versions directory</span></a> for the version of the game your replay was recorded with and then load it up with that version.");
			else
				displayInfoMsg("This replay was made with an older map version. Unfortunately you can't watch it anymore.");
		}
	}
	
	else if(splitMsg[0] == "laddermaps-list")
	{
		fadeIn($('#ladderWindow'));
		
		// explaining text
		var str = "Here you can play ranked 1v1 matches. If you click the 'Start searching' button, an opponent (preferably of same skill) will be searched (this may take a while, depending on how many other player searching for ranked matches). The winner gets ranking points while the loser loses ranking points. ";
		str += "The first 5 ranked matches you play will be used to determine your skill level. After your 5th game you will be placed into a division. ";
		str += "From there on you can get promoted or demoted depending on your results. Ranked matches are played on one of the following maps (randomly picked):<br /><br /><font style='color: #13C700;'>";
		
		// laddermaps list
		for(var i = 1; i < splitMsg.length; i++)
			str += splitMsg[i] + ", ";
		
		str = str.substr(0, str.length - 2) + "</font><br /><br />";
		
		$('#ladderWindow').html(str);
		
		$('#ladderWindow').append(uimanager.createButton("ladderButton2", "Start searching", function(){
			
			if(network.authedAndLogged)
			{
				network.send("init-ladder<<$" + GAME_VERSION);
				fadeIn($('#ladderWindow'));
				$('#ladderWindow').html("<br /><p style='font-size: 30px; margin: 20px auto;'>searching for opponent ...</p><br /><br /><br />");
				$('#ladderWindow').append(uimanager.createButton("cancelLadderButton", "cancel", function(){
					network.send("cancel-ladder");
					fadeOut($('#ladderWindow'));
					soundManager.playSound(SOUND.CLICK);
				}));
			}
			
			else
			{
				displayInfoMsg("Only registered users can play ranked matches.");
				fadeOut($('#ladderWindow'));
			}
			
			soundManager.playSound(SOUND.CLICK);
		}));
		
		$('#ladderWindow').append(uimanager.createButton("ladderCancelButton2", "Cancel", function(){
			fadeOut($('#ladderWindow'));
			soundManager.playSound(SOUND.CLICK);
		}));
	}
	
	else if(splitMsg[0] == "ladder-result")
	{
		$('#showLadderPointsDiv').html("");
		
		// won (gained ladder points)
		if(splitMsg[1].substr(0, 1) == "+")
		{
			$('#showLadderPointsDiv')[0].style.color = "#5EFF3E";
			$('#showLadderPointsDiv')[0].style.fontSize = "90px";
			$('#showLadderPointsDiv').html(splitMsg[1] + " Points");
		}
		
		// lost (lost ladder points)
		else if(splitMsg[1].substr(0, 1) == "-")
		{
			$('#showLadderPointsDiv')[0].style.color = "red";
			$('#showLadderPointsDiv')[0].style.fontSize = "70px";
			$('#showLadderPointsDiv').html(splitMsg[1] + " Points");
		}
		
		// promo
		else if(splitMsg[1].substr(0, 9) == "promotion")
		{
			storedAchivements.push({
				text: "<div id='promotionTextDiv' style='font-size: 30px;'><font class='greenfont'>Congratulations!</font> You were promoted to a new league:</div>" + getLeagueLink((splitMsg[1].split(" "))[1], false, 8),
				sound: SOUND.ARCHIVEMENT2
			});
			
			$('#mainLeagueLink').html(getLeagueLink((splitMsg[1].split(" "))[1], false, 4));
			
			showAchivement();
		}
		
		// demo
		else if(splitMsg[1].substr(0, 8) == "demotion")
		{
			storedAchivements.push({
				text: "<div id='promotionTextDiv' style='font-size: 30px;'>You were demoted to a new league:</div>" + getLeagueLink((splitMsg[1].split(" "))[1], false, 8)
			});
			
			$('#mainLeagueLink').html(getLeagueLink((splitMsg[1].split(" "))[1], false, 4));
			
			showAchivement();
		}
		
		// still doin' placement matches
		else if(splitMsg[1].substr(0, 9) == "placement")
		{
			$('#showLadderPointsDiv').html((splitMsg[1].split(" "))[1] + " matches left until you will get placed");
			$('#showLadderPointsDiv')[0].style.color = "white";
			$('#showLadderPointsDiv')[0].style.fontSize = "40px";
			
			$('#rankedGamesLeft').html((splitMsg[1].split(" "))[1]); // refresh ranked games left display
		}
		
		// initial placement
		else if(splitMsg[1].substr(0, 10) == "init-place")
		{
			storedAchivements.push({
				text: "<div id='promotionTextDiv' style='font-size: 30px;'><font class='greenfont'>Congratulations!</font> You've been placed in a league</div>" + getLeagueLink((splitMsg[1].split(" "))[1], false, 8),
				sound: SOUND.ARCHIVEMENT2
			});
			
			$('#mainLeagueLink').html(getLeagueLink((splitMsg[1].split(" "))[1], false, 4));
			
			showAchivement();
		}
	}
	
	// player info
	else if(splitMsg[0] == "player-info")
	{
		var rank = "<br />Ladder Record: <font class='greenfont'>" + parseInt(splitMsg[7]) + "</font> wins, <font class='redfont'>" + parseInt(splitMsg[8]) + "</font> losses";
		// Player Profile - Ladder Information
		if(parseInt(splitMsg[5]) >= 0)
			rank += "<br />Ladder Ranking: " + getLeagueLink(splitMsg[5], false, 1, false) + " (" + parseInt(splitMsg[6]) + " Points)";
		
		rank += "<br />";
		
		if(splitMsg[4] == "1")
			rank += "<br /><font style='color: #E84141;'>Admin</font> ";
		
		else if(splitMsg[3] == "1")
			rank += "<br /><font style='color: #F38F3C;'>Moderator</font> ";
		
		if(splitMsg[13] == "true")
			rank += "<br /><font style='color: #5FFF39;'>Premium User</font> ";
		
		var persText = ((splitMsg[9] && splitMsg[9].length > 0) || splitMsg[1] == networkPlayerName) ? ("<br /><br />Personal Text:<div id='personalTextDiv'>" + escapeHtml(splitMsg[9]).replace(/(?:\r\n|\r|\n)/g, '<br />') + "</div>" + (splitMsg[1] == networkPlayerName ? "<br /><button id='profileTextButton' onclick=editPersonalText()>edit</button>" : "")) : "";
		
		// lvl & exp
		var exp_ = "Level: <span class='greenfont'>" + getLvlFromXp(splitMsg[12]) + "</span><br />Experience: <span style='color: rgb(255, 255, 100);'>" + splitMsg[12] + "</span><br />";
		
		// clan
		var clan = (splitMsg[10] && splitMsg[10].length > 0) ? "Clan: [<a href='#' onclick='getClanInfo(\"" + splitMsg[10] + "\");' class='clanLink'>" + splitMsg[10] + "</a>]<br />" : "";
		
		// refresh friend button state
		addFriendButton = splitMsg[11] == 0 && splitMsg[1] != networkPlayerName && this.authedAndLogged;
		
		generatePlayerWindow(splitMsg[1], exp_ + clan + "Unranked games: " + splitMsg[2] + rank + persText);
	}
	
	else if(splitMsg[0] == "achivements-list")
	{
		showAchivementsWindow(splitMsg[1]);
	}
	
	// ladder info
	else if(splitMsg[0] == "player-info-ladder")
	{
		var games = "<p>Last ladder results:</p><table>";
		for(var i = 2; i + 2 < splitMsg.length; i += 5)
		{
			var win_text = "";
			if(splitMsg[i + 2] == -1)
				win_text = "<span style='color: yellow;'>-</span>";
			else
				win_text = ((splitMsg[i + 2] == "1" && splitMsg[i] == splitMsg[1]) || (splitMsg[i + 2] == "2" && splitMsg[i + 1] == splitMsg[1])) ? "<span class='greenfont'>win</span>" : "<span class='redfont'>loss</span>";
			games += "<tr><td>" + getPlayerLink(splitMsg[i]) + "</td><td> vs </td><td>" + getPlayerLink(splitMsg[i + 1]) + "</td><td> " + win_text + "</td><td class='ladderGameTimeTD'> &nbsp; " + splitMsg[i + 3] + "</td><td> &nbsp; " + splitMsg[i + 4] + "</td></tr>";
		}
		games += "</table>";
		
		generatePlayerWindow(splitMsg[1], games);
	}
	
	// friends info
	else if(splitMsg[0] == "player-info-friends")
	{
		var friends_split = splitMsg[2].split(" ");
		var friends = "<h2>Friends (" + (friends_split.length - 1) + " / 100)</h2>";
		for(var i = 0; i < friends_split.length; i++)
			friends += " " + getPlayerLink(friends_split[i]) + "<br />";
		generatePlayerWindow(splitMsg[1], friends);
	}
	
	// maps info
	else if(splitMsg[0] == "player-info-maps")
	{
		var friends = "<p>Maps made by " + splitMsg[1] + ":</p><br />";
		var hasMaps = false;
		for(var i = 2; i < splitMsg.length; i++)
		{
			if(splitMsg[i].length > 0)
			{
				hasMaps = true;
				friends += " &nbsp; " + splitMsg[i] + "<br />";
			}
		}
		
		if(!hasMaps)
			friends = " &nbsp; " + splitMsg[1] + " has not made any maps";
		
		generatePlayerWindow(splitMsg[1], friends);
	}
	
	// achievements info
	else if(splitMsg[0] == "player-info-arch")
	{
		var str = "<div>";
		
		for(var i = 0; i < achivements.length; i++)
		{
			if(checkDBPos(achivements[i].dbPos, splitMsg[5]))
			{
				var a = achivements[i];
				str += "<div class='achivement_div2' title='" + a.text + "'>";
				str += "<img class='pixelated' style='height: 81px;' src='imgs/achivements/" + a.img + "' /><p>" + a.name + "</p></div>";
			}
		}
		
		str += "</div><div style='clear: both;'></div><br /><br /><div style='padding: 20px;'>";
		
		var em = emotes.concat(_emotes2);
		for(var i = 0; i < em.length; i++)
			if(isUnlocked = em[i].free || (em[i].dbPos && em[i].dbPos <= splitMsg[2].length && splitMsg[2].substr(splitMsg[2].length - em[i].dbPos, 1) == "1"))
				str += "<img title='" + em[i].name + "' class='buytableImgs' src='imgs/emotes/" + em[i].img + "' /> ";
		
		str += "</div>";
		generatePlayerWindow(splitMsg[1], str);
	}
	
	// clan info
	else if(splitMsg[0] == "clan-info")
	{
		var str = "Tag: [" + splitMsg[1] + "]<br />Name: " + splitMsg[2] + "<br />" + (splitMsg[3] ? "<div class='profileTextDiv'>" + escapeHtml(splitMsg[3]).replace(/(?:\r\n|\r|\n)/g, '<br />') + "</div>" : "") + "<br /><br /><span class='biggerFont'>Members:</span><br />";
		
		var membersArray = splitMsg[4].split(" ");
		for(var i = 0; i < membersArray.length; i++)
			if(membersArray[i].length > 0)
				str += getPlayerLink(membersArray[i]) + "<br />";
		
		str += "<br /><br /><button onclick='getClanList(); soundManager.playSound(SOUND.CLICK);'>show all clans</button>";
		$('#addScrollableSubDivTextArea').html(str);
		$('#riderDiv').html("");
		fadeIn($('#playerInfoWindow'));
		
		uimanager.playerInfoWindow.setTitle("<font style='color: rgb(255, 248, 57);'>Clan " + splitMsg[2] + "</font>");
	}
	
	else if(splitMsg[0] == "gold-update")
	{
		gold = splitMsg[1];
		$('#playerGold').html(gold);
		console.log(`Gold update ${gold}`);
	}
	
	else if(splitMsg[0] == "gold-reward")
	{
		displayInfoMsg2("<p style='font-size: 44px;'>You got <span style='color: rgb(255, 255, 99);'>" + splitMsg[1] + "</span> gold</p><br /><br /><br /><img src='imgs/gold2.png' class='pixelated' style='height: 128px;' />", true);
	}
	
	// emotes info
	else if(splitMsg[0] == "emotes-info")
	{
		var playerGold = gold;
		var emotesBin = hex32ToBin(splitMsg[1]);
		var str = "<div><br />&nbsp; &nbsp;Emotes are small icons that can be used in lobby chat.<br /><br /></div>";
		
		for(var i = 0; i < emotes.length; i++)
		{
			var isUnlocked = emotes[i].free || (emotes[i].dbPos && emotes[i].dbPos <= emotesBin.length && emotesBin.substr(emotesBin.length - emotes[i].dbPos, 1) == "1");
			
			var title_ = "";
			
			if(isUnlocked)
				title_ = "title='Type " + emotes[i].text + " in chat to use this emote'";
			
			else if(emotes[i].price)
				title_ = "title='Buy this emote for " + emotes[i].price + "€'";
			
			else if(emotes[i].gold)
				title_ = playerGold >= emotes[i].gold ? "title='Get this emote for " + emotes[i].gold + " gold'" : "title='You need " + emotes[i].gold + " gold for this emote'";
			
			else if(emotes[i].playerLvl)
				title_ = "title='This emote wil be unlocked when your account reaches level " + emotes[i].playerLvl + "'";
			
			else if(emotes[i].div)
				title_ = "title='This emote wil be unlocked when you reach " + leagueNames[emotes[i].div - 1] + " (or a higher league)'";
			
			else if(emotes[i].special)
				title_ = "title='" + emotes[i].requirementTitle + "'";
			
			str += "<div class='buytable2' " + title_ + "><p><img class='buytableImgs' src='imgs/emotes/" + emotes[i].img + "' /></p><p class='buytableNames'>" + emotes[i].name + "</p><div class='buytablePurchased'>";
			
			if(isUnlocked)
				str += "<font class='greenfont'>unlocked</font>";
			
			else if(emotes[i].price)
				str += getBuyButton0(emotes[i].artNr, emotes[i].price, splitMsg[2]);
			
			else if(emotes[i].gold)
			{
				str += playerGold >= emotes[i].gold ? "<button onclick='getItem4Gold(\"" + emotes[i].artNr + "\");'>Get for " + emotes[i].gold + " gold</button>" : "<span class='redfont'>" + emotes[i].gold + " gold required</span>";
				
			}
				
			else if(emotes[i].playerLvl)
				str += "Level " + emotes[i].playerLvl + " required";
			
			else if(emotes[i].div)
				str += leagueNames[emotes[i].div - 1] + " required";
			
			else if(emotes[i].special)
				str += emotes[i].requirementText;
			
			str += "</div></div>";
		}
		
		$('#addScrollableSubDivTextArea').html(str);
		fadeIn($('#playerInfoWindow'));
		
		uimanager.playerInfoWindow.setTitle("<font style='color: rgb(255, 248, 57);'>Emotes</font>", "<button onclick='soundManager.playSound(SOUND.CLICK); showMicroTransWindow();'>back</button>");
	}
	
	else if(splitMsg[0] == "skins-info")
	{
		var playerGold = gold;
		var str = "<div>Purchase custom skins for your units!</div>";
		
		var skins_obj = null;
		try{ skins_obj = JSON.parse(splitMsg[2]); }catch(e){}
		if(!skins_obj)
			skins_obj = {};
		
		for(var k = 0; k < basicUnitTypes.length; k++)
		{
			var first = true;
			
			var j = 0;
			
			for(var i = 0; i < skins.length; i++)
				if(skins[i].unit_id_string == basicUnitTypes[k].id_string)
				{
					var isUnlocked = skins[i].free || (skins[i].dbPos && splitMsg[1].length >= skins[i].dbPos && splitMsg[1].substr(splitMsg[1].length - skins[i].dbPos, 1) == "1");
					
					// if it's the first skin, inject the default ahead of it
					if(first)
					{
						first = false;
						var img = unit_imgs[basicUnitTypes[k].img];
						
						var w = img.idle.frameWidth;
						var h = img.idle.h / img._angles;
						
						if(w > h)
						{
							h = 100 * (h / w);
							w = 100;
						}
						else
						{
							w = 100 * (w / h);
							h = 100;
						}
						
						var w2 = img.file[1].width * (w / img.idle.frameWidth);
						var h2 = img.file[1].height * (h / (img.idle.h / img._angles));
						var x = img.idle.x * (w2 / img.file[1].width);
						var y = img.idle.y * (h2 / img.file[1].height);
						
						str += "<div class='buytable'><p class='buytable_title'>" + basicUnitTypes[k].name + "</p><div><button id='skins_" + basicUnitTypes[k].id_string + "_0' onclick='setSkin(null, \"" + basicUnitTypes[k].id_string + "\", " + j + ");'";
						str += "class='buytableImgs2 " + (skins_obj[basicUnitTypes[k].id_string] ? "b_inactive" : "b_active") + "'><div style='width: " + w + "px; height: " + h + "px; overflow: hidden; position: relative;'>";
						str += "<img style='position: absolute; left: " + -x + "px; top: " + -y + "px; width: " + w2 + "px; height: " + h2 + "px;' src='" + (img.file[1].toDataURL ? img.file[1].toDataURL() : img.file[1].src) + "' /></div></button>";
						str += "<p class='buytableNames'>Default</p><p class='buytablePurchased'>";
						str += "<font class='greenfont'>unlocked</font></div>";
					}
					
					j++;
					
					var img2 = unit_imgs[skins[i].img];
					
					var w = img2.idle.frameWidth;
					var h = img2.idle.h / img._angles;
					
					if(w > h)
					{
						h = 100 * (h / w);
						w = 100;
					}
					else
					{
						w = 100 * (w / h);
						h = 100;
					}
					
					var w2 = img2.file[1].width * (w / img2.idle.frameWidth);
					var h2 = img2.file[1].height * (h / (img2.idle.h / img._angles));
					var x = img2.idle.x * (w2 / img2.file[1].width);
					var y = img2.idle.y * (h2 / img2.file[1].height);
					var name = skins[i].name || "Default";
					
					str += " <div><button id='skins_" + basicUnitTypes[k].id_string + "_" + j + "' " + (isUnlocked ? "onclick='setSkin(\"" + skins[i].artNr + "\", \"" + basicUnitTypes[k].id_string + "\", " + j + ");' " : "");
					str += "class='buytableImgs2 " + (isUnlocked ? (skins_obj[basicUnitTypes[k].id_string] == skins[i].artNr ? "b_active" : "b_inactive") : "b_disabled") + "'>";
					str += "<div style='width: " + w + "px; height: " + h + "px; overflow: hidden; position: relative;'>";
					str += "<img style='position: absolute; left: " + -x + "px; top: " + -y + "px; width: " + w2 + "px; height: " + h2 + "px;' src='" + (img2.file[1].toDataURL ? img2.file[1].toDataURL() : img2.file[1].src) + "' /></div></button>";
					str += "<p class='buytableNames'>" + name + "</p><p class='buytablePurchased'>";
					
					if(isUnlocked)
						str += "<font class='greenfont'>unlocked</font>";
					
					else if(skins[i].price)
						str += getBuyButton0(skins[i].artNr, skins[i].price, splitMsg[4]);
					
					else if(skins[i].gold)
						str += playerGold >= skins[i].gold ? "<button onclick='getItem4Gold(\"" + skins[i].artNr + "\");'>Get for " + skins[i].gold + " gold</button>" : "<span class='redfont'>" + skins[i].gold + " gold required</span>";
					
					else if(skins[i].playerLvl)
						str += "Level " + skins[i].playerLvl + " required";
					
					else if(skins[i].div)
						str += leagueNames[skins[i].div] + " required";
					
					str += "</p></div>";
				}
			
			if(!first)
				str += "</div>";
		}
		
		// Dances
		str += "<div style='clear: both;'><br /><h2>&nbsp; &nbsp;Dances</h2></div><div>&nbsp; &nbsp;Some of your units can perform dance animations in game.<br /><br /></div>";
		
		var offsets = [];
		var maxs = [];
		var xs = [];
		var ys = [];
		var j = 0;
		
		for(var k = 0; k < basicUnitTypes.length; k++)
		{
			var first = true;
			
			for(var i = 0; i < dances.length; i++)
				if(dances[i].unit_id_string == basicUnitTypes[k].id_string)
				{
					var isUnlocked = dances[i].free || (dances[i].dbPos && splitMsg[3].substr(splitMsg[3].length - dances[i].dbPos, 1) == "1");
					
					if(first)
					{
						first = false;
						str += "<div class='buytable'><p class='buytable_title'>" + basicUnitTypes[k].name + "</p>";
					}
					
					var img = unit_imgs[basicUnitTypes[k].img][dances[i].animName];
					var file = unit_imgs[basicUnitTypes[k].img].file[1];
					
					offsets.push(img.frameWidth * 4);
					maxs.push(img.w * 4);
					xs.push(img.x * 4);
					ys.push(img.y * 4);
					
					str += "<div " + (isUnlocked ? ("title='Select units ingame and type " + dances[i].chat_str + " in chat to make them perform this dance'") : "") + "><div class='dancediv' ";
					str += " style='width: " + (img.frameWidth * 4) + "px;'><img id='dance_img_" + j + "' style='margin-left: 0; height: " + (4 * file.height) + "px;' class='pixelated' src='" + file.toDataURL() + "' /></div>";
					str += "<p class='buytableNames'>" + dances[i].name + "</p><p class='buytablePurchased'>";
					
					if(isUnlocked)
						str += "<font class='greenfont'>unlocked</font>";
					
					else if(dances[i].price)
						str += getBuyButton0(dances[i].artNr, dances[i].price, splitMsg[4]);
					
					else if(dances[i].gold)
						str += playerGold >= dances[i].gold ? "<button onclick='getItem4Gold(\"" + dances[i].artNr + "\");'>Get for " + dances[i].gold + " gold</button>" : "<span class='redfont'>" + dances[i].gold + " gold required</span>";
					
					else if(dances[i].playerLvl)
						str += "Level " + dances[i].playerLvl + " required";
					
					else if(dances[i].div)
						str += leagueNames[dances[i].div] + " required";
					
					str += "</p></div>";
					
					j++;
				}
			
			if(!first)
				str += "</div>";
		}
		
		animateDances(offsets, maxs, xs, ys);
		
		$('#addScrollableSubDivTextArea').html(str);
		fadeIn($('#playerInfoWindow'));
		
		uimanager.playerInfoWindow.setTitle("<font style='color: rgb(255, 248, 57);'>Skins &amp; Dances</font>", "<button onclick='soundManager.playSound(SOUND.CLICK); showMicroTransWindow();'>back</button>");
	}
	else if(splitMsg[0] == "friends-pending")
	{
		updateFriendsPendingIcon(splitMsg[1] == "1");
	}
	else if(splitMsg[0] == "friends-list" && splitMsg.length >= 2)
	{
		var friends = "";
		var onlineFriends = "";
		var offlineFriends = "";
		var incoming = "";
		var outgoing = "";
		
		var countFriends = 0;
		var countOnline = 0;
		var countIncoming = 0;
		var countOutgoing = 0;
		
		var friendsMsg = splitMsg[1].split(" ");
		
		for(var i = 0; i < friendsMsg.length; i += 4)
		{
			if(friendsMsg[i + 2] == 0)
			{
				countFriends++;
				var friendName = friendsMsg[i] == networkPlayerName ? friendsMsg[i + 1] : friendsMsg[i];
				if (friendsMsg[i + 3] == "1")
				{
					onlineFriends += " &nbsp; " + getPlayerLink(friendName) + " " + (friendsMsg[i + 3] == "1" ? "<span class='online'>online</span>" : "") + " (<a href='#' onclick='soundManager.playSound(SOUND.CLICK); network.send(\"cancel-friend<<$" + friendName + "\");' class='yellowfont'>remove</a>)<br />";
					countOnline++
				}
				else
				{
					offlineFriends += " &nbsp; " + getPlayerLink(friendName) + " " + (friendsMsg[i + 3] == "1" ? "<span class='online'>online</span>" : "") + " (<a href='#' onclick='soundManager.playSound(SOUND.CLICK); network.send(\"cancel-friend<<$" + friendName + "\");' class='yellowfont'>remove</a>)<br />";
				}
			}
			
			else if(friendsMsg[i] == networkPlayerName) // outgoing request
			{
				outgoing += " &nbsp; " + getPlayerLink(friendsMsg[i + 1]) + " (<a href='#' onclick='soundManager.playSound(SOUND.CLICK); network.send(\"cancel-friend<<$" + friendsMsg[i + 1] + "\");' class='yellowfont'>cancel</a>)<br />";
				countOutgoing++;
			}
			
			else if(friendsMsg[i + 1] == networkPlayerName) // incoming requests
			{
				incoming += " &nbsp; " + getPlayerLink(friendsMsg[i]) + " (<a href='#' onclick='soundManager.playSound(SOUND.CLICK); network.send(\"add-friend<<$" + friendsMsg[i] + "\");' class='yellowfont'>accept</a>) (<a href='#' onclick='soundManager.playSound(SOUND.CLICK); network.send(\"cancel-friend<<$" + friendsMsg[i] + "\");' class='yellowfont'>decline</a>)<br />";
				countIncoming++;
			}
		}
		
		friendsTitle = ("<h2> &nbsp; Friends (" + countFriends + " / 100)</h2>");
		var onlineTitle = "<h2> &nbsp; Online (" + countOnline + ")</h2><br />";
		var offlineTitle = "<h2> &nbsp; Offline (" + (countFriends - countOnline) + ")</h2><br />";
		friends = countFriends > 0 ? friends : ("<h2> &nbsp; Friends</h2><p>You don't have any friends yet</p>")
		incoming = incoming.length > 0 ? ("<br /><h2> &nbsp; Incoming requests (" + countIncoming + ")</h2>" + incoming) : "";
		outgoing = outgoing.length > 0 ? ("<br /><h2> &nbsp; Outgoing requests (" + countOutgoing + ")</h2>" + outgoing) : "";
		
		// TODO: WORK OUT IF THIS IS CORRECT
		$('#queriesWindow').append(p);
		p = document.createElement("p");
		var newFriend = "<br /> &nbsp; <input type='text' id='newFriendInput' /> &nbsp; <button onclick='sendFriendRequest(); soundManager.playSound(SOUND.CLICK);'>send new friend request</button><br /><br />";
		p.innerHTML = newFriend;
		p.id = "addFriendP";
		$('#queriesWindow').append(p);

		$('#friendsSubdiv').html(friendsTitle + incoming + outgoing + onlineTitle + onlineFriends + offlineTitle + offlineFriends);
 		fadeIn($('#queriesWindow'));

		// Icon
		updateFriendsPendingIcon(countIncoming);
	}
	
	else if(game_state == GAME.EDITOR)
	{
		if(msg == "map-upload-init")
		{
			var map = game.export_();
			this.send("uploading-map<<$" + JSON.stringify(map) + "<<$" + getImageFromMap(game.export_(true)) + "<<$" + getPlayerCountFromMap(map) + "<<$" + $('#mapDescriptionInput')[0].value);
		}
		
		else if(splitMsg[0] == "personal-maps")
		{
			// clear window
			$('#mapWindowSubdiv').html("");
			
			// display maps
			for(var i = 1; i < splitMsg.length; i++)
			{
				var p = document.createElement("p");
				p.innerHTML = splitMsg[i] + " ";
				
				var b = document.createElement("button");
				b.innerHTML = "X";
				b.i_ = splitMsg[i];
				b.title = "delete this map";
				b.onclick = function(){
					network.send("map-delete-request<<$" + this.i_);
					soundManager.playSound(SOUND.CLICK);
				};
				
				p.appendChild(b);
				$('#mapWindowSubdiv').append(p);
			}
		}
		
		else if(msg == "map-has-been-deleted")
			this.send("request-my-maps");
		
		else if(splitMsg[0] == "custom-map-editor-file" && splitMsg[1])
		{
			var map = JSON.parse(splitMsg[1]);
			currentMapImg = splitMsg[2];
			
			soundManager.playSound(SOUND.CLICK);
			
			// show loading screen
			uimanager.showLoadingScreen(map);
			
			setTimeout(function(){
				game = new Game();
				game.loadMap(map, null, null, null, true);
				worker.postMessage({what: "start-game", editorLoad: true, map: map, players: null, network_game: network_game, game_state: game_state, networkPlayerName: networkPlayerName});
				
				// set form fields name and description
				$('#mapNameInput')[0].value = map.name;
				$('#mapDescriptionInput')[0].value = map.description;
				$("#mapOpenCheckbox").prop('checked', map.globalVars ? map.globalVars.isOpen : false);
				$("#useBlackFogCheckbox").prop('checked', map.globalVars ? map.globalVars.useDarkMask : false);
				$("#maxSupplyInput")[0].value = map.globalVars ? map.globalVars.maxSupply : false;
				$("#startGoldInput")[0].value = map.globalVars ? map.globalVars.startGold : false;
				$("#mineDistInput")[0].value = map.globalVars ? map.globalVars.mineDist : false;
			}, 50);
		}
	}
	
	else if(game_state == GAME.LOBBY || game_state == GAME.ACCEPT_AGB)
	{
		if(splitMsg[0] == "start-game" && splitMsg.length >= 4)
		{
			network.send("cancel-ladder");
			fadeOut($('#ladderWindow'));
			
			// parse players object
			var obj = JSON.parse(splitMsg[3]);
			
			// set players object
			var players = obj.players;
			
			// set playing player
			players[splitMsg[1]].isPlayingPlayer = true;
			
			// random KI number
			var aiRandomizer = splitMsg[2];
			
			network_game = true;
			ladder_game = false;
			
			// show loading screen
			uimanager.showLoadingScreen(lobbyPlayerManager.map, players);
			hideChat();
			
			setTimeout(function(){
				game = new Game();
				game.loadMap(lobbyPlayerManager.map, players, aiRandomizer);
				game_state = GAME.PLAYING;
				mapData = "";
				worker.postMessage({what: "start-game", map: lobbyPlayerManager.map, players: players, aiRandomizer: aiRandomizer, network_game: network_game, game_state: game_state, networkPlayerName: networkPlayerName});
				
				// send initial order cycle(s)
				for(var i = 0; i < TICKS_DELAY - 1; i++)
					network.send(JSON.stringify({"tick": i, "orders": []}));
			}, 50);
		}
		
		else if(msg == "you-are-new-host")
			lobbyPlayerManager.setHost(true);
		
		else if((splitMsg[0] == "game-joined" || splitMsg[0] == "game-created") && splitMsg.length >= 3)
		{
			this.game.id = parseInt(splitMsg[1]);
			this.game.name = escapeHtml(splitMsg[2]);
			
			$('#lobbyGameChatTextArea').html("");
			
			if(splitMsg[0] == "game-joined")
			{
				lobbyPlayerManager.init(true);
				lobbyPlayerManager.refreshFromServer(JSON.parse(splitMsg[3]).players);
			}
			
			// set focus on input
			setChatFocus(false);
		}
		
		else if(splitMsg[0] == "custom-map-join-file" && splitMsg[1])
		{
			var map = JSON.parse(splitMsg[1]);
			map.img = splitMsg[2];
			map.description = map.description.replace(/\n/g, '<br />');
			currentMapImg = map.img;
			lobbyPlayerManager.setMap(map);
		}
		
		else if(splitMsg[0] == "custom-map-ladder-file" && splitMsg.length >= 3)
		{
			$('#ladderWindow')[0].style.display = "inline";
			
			var map = JSON.parse(splitMsg[1]);
			map.img = splitMsg[2];
			map.description = map.description.replace(/\n/g, '<br />');
			currentMapImg = map.img;
			
			// parse players pbject
			var obj = JSON.parse(splitMsg[5]);
			
			// set players object
			var players = obj.players;
			
			// set playing player
			players[splitMsg[3]].isPlayingPlayer = true;
			
			// random KI number
			var aiRandomizer = splitMsg[4];
			
			network_game = true;
			ladder_game = true;
			
			$('#ladderWindow').html("<br /><br /><p style='font-size: 30px;'>Opponent found, starting game in<p><br /><br /><p id='ladderStartCounter'>10</p>");
			
			soundManager.playSound(SOUND.LADDER_START);
			
			var ladderTicker = setInterval(function(){
				
				var counter = $('#ladderStartCounter')[0].innerHTML;
				
				// start game
				if(counter <= 1)
				{
					clearInterval(ladderTicker);
					
					$('#ladderWindow')[0].style.display = "none";
					
					// show loading screen
					uimanager.showLoadingScreen(map, players);
					hideChat();
					
					network.send("load-ladder-map");
					
					setTimeout(function(){
						game = new Game();
						game.loadMap(map, players, aiRandomizer);
						game_state = GAME.PLAYING;
						mapData = "";
						worker.postMessage({what: "start-game", map: map, players: players, aiRandomizer: aiRandomizer, network_game: network_game, game_state: game_state, networkPlayerName: networkPlayerName});
						
						// send initial order cycle(s)
						for(var i = 0; i < TICKS_DELAY - 1; i++)
							network.send(JSON.stringify({"tick": i, "orders": []}));
					}, 50);
				}
				
				else
					$('#ladderStartCounter')[0].innerHTML = counter - 1;
				
			}, 1000);
		}
		
		else if(splitMsg[0] == "games-list" && !this.game.id)
		{
			$('#gamesWindowTextArea').html("");
			
			for(var i = 1; i < splitMsg.length; i++)
			{
				var g = splitMsg[i].split("<");
				
				var gameButton = document.createElement("p");
				gameButton.onmouseover = function() {
					this.style.backgroundColor = "rgba(255, 255, 255, 0.4)";
					soundManager.playSound(SOUND.ZIP, false, 0.3);
				};
				gameButton.onmouseout = function() {
					this.style.backgroundColor = "rgba(0, 0, 0, 0)";
					soundManager.playSound(SOUND.ZIP, false, 0.3);
				};
				// Derive settings
				const players = " [" + g[2] + "/" + g[3] + "] ";
				const running = (g[4] == "1" ? "<span class='running'>running</span> " : "");
				const private = (g[8] == "1" ? "<img src='imgs/lock.png' />" : "");
				const custom = (g[9] == "1" ? "<span class='mapListMod'>custom map</span> " : "");

				// Populate item
				gameButton.innerHTML = escapeHtml(g[1]) + players + custom + running + private;
				gameButton.gameID_ = parseInt(g[0]);
				gameButton.pw_ = g[8] == "1";
				gameButton.innerHTML = escapeHtml(g[1]) + " [" + g[2] + "/" + g[3] + "] " + (g[4] == "1" ? "<span class='running'>running</span> " : "") + (g[8] == "1" ? "<img src='imgs/lock.png' />" : "");
				gameButton.title = "Host: " + g[6] + " | Game Version: " + g[5] + " | Map: " + g[7];
				gameButton.onclick = g[8] == "1" ? function() {
					var b = document.createElement("button");
					b.id = "game_pw_button";
					b.gameID_ = this.gameID_;
					b.innerHTML = "join";
					b.onclick = function(){ joinPWGame(this.gameID_); };
					displayInfoMsg("This game is password protected. Enter password:<br /><input type='text' id='game_pw' /><br />");
					$('#infoWindowTextArea').append(b);
					soundManager.playSound(SOUND.CLICK);
				} : function() {
					network.send("join-game<<$" + this.gameID_ + "<<$" + GAME_VERSION);
					soundManager.playSound(SOUND.CLICK);
				};
				
				$('#gamesWindowTextArea').append(gameButton);
			}
		}
		
		else if(msg == "you've-been-kicked")
		{
			this.game.id = 0;
			this.game.name = "";
			
			// set focus on input
			setChatFocus(true);
		}
		
		else if(splitMsg[0] == "player-list")
		{
			this.players = {};
			
			for(var i = 1; i < splitMsg.length; i++)
			{
				var pl = splitMsg[i].split("<");
				var name = escapeHtml(pl[0]);
				this.players[name] = {
					name: name,
					location: pl[1],
					authLevel: pl[2],
					clan: pl[3],
					premium: pl[4] == "1"
				};
			}
			
			this.refreshPlayerWindow();
		}
		
		else if(splitMsg[0] == "player-location-update" && splitMsg.length >= 3)
		{
			var player = escapeHtml(splitMsg[1]);
			
			const location = parseInt(splitMsg[2]);
			let locString = resolveLocationString(location);
			
			$('#playerLocation_' + player).html(" " + locString);
			if(this.players[player])
				this.players[player].location = splitMsg[2];
		}
		
		else if(splitMsg[0] == "player-premium-update" && splitMsg.length >= 3)
		{
			var player = escapeHtml(splitMsg[1]);
			
			if(this.players[player])
				this.players[player].premium = splitMsg[2] == "1";
			
			if(!this.players[player] || this.players[player].authLevel < AUTH_LEVEL.MOD)
				$('#playerList_' + player).children(".playerNameInList").attr('class', 'playerNameInList playerLinkPremium');
		}
		
		else if(splitMsg[0] == "player-clan-update" && splitMsg.length >= 3)
		{
			var player = escapeHtml(splitMsg[1]);
			
			$('#playerLocationClan_' + player).html((splitMsg[2] && splitMsg[2].length > 0) ? "[<a href='#' onclick='getClanInfo(\"" + splitMsg[2] + "\");' class='clanLink'>" + splitMsg[2] + "</a>] " : "");
			
			if(this.players[player])
				this.players[player].clan = splitMsg[2];
		}
		
		else if(splitMsg[0] == "clans-list")
		{
			var str = "<table><tr><td class='clanListTitleLine'>Tag</td><td class='clanListTitleLine'>Name</td><td class='clanListTitleLine'>Members</td></tr><tr><td></td><td></td><td></td></tr>";
			
			for(var i = 1; i < splitMsg.length - 1; i += 3)
				str += "<tr><td>[<a href='#' onclick='getClanInfo(\"" + splitMsg[i] + "\");' class='clanLink'>" + splitMsg[i] + "</a>]</td><td>" + splitMsg[i + 1] + "</td><td>" + splitMsg[i + 2] + "</td></tr>";
			
			str += "</table>";
			
			uimanager.playerInfoWindow.setTitle("<font style='color: rgb(255, 248, 57);'>Clans</font>");
			
			$('#addScrollableSubDivTextArea').html(str);
			fadeIn($('#playerInfoWindow'));
		}
		
		else if(splitMsg[0] == "bing-msg" && splitMsg.length >= 2)
		{
			bingMsg(splitMsg[1]);
		}
		
		// an infostring, that defines the players, teams and everything in a game-lobby, whenever the host changes something, this is sent to all players
		else if(splitMsg[0] == "infostring" && splitMsg.length >= 2)
		{
			var obj = JSON.parse(splitMsg[1]);
			
			// get player names array
			var players1 = getPlayerNameArrayFromPlayerSettingsArrayObject(lobbyPlayerManager.getPlayerSettingsArrayObject());
			
			// refresh lobby
			lobbyPlayerManager.refreshFromServer(obj.players);
			
			// get player names array again
			var players2 = getPlayerNameArrayFromPlayerSettingsArrayObject(lobbyPlayerManager.getPlayerSettingsArrayObject());
			
			// check, if a player has joined of left and add chat msg, if so
			if(players2.length > players1.length)
			{
				for(var i = 0; i < players2.length; i++)
					if(players1.indexOf(players2[i]) == -1)
					{
						$('#lobbyGameChatTextArea')[0].innerHTML += "<p>Server (" + getFormattedTime() + "): Player " + players2[i] + " joined</p>";
						$('#lobbyGameChatTextArea')[0].scrollTop = $('#lobbyGameChatTextArea')[0].scrollHeight;
					}
			}
			
			else if(players2.length < players1.length)
			{
				for(var i = 0; i < players1.length; i++)
					if(players2.indexOf(players1[i]) == -1)
					{
						$('#lobbyGameChatTextArea')[0].innerHTML += "<p>Server (" + getFormattedTime() + "): Player " + players1[i] + " left</p>";
						$('#lobbyGameChatTextArea')[0].scrollTop = $('#lobbyGameChatTextArea')[0].scrollHeight;
					}
			}
		}
		
		else if(splitMsg[0] == "player-left" && splitMsg.length >= 2)
		{
			var player = escapeHtml(splitMsg[1]);
			
			delete this.players[player]; // remove from player list
			
			// kill element from player list
			var playerListElement = $('#playerList_' + player)[0];
			
			if(playerListElement)
				playerListElement.parentNode.removeChild(playerListElement);
			
			// refresh title, so it shows the total player count
			$('#playersWindow')[0].getElementsByTagName('h2')[0].innerHTML = "&raquo; Players (" + _.size(this.players) + ")";
		}
		
		else if(splitMsg[0] == "player-joined" && splitMsg.length >= 3)
		{
			var player = escapeHtml(splitMsg[1]);
			
			// if player already exists, return
			if(this.players[player])
				return;
			
			this.players[player] = {name: player, location: 0, authLevel: splitMsg[2], clan: splitMsg[3], premium: splitMsg[4] == "true"};
			
			// add dom node
			$('#playersWindowTextArea').append(this.createPlayerNode(this.players[player]));
			this.refreshPlayerWindow();
			
			// refresh title, so it shows the total player count
			$('#playersWindow')[0].getElementsByTagName('h2')[0].innerHTML = "&raquo; Players (" + _.size(this.players) + ")";
		}
		
		else if(splitMsg[0] == "lcg-battle")
		{
			littlechatgame(JSON.parse(splitMsg[1]));
		}
		
		else if(splitMsg[0] == "lcg-rank")
		{
			var p = document.createElement("p");
			
			var time = document.createElement("span");
			time.className = "time";
			time.innerHTML = getFormattedTime() + " &nbsp;";
			
			var span = document.createElement("span");
			
			span.innerHTML = "Server: Littlechatgame record for " + splitMsg[1] + ": " + splitMsg[2] + " wins / " + splitMsg[3] + " losses. Rank: " + getRankCode(splitMsg[4]) + " &nbsp;(Global ranking #" + splitMsg[5] + ")";
			
			p.appendChild(time);
			p.appendChild(span);
			
			addToChatWindow(p);
		}
		
		else if(splitMsg[0] == "lcg-top")
		{
			var p = document.createElement("p");
			
			var time = document.createElement("span");
			time.className = "time";
			time.innerHTML = getFormattedTime() + " &nbsp;";
			
			var span = document.createElement("span");
			
			span.innerHTML = "Server: Littlechatgame top ranked players:";
			
			for(var i = 1; i < splitMsg.length; i += 2)
				span.innerHTML += "<br />" + Math.ceil(i / 2) + ". " + splitMsg[i] + " (" + getRankCode(splitMsg[i + 1]) + ")";
			
			p.appendChild(time);
			p.appendChild(span);
			
			addToChatWindow(p);
		}
		
		else if(splitMsg[0] == "chat")
		{
			// split chat msg and add time
			var display = true;
			
			// its a command, (theres a "/" at the beginning, so dont display message, but execute command)
			if(splitMsg[3].indexOf("/") === 0)
			{
				display = false;
				
				// if its a ping command and we are the sending player
				if(splitMsg[3] == "/ping" && splitMsg[2] == networkPlayerName)
				{
					display = true;
					splitMsg[3] = "ping: " + (Date.now() - timeOfLastPingSent) + " ms";
				}
			}
			
			if(display && !ignores.contains(splitMsg[2].toLowerCase()))
				addChatMsg(splitMsg[2], splitMsg[3], splitMsg[1]);
		}
	
	}
	
	else if(game_state == GAME.PLAYING && network_game)
	{
		if(splitMsg[0] == "order-missing")
		{
			var tickToSend = parseInt(splitMsg[1]);
			
			// if(lastSentTick >= tickToSend)
				network.send(JSON.stringify({tick: tickToSend, orders: []}));
			
			//console.log("missing order " + tickToSend + " resent");
		}
		
		else if(splitMsg[0] == "chat")
		{
			if(!ignores.contains(splitMsg[2].toLowerCase()))
			{
				var msg_ = splitMsg[2] + ": " + splitMsg[3];
				//console.log(`Got msg ${msg_}`);
				game.addChatMsgToLog(msg_);
				//console.log(`Muted: ${game.chat_muted}`);
				if (!game.chat_muted)
				{
					interface_.chatMsg(msg_);
				}
			}
		}
		
		else if(splitMsg[0] == "chat-server")
		{
			soundManager.playSound(SOUND.POSITIVE);
			interface_.addMessage(splitMsg[1], "yellow", imgs.attentionmarkYellow);
		}
		
		else if(splitMsg[0] == "ping")
		{
			this.pings.push(Date.now() - timeOfLastPingSent);
			if(this.pings.length > 8)
				this.pings.splice(0, 1);
			
			var delayShouldBe = Math.ceil(Math.max.apply(null, this.pings) / TICK_TIME) + this.EXTRA_DELAY + ((PLAYING_PLAYER && PLAYING_PLAYER.controller == CONTROLLER.SPECTATOR) ? 2 : 0);
			
			if(delayShouldBe > TICKS_DELAY)
				game.increaseDelayOnNextTick = true;
			
			else if(delayShouldBe < TICKS_DELAY)
				game.reduceDelayOnNextTick = true;
		}
		
		else if(splitMsg[0] == "waiting-for")
			interface_.addMessage("Waiting for player " + splitMsg[1], "yellow", imgs.attentionmarkYellow);
		
		else if(msg == "youve-been-kicked")
		{
			this.game.id = 0;
			this.game.name = "";
			game_state = GAME.LOBBY;
			
			// set focus on input
			setChatFocus(true);
			
			keyManager.resetCommand();
		}
		
		else if(splitMsg[0] == "game-paused")
		{
			game_paused = true;
			interface_.addMessage("Game paused by " + splitMsg[1] + " (" + splitMsg[2] + " pauses left)", "yellow", imgs.attentionmarkYellow);
			soundManager.playSound(SOUND.POSITIVE);
			worker.postMessage({what: "setPause", val: game_paused});
		}
		
		else if(splitMsg[0] == "game-unpaused")
		{
			game_paused = false;
			interface_.addMessage("Game unpaused by " + splitMsg[1], "yellow", imgs.attentionmarkYellow);
			soundManager.playSound(SOUND.POSITIVE);
			worker.postMessage({what: "setPause", val: game_paused});
		}
		
		else if(splitMsg[0] == "map-ping")
		{
			if(!ignores.contains(splitMsg[3].toLowerCase()))
			{
				game.minimap.mapPings.push({field: new Field(parseInt(splitMsg[1]), parseInt(splitMsg[2])), time: Date.now()});
				soundManager.playSound(SOUND.BING2);
			}
		}
		
		// orders
		else if(splitMsg[0] != "dummy")
		{
			worker.postMessage({what: "orders", msg: msg});
			
			try {
				
				var parsedMsg = JSON.parse(msg);
				incomingOrders[parsedMsg.tick] = parsedMsg.orders;
				if(parsedMsg.playersLeft)
					playerLefts[parsedMsg.tick] = parsedMsg.playersLeft;
				
			} catch (e) {
				console.log("main thread error parsing orders msg");
			}
		}
	}
}

function generatePlayerWindow(playerName, htmlStr)
{
	uimanager.playerInfoWindow.setTitle("<font style='color: rgb(255, 248, 57);'>Player " + playerName + "</font>", getPlayerTopRiders(playerName));
	$('#riderDiv').empty();
	var riders = getPlayerNavRiders(playerName);
	//console.log(riders);
	$('#riderDiv').html(riders);
	$('#addScrollableSubDivTextArea').html(htmlStr);
	fadeIn($('#playerInfoWindow'));
}

function hideChat()
{
	$('#lobbyGameChatInput')[0].style.visibility = 'hidden';
	$('#lobbyChatInput')[0].style.visibility = 'hidden';
}

function setChatFocus(show)
{
	$('#lobbyGameChatInput')[0].style.visibility = (show || lobbyPlayerManager.singlePlayerMode) ? 'hidden' : 'visible';
	$('#lobbyChatInput')[0].style.visibility = (!show) ? 'hidden' : 'visible';
	if (show)
	{
		$('#lobbyChatInput')[0].focus();
	}
	else
	{
		$('#lobbyGameChatInput')[0].focus();
	}
}

function resolveLocationString(locationID)
{
    locationID = parseInt(locationID);
	const separator = " ( ";
	const close = " )"
    switch (locationID)
    {
        case 0:
            return separator + "lobby" + close;
        case 1:
            return separator + "editor" + close;
        case 2:
            return separator + "ranked" + close;
        case 3:
            return separator + "match" + close;
        case 4:
            return separator + "map lobby" + close;
        case 5:
            return separator + "cpu match" + close;
        default:
            return separator + "?" + close;
    }
}

function currencyFormatter(currency)
{
    for (let i = currency.length -3; i > 0; i-=3)
    {
        currency = currency.slice(0, i) + "," + currency.slice(i , currency.length)
    }
    return currency;
}

function updateFriendsPendingIcon(hasPending)
{
	if (hasPending) {
		$('#friendsButton').css('background-image', 'url("imgs/m_friends_active.png")');
	}
	else {
		$('#friendsButton').css('background-image', 'url("imgs/m_friends.png")');
	}
}

function tryShowChangeLog()
{
	var dontShowChangeLog = getCookieValue(document.cookie, `shownLog`) == `${GAME_VERSION}`;
	if (!dontShowChangeLog)
	{
		fadeIn($('#versionInfo'));
		var in90Days = getGMTDateString4Days(90);
		document.cookie = `shownLog=${GAME_VERSION}; expires=${in90Days}`;
	}
}

function addLoginButton(buttonName, str, clearCookies)
{
	// if (clearCookies)
	// {
	// 	document.cookie = "pw=\"\"";
	// 	document.cookie = "username=\"\"";
	// }
	const logOutFunc = function() {
		soundManager.playSound(SOUND.CLICK);
		game_state = GAME.LOGIN;
		createLoginView();
		showPlayerInfo(false);
	};
	var button = $(`#${buttonName}`)[0];
	if (!button)
	{
		$('#accInfoTopDiv').append(uimanager.createButton(buttonName, str, logOutFunc));
	}
	else
	{
		document.querySelector(`#${buttonName}`).innerHTML = str;
		document.querySelector(`#${buttonName}`).onclick = logOutFunc;
	}
	// $(`#${buttonName}`)[0].style.bottom = '-25px';
	// $(`#${buttonName}`)[0].style.position = 'relative';
}


Network.prototype.send = function(data)
{
	if(this.connected && this.socket)
	{
		this.socket.send(data);
		return;
	}

	//(id, condition, closeable, title, draggable, onKey)
	var optionsWindow = new UIWindow("NoConnectionWindow", function(){ return true; }, false, "Connection Error", false);
	elements.push(optionsWindow);
	console.log("No connection.");
	if (!this.socket)
	{
		console.log("Websocket failed. Does your browser support it?");
		$('#NoConnectionWindow')[0].innerHTML = "Establishing Websocket failed. Does your browser support it?";
	}
	else if (!this.connected)
	{
		console.log("Websocket success. Could not connect to server. Try again later.");
		$('#NoConnectionWindow')[0].innerHTML = "Establishing Websocket: success. Could not connect to server. Try again later.";
	}
	else
	{
		console.log("Websocket Success. Connected. Send Failed.");
		$('#NoConnectionWindow')[0].innerHTML = "Websocket Success. Connected. Failed to send message to server.";
	}
};

// GUI Logic
Network.prototype.createPlayerNode = function(p)
{
	var div = document.createElement("div");
	div.id = "playerList_" + p.name;
	div.className = "playerContainer" + (($('#playerSearchInput').val() != "filter players" && p.name.toLowerCase().indexOf($('#playerSearchInput').val()) == -1) ? " invis" : "");
	
	div.appendChild(this.getClanLink(p));
	div.appendChild(this.getPlayerLink(p));
	
	var span = document.createElement("span");
	span.id = "playerLocation_" + p.name;
	span.className = "lobbyLabel";
	span.innerHTML = resolveLocationString(p.location);
	div.appendChild(span);
	
	return div;
};

Network.prototype.getClanLink = function(p, noID)
{
	var span = document.createElement("span");
	span.id = noID ? "" : ("playerLocationClan_" + p.name);
	span.innerHTML = (p.clan && p.clan.length > 0) ? "[<a href='#' onclick='getClanInfo(\"" + p.clan + "\");' class='clanLink'>" + p.clan + "</a>] " : "";
	return span;
};

Network.prototype.getPlayerLink = function(p)
{
	if(p.name == "Server")
	{
		var el = document.createElement("span");
		el.innerHTML = "Server";
		return el;
	}
	
	var link = document.createElement("a");
	link.innerHTML = p.name;
	link.className = (p.name != "Server" ? ((p.premium && p.authLevel < AUTH_LEVEL.MOD) ? "playerLinkPremium" : auth_level_css_classes[p.authLevel]) : "") + " playerNameInList";
	link.href = "#";
	
	if(p.name != "Server" && (p.name != networkPlayerName || p.authLevel >= AUTH_LEVEL.PLAYER))
		link.onclick = p.authLevel >= AUTH_LEVEL.PLAYER ? function(){ soundManager.playSound(SOUND.CLICK); network.send("get-player-info<<$" + p.name); } : function(){ openQueryWindowFor(p.name); };
	
	return link;
};

Network.prototype.refreshPlayerWindow = function(x)
{
	$('#playersWindowTextArea').html("");
	
	// refresh title, so it shows the total player count
	$('#playersWindow')[0].getElementsByTagName('h2')[0].innerHTML = "&raquo; Players (" + _.size(this.players) + ")";
	
	_.each(alphabetizePlayers(this.players), function(p){
		$('#playersWindowTextArea').append(network.createPlayerNode(p));
	});
};
// just a "static js-class" (HA-HA) that has some image transform methods
function ImageTransformer()
{
	
};

// return a greyscaled version of a given image
ImageTransformer.getGreyScaledImage = function(img)
{
	var canv = document.createElement('canvas');
	canv.height = img.height;
	canv.width = img.width
	var ctx = canv.getContext('2d');
	
	ctx.drawImage(img, 0, 0);
	
	var imgData = ctx.getImageData(0, 0, canv.width, canv.height);
    
	for(var i = 0; i < imgData.data.length; i += 4)
	{
		var newValue = (imgData.data[i] + imgData.data[i + 1] + imgData.data[i + 2]) / 3;
		imgData.data[i] = newValue;
		imgData.data[i + 1] = newValue;
		imgData.data[i + 2] = newValue;
	}
	
    ctx.putImageData(imgData, 0, 0);
    
    return canv;
};

// returns a image with some colors replaced, specified by search and replace, which are arrays of color arrays ([[255, 255, 255], [...], ...], )
ImageTransformer.replaceColors = function(img, search, replace)
{
	var canv = new Array(replace.length);
	var imgData = new Array(replace.length);
	
	for(var i = 0; i < replace.length; i++)
	{
		canv[i] = document.createElement('canvas');
		canv[i].height = img.height;
		canv[i].width = img.width
		canv[i].getContext('2d').drawImage(img, 0, 0);
		imgData[i] = canv[i].getContext('2d').getImageData(0, 0, img.width, img.height);
	}
	
	var data0 = imgData[0].data;
	for(var i = 0; i < data0.length; i += 4)
		if(data0[i + 3] > 0)
			for(var k = 0; k < search.length; k++)
				if(data0[i] == search[k][0] && data0[i + 1] == search[k][1] && data0[i + 2] == search[k][2])
					for(var j = 0; j < replace.length; j++)
					{
						imgData[j].data[i] = replace[j][k][0];
						imgData[j].data[i + 1] = replace[j][k][1];
						imgData[j].data[i + 2] = replace[j][k][2];
					}
	
	for(var i = 0; i < replace.length; i++)
		canv[i].getContext('2d').putImageData(imgData[i], 0, 0);
	
	return canv;
};

// returns a image with all colors replaced with white
ImageTransformer.replaceColorsWhite = function(img, color)
{
	color = color ? color : [255, 255, 255];
	
	var canv = document.createElement('canvas');
	canv.height = img.height;
	canv.width = img.width
	var ctx = canv.getContext('2d');
	
	ctx.drawImage(img, 0, 0);
	
	var imgData = ctx.getImageData(0, 0, canv.width, canv.height);
    
	for(var i = 0; i < imgData.data.length; i += 4)
		if(imgData.data[i + 3] > 0)
		{
			imgData.data[i] = color[0];
			imgData.data[i + 1] = color[1];
			imgData.data[i + 2] = color[2];
		}
	
    ctx.putImageData(imgData, 0, 0);
    
    return canv;
};

// return the average color of an image (used to get a color to represent the image on the minimap)
ImageTransformer.getAverageColor = function(img)
{
	c2.clearRect(0, 0, img.img.w, img.img.h);
	c2.drawImage(img.file[0], img.img.x, img.img.y, img.img.w, img.img.h, 0, 0, img.img.w, img.img.h);
	var data = c2.getImageData(0, 0, img.img.w, img.img.h).data;
	
	var p = [0, 0, 0];
	var count = 0.01;
	for(var i = 0; i < data.length; i += 4)
		if(data[i + 3] > 0) // if not
		{
			count++;
			for(k = 0; k < 3; k++)
				p[k] += data[i + k];
		}
	
	return "rgba(" + Math.floor(p[0] / count) + ", " + Math.floor(p[1] / count) + ", " + Math.floor(p[2] / count) + ", " + (count / (data.length / 4)) + ")";
};

// returns a canvas based on a spritesheet and coords in the form of {x = 5, y = 8, w = 3, h = 3}
ImageTransformer.getImgFromSheet = function(sheet, coords)
{
	// create new canvas
	var canv = document.createElement('canvas');
	canv.height = coords.h;
	canv.width = coords.w;
	
	// draw image on canvas
	canv.getContext('2d').drawImage(sheet, coords.x, coords.y, coords.w, coords.h, 0, 0, coords.w, coords.h);
	
	return canv;
};
// an UIElement, mostly a HTML Element, with some extra features
function UIElement(type, id, condition, killOnHide, onKey)
{
	this.domElement = document.createElement(type);
	this.domElement.id = id;
	this.domElement.style.visibility = condition ? "hidden" : "visible";;
	
	document.body.appendChild(this.domElement);
	
	this.condition = condition; // function that returns true, if the element should be drawn
	this.wasActiveLastFrame = false;
	this.blocksCanvas = true; // if this is true and the element is active, clicks do not get delegated to the canvas
	this.killOnHide = killOnHide;
	
	this.onKey = onKey;
};

UIElement.prototype.refreshVisibility = function()
{
	if(this.condition())
	{
		if(this.wasActiveLastFrame)
			return this.blocksCanvas;
		
		this.wasActiveLastFrame = true;
		
		if(this.killOnHide)
		{
			this.domElement.style.display = "block";
		}
		else
			this.domElement.style.visibility = "visible";
		
		// if its an inout which gets just active in this frame, set focus to it
		if(this.domElement.tagName == "INPUT")
		{
			this.domElement.focus();
			this.domElement.value = this.domElement.value; // re-set value, so cursor is at the end and not at the beginning
		}
		
		return this.blocksCanvas;
	}
	
	if(!this.wasActiveLastFrame)
		return false;
	
	this.wasActiveLastFrame = false;
	
	if(this.killOnHide)
	{
		this.domElement.style.display = "none";
	}
	else
		this.domElement.style.visibility = "hidden";
	
	return false;
};
// this does represent a game-lobby (uses jquery-UI sorted list element, to sort the players)
LobbyPlayerManager = function()
{
	// buttons to change team and remove player
	this.teamButton = " <button name='teamButton' onclick=increaseTeamCount(this)>Team 1</button>";
	this.killButton = " <button onclick=removeElement(this.parentElement)>X</button>";
	
	// save current map
	this.map = null;
	
	// create the initial div
	this.div = document.createElement('div');
	this.div.id = "playerManagerDiv";
	
	this.singlePlayerMode = true;
	this.globalLobbyPlayerId = 100;
	this.iAmHost = false;
	
	this.playerSettings = null;
	this.cachedPlayerSettings = null;
};

// get position of a player in the player list, return json {list: (1 for players, 2 for specs), pos: position inside the list, starting with 1}
function getPosOfItem(item)
{
	if(item.parentNode.id != 'listSpec')
		return item.parentNode.id.split("list")[1];
	
	var els = $("#listSpec").children();
	for(var i = 0; i <= els.length; i++)
		if(els[i] == item)
			return i + 1 + MAX_PLAYERS;
};
function getNextSpecSlot()
{
	return ($("#listSpec").children() + MAX_PLAYERS) + 1;
}
// adds another cpu player to the lobby (in case of network game, dont do, but send command to the server)
function addCpu()
{
	var freeSlot = -1;
	for(var i = 0; i < MAX_PLAYERS; i++)
		if($("#list" + (i + 1)) && $("#list" + (i + 1)).children().length == 0 && lobbyPlayerManager.playerSettings && lobbyPlayerManager.playerSettings[i] && lobbyPlayerManager.playerSettings[i].slot == "open")
		{
			freeSlot = i + 1;
			i = MAX_PLAYERS;
		}
	
	if(freeSlot == -1)
	{
		bingMsg("No more free player slots", true);
		return;
	}
	
	// if were in multiplayer mode, send msg to server instead of doing it on our own
	if(!lobbyPlayerManager.singlePlayerMode && network && network.socket)
	{
		network.send("add-cpu");
		return;
	}
	
	// check custom ais
	var customAIStr = "";
	if(countCustomAIFunctions > 0)
	{
		var arr = getAINamesArray();
		customAIStr = arr[arr.length - 1];
	}
	
	// create element and put it in the list
	var btn = document.createElement("li");
	btn.className = 'draggable_';
	btn.id = "cmp" + lobbyPlayerManager.globalLobbyPlayerId++;
	btn.setAttribute("name", "Computer");
	btn.innerHTML = "Computer <button name='teamButton' onclick=increaseTeamCount(this)>Team 1</button> <button onclick=removeElement(this.parentElement)>X</button>" + (countCustomAIFunctions > 0 ? " <button onclick=switchAI(this)>" + customAIStr + "</button>" : "");
	
	$("#list" + freeSlot).append(btn);
	$("#list" + freeSlot).sortable("refresh");
	
	soundManager.playSound(SOUND.CLICK);
};

function switchAI(button)
{
	// find next AI name
	var arr = getAINamesArray();
	
	// set new number
	button.innerHTML = arr[(arr.indexOf(button.innerHTML) + 1) % arr.length];
	
	soundManager.playSound(SOUND.CLICK);
};

// remove a player
function removeElement(element)
{
	// if were in multiplayer mode, send msg to server instead of doing it on our own
	if(!lobbyPlayerManager.singlePlayerMode && network && network.socket)
	{
		network.send("kick-player<<$" + getPosOfItem(element));
		return;
	}
	
	element.parentElement.removeChild(element);
	$(".connectedSortable").sortable("refresh");
	
	soundManager.playSound(SOUND.CLICK);
};

// increase the team of a player by 1
function increaseTeamCount(button)
{
	var listID = parseInt(button.parentNode.parentNode.id.split("list")[1]) - 1;
	
	// if fixed team, return and dont change shit
	if(lobbyPlayerManager.playerSettings && lobbyPlayerManager.playerSettings[listID] && lobbyPlayerManager.playerSettings[listID].team != "any")
	{
		bingMsg("The team of this player can't be changed", true);
		return;
	}
	
	// if were in multiplayer mode, send msg to server instead of doing it on our own
	if(!lobbyPlayerManager.singlePlayerMode && network && network.socket)
	{
		if(!lobbyPlayerManager.iAmHost)
			return;
		
		network.send("change-team<<$" + getPosOfItem(button.parentNode));
		return;
	}
	
	var nr = button.innerHTML.slice(5, 6);
	button.innerHTML = "Team " + (nr >= MAX_PLAYERS ? 1 : parseInt(nr) + 1);
	
	soundManager.playSound(SOUND.CLICK);
};

LobbyPlayerManager.prototype.setMap = function(map)
{
	// refresh img
	$('#mapPreviewImg')[0].src = currentMapImg ? currentMapImg : map.img;
	
	// refresh map description
	$('#showMapInfo2').html(map.name + "<br />Size: " + map.x + "x" + map.y + "<br />" + map.countPlayers + " Players<br /><br />" + escapeHtml(map.description.replace(new RegExp("<br />", "gi"), '\n')).replace(/(?:\r\n|\r|\n)/g, '<br />'));
	
	this.map = map;
	this.playerSettings = map.players ? map.players : getDefaultPlayerSettings(map.countPlayers);
	this.setPlayerNumbers();
	
	if(this.cachedPlayerSettings)
		this.refreshFromServer(this.cachedPlayerSettings);
};
function tryRemoveElement(elementID)
{
	var element = document.getElementById(elementID);
	if (element)
	{
		element.parentNode.removeChild(element);
	}
}
LobbyPlayerManager.prototype.setPlayerNumbers = function()
{
	console.log("lobbyPlayerManager setPlayerNumbers()");
	// ****************
	// Kind of a hack until all this raw html str stuff is rewritten and managable
	for(var i = 0; i < MAX_PLAYERS; i++)
	{
			tryRemoveElement("list" + (i + 1));
	}
	tryRemoveElement("listSpec");
	tryRemoveElement("addCpuButton");
	tryRemoveElement("moveMeToSpecButton");
	// *****************


	// Add coloured numbers
	console.log(`Player settings: ${this.playerSettings.length} => ${this.playerSettings}`);
	var str = "";
	for(var i = 0; i < this.playerSettings.length; i++)
		if(this.playerSettings[i].slot == "open" || this.playerSettings[i].slot == "computer")
			str += "<p style='color: rgb(" + playerTextColors[i + 1][0] + ", " + playerTextColors[i + 1][1] + ", " + playerTextColors[i + 1][2] + ");'>" + (i + 1) + ".</p>";
		else
			str += "<p>&nbsp;</p>";
		
	$('#startPosDiv').html(str);
	// Adds selectable lists
	var str = "";
	for(var i = 0; i < MAX_PLAYERS; i++)
	{
		console.log(`Player settings ${i} slotstate: ${this.playerSettings[i].slot}`);
		if(this.playerSettings[i] && (this.playerSettings[i].slot == "open" || this.playerSettings[i].slot == "computer"))
		{
			str += "<ul id='list" + (i + 1) + "' class='connectedSortable activeList' style='top: " + (-2 + (i + 1) * 37)+ "px;'></ul>";
		}
	}
	str += "<ul id='listSpec' class='connectedSortable'></ul><button id='addCpuButton' onclick=addCpu()>add Computer</button>";
	$('#playerManagerDiv')[0].innerHTML += str;
	
	// use jquery ui to make a sortable out of the lists
	$(function(){ $(".connectedSortable").sortable({
		connectWith: ".connectedSortable",
		placeholder: "invis",
		receive: function(event, ui){
			
			var el = ui.item[0];
			var listID = parseInt(el.parentNode.id.split("list")[1]) - 1;
			var sendID = parseInt(ui.sender[0].id.split("list")[1]) - 1;
			
			if(el.parentNode != $("#listSpec")[0] && (!lobbyPlayerManager.playerSettings || !lobbyPlayerManager.playerSettings[listID] || lobbyPlayerManager.playerSettings[listID].slot != "open"))
				$(ui.sender).sortable('cancel');
			
			if((!lobbyPlayerManager.playerSettings || !lobbyPlayerManager.playerSettings[sendID] || lobbyPlayerManager.playerSettings[sendID].slot == "computer") && ui.sender[0] != $("#listSpec")[0])
			{
				bingMsg("This slot can't be changed", true);
				$(ui.sender).sortable('cancel');
			}
			
			if($("#listSpec").children().length > 4)
			{
				bingMsg("Max 4 Spectators", true);
				$(ui.sender).sortable('cancel');
			}
			
			if(el.parentNode == $("#listSpec")[0] && el.id.slice(0, 1) == "c")
			{
				bingMsg("Computer Players can't be Spectators", true);
				$(ui.sender).sortable('cancel');
			}
			
			// if more then one element, switch
			if($(el.parentNode).children().length > 1 && el.parentNode != $("#listSpec")[0])
			{
				if(ui.sender[0] == $("#listSpec")[0])
					$(ui.sender).sortable('cancel');
				
				else
					$(el.parentNode).children().each(function(index, child){ 
					    if(child != el)
					    	$(child).detach().appendTo(ui.sender);
					});
			}
			
			lobbyPlayerManager.checkTeams();
			
		},
		
		stop: function(event, ui){
			
			var el = ui.item[0];
				
			// if mp, dont do the action, but only send info to server
			if(!lobbyPlayerManager.singlePlayerMode && network && network.socket)
				network.send("move-player<<$" + el.getAttribute('pos') + "<<$" + getPosOfItem(el));
		}
		
	}).disableSelection(); });
	
	this.setHost(this.iAmHost);
	// Don't allow use of this slot if it's computer-only
	for(var i = 0; i < this.playerSettings.length; i++)
		if(this.playerSettings[i] && this.playerSettings[i].slot == "computer")
			$('#list' + (i + 1)).sortable("disable");

	var moveMeToSpecButton = new UIElement("button", "moveMeToSpecBtn");
	$('#playerManagerDiv')[0].appendChild($("#moveMeToSpecBtn")[0]);
	$("#moveMeToSpecBtn")[0].innerHTML = "Spectate";
	$("#moveMeToSpecBtn")[0].onclick = function(){
		const slotId = getNextSpecSlot();
		if (slotId >= 4)
		{
			bingMsg("No more free player slots", true);
		}
		else
		{
			network.send("move-player-to-spec");
		}
		soundManager.playSound(SOUND.CLICK);
	};
}

// init the lobby for a single player match
LobbyPlayerManager.prototype.init = function(multiplayer, map, isHost)
{
	this.cachedPlayerSettings = null;
	this.map = null;
	
	// set some variables
	this.singlePlayerMode = !multiplayer;
	setChatFocus(false)
	this.setHost(isHost || !multiplayer);
	
	$('#playerManagerDiv').html("<div id='startPosDiv'></div><p id='playersLabel'>Players</p><p id='spectatorsLabel'>Spectators</p>");
	
	if(map)
	{
		this.playerSettings = map.players ? map.players : getDefaultPlayerSettings(map.countPlayers);
		this.setPlayerNumbers();
		
		// Finds the first open slot to add us to
		var added = false;
		for(var i = 0; i < this.playerSettings.length; i++)
			if(this.playerSettings[i].slot == "open")
			{
				$('#list' + (i + 1)).html("<li id='pl1' name='" + networkPlayerName + "' pos='" + (i + 1) + "' class='draggable_'>" + networkPlayerName + this.teamButton + "</li>");
				i = this.playerSettings.length;
				added = true;
			}
		
		if(!added)
			$('#listSpec').html("<li id='pl1' name='" + networkPlayerName + "' class='draggable_'>" + networkPlayerName + this.teamButton + "</li>");
		
		// check custom ais
		var customAIStr = "";
		if(countCustomAIFunctions > 0)
		{
			var arr = getAINamesArray();
			customAIStr = arr[arr.length - 1];
		}
		
		// put cpus in cpu only slots
		for(var i = 0; i < this.playerSettings.length; i++)
			if(this.playerSettings[i].slot == "computer")
				$('#list' + (i + 1)).html("<li id='cmp" + i + "' name='Computer' class='draggable_'>Computer <button name='teamButton' onclick=increaseTeamCount(this)>Team 2</button>" + ((countCustomAIFunctions > 0 && !multiplayer) ? " <button onclick=switchAI(this)>" + customAIStr + "</button>" : "") + "</li>");
		
		if(!multiplayer)
		{
			// fill free spots with cpu players
			for(var i = 0; i < MAX_PLAYERS; i++)
				if($('#list' + (i + 1)) && $('#list' + (i + 1)).html() == "" && this.playerSettings[i].slot == "open")
					$('#list' + (i + 1)).html("<li id='cmp" + i + "' name='Computer' class='draggable_'>Computer <button name='teamButton' onclick=increaseTeamCount(this)>Team 2</button>" + this.killButton + (countCustomAIFunctions > 0 ? " <button onclick=switchAI(this)>" + customAIStr + "</button>" : "") + "</li>");
		}
		
		lobbyPlayerManager.checkTeams();
	}
	
	if(map)
	{
		$('#mapPreviewImg')[0].src = currentMapImg ? currentMapImg : map.img;
		$('#showMapInfo2').html(map.name + "<br />Size: " + map.x + "x" + map.y + "<br />" + map.countPlayers + " Players<br /><br />" + escapeHtml(map.description.replace(new RegExp("<br />", "gi"), '\n')).replace(/(?:\r\n|\r|\n)/g, '<br />'));
		this.map = map;
	}
	else
	{
		$('#mapPreviewImg')[0].src = "";
		$('#showMapInfo2').html("downloading map...");
	}
};

LobbyPlayerManager.prototype.checkTeams = function(host)
{
	// set team in case of restricted team
	if(this.playerSettings)
		for(var i = 0; i < this.playerSettings.length; i++)
			if(this.playerSettings[i].team != "any" && $('#list' + (i + 1))[0])
			{
				var team = parseInt(this.playerSettings[i].team.split("Team ")[1]);
				
				if(!(team >= 1 && team <= MAX_PLAYERS))
					team = 1;
				
				var buttons = $('#list' + (i + 1))[0].getElementsByTagName('button');
				if(buttons && buttons[0])
					buttons[0].innerHTML = "Team " + team;
			}
}

LobbyPlayerManager.prototype.setHost = function(host)
{
	// set lists modifiable, only if were the host
	if(host)
	{
		if($(".connectedSortable").length > 0)
			$(".connectedSortable").sortable("enable");
		this.iAmHost = true;
	}
	else
	{
		if($(".connectedSortable").length > 0)
			$(".connectedSortable").sortable("disable");
		this.iAmHost = false;
	}
	if ($("#addCpuButton")[0])
	{
		$("#addCpuButton")[0].style.visibility = this.iAmHost ? 'visible' : 'hidden';
	}
};

// refresh the lobby from a json-obj sent from the server
LobbyPlayerManager.prototype.refreshFromServer = function(obj)
{
	console.log('trying refresh from server...');
	if(!this.map)
	{
		this.cachedPlayerSettings = obj;
		return;
	}
	console.log(`refreshing with ${obj}`);
	
	$('.connectedSortable').empty();
	
	for(var i = 0; i < obj.length; i++)
	{
		var p = obj[i];
		var listToAdd = $("#" + (p.controller == CONTROLLER.SPECTATOR ? "listSpec" : ("list" + p.nr)));
		
		var li = document.createElement('li');
		li.className = "draggable_";
		li.setAttribute('pos', p.nr ? p.nr : listToAdd.children().length);
		li.id = (p.controller == CONTROLLER.COMPUTER ? "cmp" : "pl") + lobbyPlayerManager.globalLobbyPlayerId++;
		li.setAttribute("name", p.name);
		var killable = this.iAmHost && p.name != networkPlayerName && (p.controller == CONTROLLER.SPECTATOR || (this.playerSettings && this.playerSettings[p.nr - 1] && this.playerSettings[p.nr - 1].slot == "open"));
		li.innerHTML = p.name + " <button name='teamButton' onclick=increaseTeamCount(this)>Team " + p.team + "</button>" + (killable ? "<button onclick=removeElement(this.parentElement)>X</button>" : "");
		
		// add element to according list
		listToAdd.append(li);
	}
	
	// refresh both lists
	$(".connectedSortable").sortable("refresh");
	
	// play sound
	soundManager.playSound(SOUND.CLICK);
};

// returns an array of json objects (one for each player) containing the information of all player in the lobby; the return value is usually passed to the game.loadMap() method, so the game knows which players it has to initialize
LobbyPlayerManager.prototype.getPlayerSettingsArrayObject = function()
{
	var returnVal = [];
	
	// iterate through the players list
	var els = $(".connectedSortable").children();
	for(var i = 0; i < els.length; i++)
	{
		var ctrl = els[i].id.slice(0, 2) == "pl" ? CONTROLLER.HUMAN : CONTROLLER.COMPUTER;
		if(els[i].parentNode == $("#listSpec")[0])
			var ctrl = CONTROLLER.SPECTATOR;
		
		var o = {
			name: els[i].getAttribute("name"),
			controller: ctrl,
			nr: getPosOfItem(els[i]),
			team: els[i].getElementsByTagName('button')[0].innerHTML.slice(5, 6),
			isPlayingPlayer: els[i].id.slice(0, 2) == "pl"
		};
		
		if(o.controller == CONTROLLER.COMPUTER && els[i].getElementsByTagName('button')[2])
		{
			var arr = getAINamesArray();
			o.ai_index = arr.indexOf(els[i].getElementsByTagName('button')[2].innerHTML) - 1;
		}
		
		returnVal.push(o);
	}
	
	return returnVal;
};
var elements = [];
// manages all the HTML UIElements; constructor creates everything
function UIManager()
{
	var pleaseNoAdblockDiv = new UIElement("div", "pleaseNoAdblockDiv", function(){ return game_state == GAME.LOBBY || game_state == GAME.LOGIN || game_state == GAME.REGISTER || game_state == GAME.RECOVERY; });
	$('#pleaseNoAdblockDiv').html("Please disable adblock for Littlewargame.com. The money from the ad helps us to run the game. Also, there is only one ad (right here where this text is) on the whole page, and we promise it's really not annoying.");
	
	// ads
	var adsenseDiv = new UIElement("div", "div-gpt-ad-1571242603068-0", function(){ return game_state == GAME.LOBBY || game_state == GAME.LOGIN || game_state == GAME.REGISTER || game_state == GAME.RECOVERY; });
	$('#div-gpt-ad-1571242603068-0').html("<script>googletag.cmd.push(function() { googletag.display('div-gpt-ad-1571242603068-0'); });</script></div>");
	
	
	this.hasActiveElements = false;
	
	this.queries = [];
	
	/* 
	* Win / Loss Window
	*/
	this.winLossWindow = new UIWindow("winLossWindow", function(){ return game && game.gameHasEnded && game_state == GAME.PLAYING; }, true, "Game Statistics", true);
	this.winLossWindow.addScrollableSubDiv("winLossTextArea");

	var quitLogo = document.createElement('img');
	quitLogo.id = "quitLogo";
	quitLogo.src = "imgs/Logo.png";
	quitLogo.className = "quitLogo";
	$('#winLossWindow').append(quitLogo);

	// Quit Game Button
	$('#winLossWindow').append(this.createButton("winLossWindowQuitButton", "Quit", function(){
		
		game.refreshReplayButtonVisibleState();
		worker.postMessage({what: "end-game"});
		
		// if map data is set, were started from editor, so we go back now to the editor and load the map data
		if(mapData)
		{
			$('#lobbyGameChatInput')[0].style.visibility = 'hidden';
			$('#lobbyChatInput')[0].style.visibility = 'hidden';
			// show loading screen
			uimanager.showLoadingScreen();
			
			setTimeout(function(){
				game_state = GAME.EDITOR;
				game = new Game();
				game.loadMap(mapData, null, null, null, true);
				worker.postMessage({what: "start-game", editorLoad: true, map: mapData, network_game: network_game, game_state: game_state, networkPlayerName: networkPlayerName});
			}, 50);
		}
		
		else
		{
			reloadLobby();
			
			network_game = false;
			
			
			keyManager.resetCommand();
			
			setTimeout(function(){ showAchivement(); }, 2000);
		}
		
		soundManager.playSound(SOUND.CLICK);
		
	}));
	
	
	
	
	/* 
	* Statistics Window
	*/
	this.statisticsWindow = new UIWindow("statisticsWindow", function(){ return true; }, true, "Game Statistics", true);
	this.statisticsWindow.addScrollableSubDiv("statisticsTextArea");
	
	// show points div
	var showLadderPointsDiv = document.createElement("div");
	showLadderPointsDiv.id = "showLadderPointsDiv";
	showLadderPointsDiv.title = "Ladder points determinate your rank in your division. You win ladder points for victories in matchmaking games and lose ladder points for losses in matchmaking games.";
	$('#statisticsWindow').append(showLadderPointsDiv);
	
	// Save Replay Button
	$('#statisticsWindow').append(this.createButton("saveReplayButton", "Save Replay", function(){
		var blob = new Blob([game.getReplayFile()], {type: "text/plain;charset=utf-8"});
		saveAs(blob, game.getReplayName() + ".json");
		soundManager.playSound(SOUND.CLICK);
	}));
	
	
	
	/*
	 * chat history window
	 */
	var chatHistoryWindow = new UIWindow("chatHistoryWindow", function(){ return true; }, true, "Chat History");
	chatHistoryWindow.addScrollableSubDiv("chatHistorytextContainer");
	
	
	
	
	/*
	 * Lobby div (invis, holds all teh elements)
	 */
	var lobbyDiv = new UIElement("div", "lobbyDiv", function(){ return game_state == GAME.LOBBY && network.connected && !network.game.id; });
	
	/*
	 * lobby chat window
	 */
	var lobbyChatWindow = new UIWindow("lobbyChatWindow", null, false, "Chat");
	lobbyChatWindow.addScrollableSubDiv("lobbyChatTextArea");
	$('#lobbyDiv').append(lobbyChatWindow.domElement);
	
	/*
	 * lobby game chat window (when opened a game)
	 */
	var lobbyGameChatWindow = new UIWindow("lobbyGameChatWindow", function(){ return game_state == GAME.LOBBY && network.connected && network.game.id; }, false, "Chat");
	lobbyGameChatWindow.addScrollableSubDiv("lobbyGameChatTextArea");
	//$("#skirmishWindow").append(lobbyGameChatWindow);

	/*
	 * lobby games window
	 */
	var gamesWindow = new UIWindow("gamesWindow", null, false, "Games");
	gamesWindow.addScrollableSubDiv("gamesWindowTextArea");
	$('#lobbyDiv').append(gamesWindow.domElement);
	
	// set gamez window title
	$('#gamesWindow').children('h2').prop('title', 'Here you can see all currently played multiplayer games. Click on a game to join it. You can only join games, that are not running.');
	
	/*
	 * lobby players window
	 */
	var playersWindow = new UIWindow("playersWindow", null, false, "Players");
	playersWindow.addScrollableSubDiv("playersWindowTextArea");
	$('#lobbyDiv').append(playersWindow.domElement);
	
	// set players window title special class (needs to be smaller than other titles because of search input)
	$('#playersWindow').children('h2')[0].className = "windowTitle2";
	
	// player search field
	var playerSearchInput = document.createElement("input");
	playerSearchInput.type = "text";
	playerSearchInput.id = "playerSearchInput";
	playerSearchInput.value = "filter players";
	playersWindow.domElement.appendChild(playerSearchInput);
	playerSearchInput.onkeyup = function()
	{
		var els = $('#playersWindowTextArea').children();
		const inputName = $('#playerSearchInput').val().toLowerCase();
		for(var i = 0; i < els.length; i++)
		{
			const isName = els[i].id.split("playerList_")[1].toLowerCase().indexOf(inputName);
			// If it's not the default text value && matches the name
			if($('#playerSearchInput').val() != "filter players" && isName == -1)
				$(els[i]).addClass("invis");
			else
				$(els[i]).removeClass("invis");
		}
	};
	playerSearchInput.onfocus = function()
	{
		if(this.value == 'filter players')
			this.value = '';
	};
	playerSearchInput.onblur = function()
	{
		if(this.value == '')
			this.value = 'filter players';
	};
	
	/*
	 * lobby chat input
	 */
	var lobbyChatInput = document.createElement("input");
	lobbyChatInput.id = "lobbyChatInput";
	lobbyChatInput.type = "text";
	lobbyChatInput.maxLength = 250;
	
	var lobbyInput = new UIElement("div", "lobbyInput", function(){ return game_state == GAME.LOBBY; });
	$('#lobbyInput').append(lobbyChatInput);
	/*
	 * match lobby chat input
	 */
	var lobbyGameChatInput = document.createElement("input");
	lobbyGameChatInput.id = "lobbyGameChatInput";
	lobbyGameChatInput.type = "text";
	lobbyGameChatInput.maxLength = 250;
	
	var lobbyGameInput = new UIElement("div", "lobbyGameInput", function(){ return false; });
	$('#lobbyGameInput').append(lobbyGameChatInput);
	// bind input to send text on enter
	const chatFunction = function(e){
		
		if(keyManager.getKeyCode(e) == KEY.ENTER && network.connected && this.value.length > 0)
		{
			if(this.value == "/ping")
				timeOfLastPingSent = Date.now();
			
			if(this.value.substr(0, 6) == "/stats")
			{
				var name = this.value.split(" ")[1].toLowerCase();
				var types_ = basicUnitTypes.concat(basicBuildingTypes, basicCommands, basicModifiers, basicUpgrades);
				var fieldTypes = unit_fields.concat(building_fields, ability_fields, upgrade_fields, modifiers_fields);
				var found = false;
				
				for(var i = 0; i < types_.length; i++)
					if(types_[i].name.toLowerCase() == name)
					{
						var fields_ = ["cost", "hp", "mana", "supply", "movementSpeed", "weaponCooldown", "dmg", "armor", "buildTime", "manaCost", "aoeRadius"];
						
						var div = document.createElement("div");
						var str = "<p>Stats for <span style='color: #FFFD92;'>" + types_[i].name + "</span>";
						
						for(var k = 0; k < fields_.length; k++)
							if(types_[i][fields_[k]])
							{
								var val = Object.prototype.toString.call(types_[i][fields_[k]]) === '[object Array]' ? types_[i][fields_[k]][0] : types_[i][fields_[k]];
								
								if(val)
								{
									for(var j = 0; j < fieldTypes.length; j++)
										if(fieldTypes[j].name == fields_[k] && fieldTypes[j].displayScale)
										{
											val *= fieldTypes[j].displayScale;
											j = fieldTypes.length;
										}
									
									str += "<p>" + fields_[k] + ": " + val + "</p>";
								}
							}
						
						div.innerHTML = str;
						addToChatWindow(div);
						
						found = true;
					}
				
				if(!found)
				{
					var p = document.createElement("p");
					p.innerHTML = "Sorry, " + name + " not found";
					addToChatWindow(p);
				}
			}
			
			else if(this.value == "/help" || this.value == "/man" || this.value == "/info")
			{
				var div = document.createElement("div");
				var str = "<p><span style='color: #FFFD92;'>Chat commands:</span>";
				str += "<p><span class='lcg_command'>[/ping]</span> send a ping command to the server and see how good your connection is</p>";
				str += "<p><span class='lcg_command'>[/stats]</span> get stats for a specific unit, building, ability or upgrade (for example: '/stats soldier')</p>";
				str += "<p><span class='lcg_command'>[/ignore]</span> ignore a player (for example '/ignore player123')</p>";
				str += "<p><span class='lcg_command'>[/unignore]</span> unignore a player (for example '/unignore player123')</p>";
				str += "<p><span class='lcg_command'>[/ignorelist]</span> show your current ignorelist</p>";
				str += "<p><span class='lcg_command'>[/lcg help]</span> show info about Littlechatgame, a small game you can play in the lobby chat</p>";
				div.innerHTML = str;
				addToChatWindow(div);
			}
			
			else if(this.value == "/ignorelist")
				addChatMsg("Server", "Your ignore list: " + ignores.join(", "));
			
			else if(this.value.substr(0, 8) == "/ignore ")
				network.send("ignore<<$" + this.value.split(" ")[1]);
			
			else if(this.value.substr(0, 10) == "/unignore ")
				network.send("unignore<<$" + this.value.split(" ")[1]);
			
			else if((this.value == "/bigeval" || this.value == "/evaldiv") && iAmAdmin)
				$('#evalDiv').css("display", "inline");
			
			else if(this.value == "/lcg help" || this.value == "/lcg man" || this.value == "/lcg info" || this.value == "/lch help" || this.value == "/lch man" || this.value == "/lch info")
			{
				var div = document.createElement("div");
				var str = "<p><span style='color: #FFFD92;'>Littlechatgame</span> is a game taking place in lobby chat. Send an army of unit-emotes to fight an opponent. Comands:</p><p><span class='lcg_command'>[/lcg fight]</span>";
				str += " Send your army into battle. Type '/lcg fight' followed by the emotes you want to send, for example '/lcg fight Catapult Archer Soldier Soldier'. ";
				str += "Valid emotes / units: Soldier, Archer, Wolf, Mage, Priest, Werewolf, Catapult, Ballista, Dragon, Worker. ";
				str += "You can only send emotes that you have unlocked. The emotes you type first will stand in the back and the emotes you type last will stand in the front in battle. Your army can consist of max 16 supply of units. ";
				str += "<p><span class='lcg_command'>[/lcg stats]</span> Get Littlechatgame related stats for a player. Example: '/lcg stats player123'</p>";
				str += "<p><span class='lcg_command'>[/lcg top]</span> Get a list of the top ranked lcg players</p>";
				str += "<p><span class='lcg_command'>[/lcg units]</span> Get information on all the available units / emotes</p>";
				str += "<p><span class='lcg_command'>[/lcg volume]</span> Set the sound volume for lcg sounds. By default, this is 0 (no sound). If you want to hear lcg sound effects, set it higher than 0. The max volume is 100. Example: '/lcg volume 50'</p>";
				div.innerHTML = str;
				addToChatWindow(div);
			}
			
			else if(this.value == "/modstuff" && (iAmMod || iAmAdmin))
			{
				var div = document.createElement("div");
				var str = "<p><span style='color: #FFFD92;'>Mod commands:</span></p>";
				str += "<p><span class='lcg_command'>[/killgame]</span> kill a running game (for example when an offensive name is used). Type '/killgame' followed by the index of the game (beginning with 0 !!!), for example '/killgame 2' would kill the 3rd game in the list. It is possible to kill multiple games at once by typing for example '/killgame 0 3 4'</p>";
				if(iAmMod2 || iAmAdmin)
					str += "<p><span class='lcg_command'>[/reward]</span> give gold to a player. Type '/reward' followed by the name of the player and then the amount of gold to reward, for example '/reward mage 2000'. Rewards can not be higher than 10000. Player will see popup notification (if he is online).</p>";
				str += "<p><span class='lcg_command'>[/killmap]</span> delete a map (for example when using offensive content or name). Type '/killmap' followed by the name of the map, for example '/killmap la petite (deleted maps are not entirely deleted, theres still a backup stored, so no worries if you misstype or something, it can always be restored)</p>";
				str += "<p><span class='lcg_command'>[/plinfo]</span> shows some information about a player. Works on guests, too (for example '/plinfo player123')</p>";
				div.innerHTML = str;
				addToChatWindow(div);
			}
			
			else if(this.value.substr(0, 12) == "/lcg volume " || this.value.substr(0, 12) == "/lch volume ")
			{
				var volume = parseInt(this.value.substr(12));
				
				if(isNaN(volume))
					volume = 0;
				
				if(volume < 0)
					volume = 0;
				
				if(volume > 100)
					volume = 100;
				
				globalSoundModifierDefault = volume / 100;
				writeCookie();
				
				var p = document.createElement("p");
				p.innerHTML = "lcg sound volume has been set to " + volume;
				addToChatWindow(p);
			}
			
			else
				network.send("chat<<$" + this.value);
			
			this.value = "";
		}
		
		/*
		if(keyManager.getKeyCode(e) == KEY.DOWN || keyManager.getKeyCode(e) == KEY.UP)
		{
			var children = $('#nameSuggestDiv').children();
			
			var k = 0;
			for(var i = 0; i < children.length; i++)
				if($(children[i]).hasClass("suggestedNameActive"))
				{
					k = i;
					$(children[i]).removeClass("suggestedNameActive");
					i = children.length;
				}
			
			if(keyManager.getKeyCode(e) == KEY.UP)
			{
				k--;
				if(k < 0)
					k = children.length - 1;
			}
			else if(keyManager.getKeyCode(e) == KEY.DOWN)
			{
				k++;
				if(k >= children.length)
					k = 0;
			}
			
			var name = "";
			for(var i = 0; i < children.length; i++)
				if(i == k)
				{
					name = $(children[i]).html();
					$(children[i]).addClass("suggestedNameActive");
					i = children.length;
				}
			
			var selectionStart = this.selectionStart;
			
			var val = this.value.split(" ");
			val.splice(-1, 1);
			this.value = val.join(" ") + " " + name;
			this.setSelectionRange(selectionStart, this.value.length);
			
			soundManager.playSound(SOUND.CLICK2);
			
			e.preventDefault();
			return false;
		}
		*/
		
	};
	lobbyChatInput.onkeydown = chatFunction;
	lobbyGameChatInput.onkeydown = chatFunction;
	/*
	lobbyChatInput.onkeypress = function(e){
		
		if(keyManager.getKeyCode(e) == KEY.DOWN || keyManager.getKeyCode(e) == KEY.UP)
		{
			e.preventDefault();
			return false;
		}
		
	};
	
	lobbyChatInput.onkeyup = function(e){
		
		if(keyManager.getKeyCode(e) == KEY.DOWN || keyManager.getKeyCode(e) == KEY.UP)
		{
			e.preventDefault();
			return false;
		}
		
		if(keyManager.getKeyCode(e) != KEY.ENTER && keyManager.getKeyCode(e) != KEY.BACKSPACE && this.value.length > 2)
		{
			var val = this.value;
			
			if(this.selectionStart != this.selectionEnd && this.selectionEnd == this.value.length)
				val = val.substr(0, this.selectionStart);
			
			var lastWord = val.split(" ").pop();
			
			if(lastWord.length > 2)
			{
				lastWord = lastWord.toLowerCase();
				
				var names = Object.keys(network.players);
				var fittingNames = [];
				var fittingNamesRaw = [];
				
				var k = 0;
				for(var i = 0; i < names.length && k < 10; i++)
					if(names[i].substr(0, lastWord.length).toLowerCase() == lastWord && lastWord.length != names[i].length)
					{
						fittingNamesRaw.push(names[i]);
						fittingNames.push("<p class='suggestedName " + (k == 0 ? " suggestedNameActive " : "") + " ' onclick='insertName(this.innerHTML);'>" + names[i] + "</p>");
						k++;
					}
				
				if(k > 0)
				{
					$('#nameSuggestDiv').html(fittingNames.join(""));
					$('#nameSuggestDiv')[0].style.display = "inline";
					
					var oldLen = val.length;
					this.value = val + fittingNamesRaw[0].substr(lastWord.length);
					this.setSelectionRange(oldLen, this.value.length); 
				}
				else
					$('#nameSuggestDiv')[0].style.display = "none";
			}
			else
				$('#nameSuggestDiv')[0].style.display = "none";
		}
		else
			$('#nameSuggestDiv')[0].style.display = "none";
		
	};
	*/
	
	lobbyChatInput.onfocus = function(e){
		if(this.value == "enter text to chat")
			this.value = "";
	};
	
	lobbyChatInput.onblur = function(e){
		if(this.value == "")
			this.value = "enter text to chat";
	};
	
	lobbyChatInput.value = "enter text to chat";
	lobbyGameChatInput.onfocus = function(e){
		if(this.value == "enter text to chat")
			this.value = "";
	};
	
	lobbyGameChatInput.onblur = function(e){
		if(this.value == "")
			this.value = "enter text to chat";
	};
	
	lobbyGameChatInput.value = "enter text to chat";
	
	
	/*
	// name suggest div
	var nameSuggestDiv = document.createElement("div");
	nameSuggestDiv.id = "nameSuggestDiv";
	nameSuggestDiv.className = "ingameWindow";
	$('#lobbyChatWindow').append(nameSuggestDiv);
	*/
	
	
	
	/*
	 * Options Window
	 */
	var optionsWindow = new UIWindow("optionsWindow", function(){ return true; }, true, "Options", true, function(key){
		
		if(key == KEY.N && (game_state == GAME.PLAYING || game_state == GAME.EDITOR))
			$('#optionsQuitButton')[0].click();
		
		if(key == KEY.ESC)
		{
			fadeOut($('#optionsWindow'));
			soundManager.playSound(SOUND.CLICK);
		}
	});
	
	// Buttons at the top
	var optionsButtonsDiv = document.createElement("div");
	optionsButtonsDiv.id = "optionsButtonsDiv";
	$('#optionsWindow').append(optionsButtonsDiv);

	// Toggle options
	var optionsChecklistDiv = document.createElement("div");
	optionsChecklistDiv.id = "optionsChecklistDiv";
	$('#optionsWindow').append(optionsChecklistDiv);

	// Fullscreen Button
	$('#optionsButtonsDiv').append(this.createButton("optionsFullscreenButton", "Fullscreen [<font class='redfont'>F8</font>]", function(){ toggleFullscreen(document.documentElement); }));
	

	// sound volume label
	var soundVolumeLabel = document.createElement("p");
	soundVolumeLabel.id = "soundVolumeLabel";
	soundVolumeLabel.innerHTML = "Sound Effects Volume";
	$('#optionsChecklistDiv').append(soundVolumeLabel);
	
	// sound volume slider
	var optionsSoundButton = document.createElement("div");
	optionsSoundButton.id = "optionsSoundButton";
	$('#soundVolumeLabel').append(optionsSoundButton);
	$("#optionsSoundButton").slider({
		change: function(event, ui){
			sound_volume = ui.value / 100;
			musicManager.setSoundVolume(sound_volume);
			writeCookie();
		},
		value: sound_volume * 100
	});
	
	// music volume label
	var musicVolumeLabel = document.createElement("p");
	musicVolumeLabel.id = "musicVolumeLabel";
	musicVolumeLabel.innerHTML = "Music Volume";
	$('#optionsChecklistDiv').append(musicVolumeLabel);
	
	// music volume slider
	var optionsMusicButton = document.createElement("div");
	optionsMusicButton.id = "optionsMusicButton";
	$('#musicVolumeLabel').append(optionsMusicButton);
	$("#optionsMusicButton").slider({
		change: function(event, ui){
			music_volume = ui.value / 100;
			musicManager.setMusicVolume(music_volume);
			writeCookie();
		},
		value: music_volume * 100
	});
	
	// scroll speed label
	var scrollSpeedLabel = document.createElement("p");
	scrollSpeedLabel.id = "scrollSpeedLabel";
	scrollSpeedLabel.innerHTML = "Scroll Speed";
	$('#optionsChecklistDiv').append(scrollSpeedLabel);
	
	// scroll speed slider
	var scrollSpeedButton = document.createElement("div");
	scrollSpeedButton.id = "scrollSpeedButton";
	$('#scrollSpeedLabel').append(scrollSpeedButton);
	$("#scrollSpeedButton").slider({
		change: function(event, ui){
			scrollSpeed = ui.value * 50;
			writeCookie();
		},
		value: scrollSpeed / 50
	});
	
	// Mouse scroll on off Checkbox
	var scrollLabel = document.createElement("p");
	scrollLabel.id = "scrollLabel";
	scrollLabel.innerHTML = "Enable mouse scroll in non fullscreen mode";
	scrollLabel.title = "When this option is deactivated, the screen will not scroll when you move the cursor to the border of the screen when you are not in fullscreen mode.";
	$('#optionsChecklistDiv').append(scrollLabel);
	
	var scrollCheckbox = document.createElement("input");
	scrollCheckbox.id = "scrollCheckbox";
	scrollCheckbox.type = "checkbox";
	scrollCheckbox.checked = mouse_scroll_when_window_mode;
	scrollCheckbox.onclick = function(){
		mouse_scroll_when_window_mode = this.checked;
		writeCookie();
		soundManager.playSound(SOUND.CLICK);
	};
	$('#scrollLabel').append(scrollCheckbox);
	
	// Middle Mouse invert scroll
	var mmLabel = document.createElement("p");
	mmLabel.id = "mmLabel";
	mmLabel.innerHTML = "Invert middle mouse button scrolling";
	mmLabel.title = "Invert the middle mouse scrolling (you can press and hold middle mouse button ingame to scroll).";
	$('#optionsChecklistDiv').append(mmLabel);
	
	var mmCheckbox = document.createElement("input");
	mmCheckbox.id = "mmCheckbox";
	mmCheckbox.type = "checkbox";
	mmCheckbox.checked = !mmScrollInvert;
	mmCheckbox.onclick = function(){
		mmScrollInvert = !this.checked;
		writeCookie();
		soundManager.playSound(SOUND.CLICK);
	};
	$('#mmLabel').append(mmCheckbox);
	
	// HP bars only when not full hp
	var hpBarsLabel = document.createElement("p");
	hpBarsLabel.id = "hpBarsLabel";
	hpBarsLabel.innerHTML = "Don't show HP bars when full HP";
	hpBarsLabel.title = "Don't show a units' or buildings' HP bar when it has full HP.";
	$('#optionsChecklistDiv').append(hpBarsLabel);
	
	var hpBarsCheckbox = document.createElement("input");
	hpBarsCheckbox.id = "hpBarsCheckbox";
	hpBarsCheckbox.type = "checkbox";
	hpBarsCheckbox.checked = noShowHPBarsWhenFullHP;
	hpBarsCheckbox.onclick = function(){
		noShowHPBarsWhenFullHP = this.checked;
		writeCookie();
		soundManager.playSound(SOUND.CLICK);
	};
	$('#hpBarsLabel').append(hpBarsCheckbox);
	
	// no main manu music
	var noMainMenuMusicLabel = document.createElement("p");
	noMainMenuMusicLabel.id = "noMainMenuMusicLabel";
	noMainMenuMusicLabel.innerHTML = "No menu / lobby music";
	noMainMenuMusicLabel.title = "Don't play music in the menus / lobby.";
	$('#optionsChecklistDiv').append(noMainMenuMusicLabel);
	
	var noMainMenuMusicCheckbox = document.createElement("input");
	noMainMenuMusicCheckbox.id = "noMainMenuMusicCheckbox";
	noMainMenuMusicCheckbox.type = "checkbox";
	noMainMenuMusicCheckbox.checked = noMainMenuMusic;
	noMainMenuMusicCheckbox.onclick = function(){
		noMainMenuMusic = this.checked;
		writeCookie();
		soundManager.playSound(SOUND.CLICK);
	};
	$('#noMainMenuMusicLabel').append(noMainMenuMusicCheckbox);

	// no rain
	var noRainLabel = document.createElement("p");
	noRainLabel.id = "noRainLabel";
	noRainLabel.innerHTML = "No Rain effects";
	noRainLabel.title = "Disable in-game rain effects";
	$('#optionsChecklistDiv').append(noRainLabel);
	
	var noRainCheckbox = document.createElement("input");
	noRainCheckbox.id = "noRainCheckbox";
	noRainCheckbox.type = "checkbox";
	noRainCheckbox.checked = noRain;
	noRainCheckbox.onclick = function(){
		noRain = this.checked;
		writeCookie();
		soundManager.playSound(SOUND.CLICK);
	};
	$('#noRainLabel').append(noRainCheckbox);
	
	$('#optionsButtonsDiv').append(this.createButton("switchQueriesButton", getButtonCaptionFromOpenQueriesState(), function(){
		open_queries = (open_queries + 1) % 3;
		this.innerHTML = getButtonCaptionFromOpenQueriesState();
		writeCookie();
		soundManager.playSound(SOUND.CLICK);
	}));
	
	// open custom hotkeys window
	$('#optionsButtonsDiv').append(this.createButton("hotkeyWindowButton", "Hotkeys", function(){
		fadeIn($('#customHotkeysWindow'));
		fadeOut($('#optionsWindow'));
		soundManager.playSound(SOUND.CLICK);
	}));
	
	// open FAQ window
	$('#optionsButtonsDiv').append(this.createButton("openFaqButton", "F.A.Q.", function(){
		fadeIn($('#faqWindow'));
		soundManager.playSound(SOUND.CLICK);
	}));
	
	// open window to load custom AI
	$('#optionsButtonsDiv').append(this.createButton("loadAIButton", "Load custom AI", function(){
		// create new input and simulate a click on it and set function (we have to make a new one, so onchange works when the same replay is loaded 2 times in a row)
		fileInput = document.createElement("input");
		fileInput.type = "file";
		fileInput.click();
		
		fileInput.onchange = function()
		{
			var file = fileInput.files[0];
			if(file)
			{
				var reader = new FileReader();
				reader.onload = function(e){ worker.postMessage({what: "aiFunc", data: e.target.result}); };
				reader.readAsBinaryString(file);
			}
		}
		
		soundManager.playSound(SOUND.CLICK);
	}));
	$('#loadAIButton')[0].title = "Load custom AI file (you can write your own AI and load it into the game. For more information on that, check the blog)";
	
	this.optionsPauseButton = new UIElement("button", "optionsPauseButton", function(){ return game_state == GAME.PLAYING; });
	this.optionsPauseButton.domElement.innerHTML = "Pause [<font color='red'>Pause</font>]";
	$('#optionsButtonsDiv').append(this.optionsPauseButton.domElement);
	this.optionsPauseButton.domElement.onclick = function(){ pauseGame(); };
	//
	this.quitGameButton = new UIElement("button", "optionsQuitButton", function(){ return game_state == GAME.PLAYING || game_state == GAME.EDITOR; });
	this.quitGameButton.domElement.innerHTML = "Quit [<font color='red'>N</font>]";
	$('#optionsWindow').append(this.quitGameButton.domElement);
	this.quitGameButton.domElement.onclick = function(){
		
		worker.postMessage({what: "end-game"});
		
		if(game_state == GAME.EDITOR)
		{
			game_state = GAME.LOBBY;
			soundManager.playSound(SOUND.CLICK);
			network.send("leave-game");
		}
		
		// if map data is set, were started from editor, so we go back now to the editor and load the map data
		else if(mapData)
		{
			// show loading screen
			uimanager.showLoadingScreen();
			
			keyManager.resetCommand();
			
			setTimeout(function(){
				$('#lobbyGameChatInput')[0].style.visibility = 'hidden';
				$('#lobbyChatInput')[0].style.visibility = 'hidden';
				game_state = GAME.EDITOR;
				game = new Game();
				game.loadMap(mapData, null, null, null, true);
				worker.postMessage({what: "start-game", editorLoad: true, map: mapData, players: null, network_game: network_game, game_state: game_state, networkPlayerName: networkPlayerName});
			}, 50);
		}
		
		else
		{
			game.refreshReplayButtonVisibleState();
			
			reloadLobby();
			
			keyManager.resetCommand();
			
			if(!game.gameHasEnded)
				game.writeGameStatisticsToWindow(false);
			
			fadeIn($('#statisticsWindow'));
			
			setTimeout(function(){ showAchivement(); }, 2000);
		}
		
		network.game.id = null;
		network.game.name = "";
		fadeOut($('#optionsWindow'));
		
		network_game = false;
		soundManager.playSound(SOUND.CLICK);
		
		// set focus on input
		setChatFocus(true);
	};	
	
	
	
	
	/*
	 * Queries Window
	 */
	var queriesWindow = new UIWindow("queriesWindow", function(){ return true; }, true, "Friends", true);
	queriesWindow.addScrollableSubDiv("queriesWindowSubDiv");
	queriesWindow.addScrollableSubDiv("friendsSubdiv");
	
	var p = document.createElement("p");
	p.innerHTML = "&raquo; Messages";
	p.id = "queriesTitle";
	$('#queriesWindow').append(p);
	
	p = document.createElement("p");
	p.innerHTML = "No Messages";
	p.id = "noMessagesP";
	$('#queriesWindowSubDiv').append(p);
	
	p = document.createElement("p");
	var newFriend = "<br /> &nbsp; <input type='text' id='newFriendInput' /> &nbsp; <button onclick='sendFriendRequest(); soundManager.playSound(SOUND.CLICK);'>send new friend request</button><br /><br />";
	p.innerHTML = newFriend;
	p.id = "addFriendP";
	$('#queriesWindow').append(p);
	
	
	
	/*
	 * Skirmish Back Button
	 */
	var backButton = new UIElement("button", "backButton", function(){ return game_state == GAME.SKIRMISH || (game_state == GAME.LOBBY && network.connected && network.game.id); });
	$('#backButton').html("Back");
	$('#backButton')[0].onclick = function(){
		
		network.game.id = 0;
		network.game.name = "";
		network.send("leave-game");
		game_state = GAME.LOBBY;
		
		soundManager.playSound(SOUND.CLICK);
		
		// set focus on input
		setChatFocus(true);
		
	};
	
	// button daddy
	var buttonDaddy = document.createElement("div");
	buttonDaddy.id = "buttonDaddy";
	$('#lobbyDiv').append(buttonDaddy);
	
	// Create Multi Button
	$('#buttonDaddy').append(this.createButton("lobbyCreateButton", "Play", function(){
		uimanager.openMapSearch(true);
		uimanager.pickMapWindow.setTitle("&raquo; Create Multiplayer Game");
	}));
	$('#lobbyCreateButton').prop('title', 'Click here to create a new multiplayer game. Alternatively you can join an existing game by simply clicking it (you find them in the games window on the left).');
	
	// Create Single Button
	$('#buttonDaddy').append(this.createButton("singleplayerButton", "Play vs CPU", function(){
		uimanager.openMapSearch(false);
		uimanager.pickMapWindow.setTitle("&raquo; Create Singleplayer Game");
	}));
	$('#singleplayerButton').prop('title', 'Click here to create a new singleplayer game and play vs computer opponents.');
	
	// Ladder Button
	$('#buttonDaddy').append(this.createButton("ladderButton", "Ranked Match", function(){
		network.send("get-laddermaps");
		soundManager.playSound(SOUND.CLICK);
	}));
	$('#ladderButton')[0].title = "Play a ranked 1v1 match via auto matchmaking.";
	
	// Map Editor Button
	$('#buttonDaddy').append(this.createButton("mapEditorButton", "Editor", function(){
		network.send("cancel-ladder");
		fadeOut($('#ladderWindow'));
		fadeOut($('#pickMapWindow'));
		$('#lobbyGameChatInput')[0].style.visibility = 'hidden';
		$('#lobbyChatInput')[0].style.visibility = 'hidden';
		
		game_state = GAME.EDITOR;
		editor = new MapEditor();
		soundManager.playSound(SOUND.CLICK);
		network.send("leave-lobby");
	}));
	$('#mapEditorButton')[0].title = "The editor is a powerful tool that allows you to create your own maps and mods.";
	
	// Replay Button
	$('#buttonDaddy').append(this.createButton("replayButton", "Load Replay", function(){
		
		// create new input and simulate a click on it and set function (we have to make a new one, so onchange works when the same replay is loaded 2 times in a row)
		fileInput = document.createElement("input");
		fileInput.type = "file";
		fileInput.click();
		
		fileInput.onchange = function()
		{
			var file = fileInput.files[0];
			if(file)
			{
				var reader = new FileReader();
				
				reader.onload = function(e){
					
					var r = JSON.parse(e.target.result);
					
					replayFile = r;
					
					// find map, replay file holds map name
					network.send("get-map-for-replay<<$" + r.map);
					
				};
				
				reader.readAsBinaryString(file);
			}
		}
		
		soundManager.playSound(SOUND.CLICK);
		
	}));
	$('#replayButton')[0].title = "Here you can watch replays of played games. After you\'ve played a game, you get the chance to save the replay of this game. You can then load this replay here and watch it again.";
	// Save Replay Button

    $('#buttonDaddy').append(this.createButton("lobbySaveReplayButton", "Save Replay", function(){
        var blob = new Blob([game.getReplayFile()], {type: "text/plain;charset=utf-8"});
        saveAs(blob, game.getReplayName() + ".json");
        soundManager.playSound(SOUND.CLICK);
    }));
    $('#lobbySaveReplayButton')[0].title = "Click to download the replay of the last match you played.";
	$('#lobbySaveReplayButton')[0].style.display = (game && game.getReplayFile()) ? "inline" : "none";
	// Create Tutorial Button
	if(!dontShowTutButton)
	{
		var tutorialButtonSpan = document.createElement("span");
		tutorialButtonSpan.id = "tutorialButtonSpan";
		$('#buttonDaddy').append(tutorialButtonSpan);
		
		$('#tutorialButtonSpan').append(this.createButton("tutorialButton", "Tutorials", function(){
			fadeIn($('#pickMapWindow'));
			$('#mapSearchSelect')[0].selectedIndex = 0;
			$('#mapSearchInput').val("");
			createdMulti = false;
			$('#gameNameLabel')[0].style.display = "none";
			$('#gameNameInput')[0].style.display = "none";
			$('#gamePWLabel')[0].style.display = "none";
			$('#gamePWInput')[0].style.display = "none";
			$('#searchLabel')[0].style.display = "none";
			$('#mapSearchInput')[0].style.display = "none";
			$('#mapSearchSelect')[0].style.display = "none";
			requestCustomMapsPage(0, true);
			soundManager.playSound(SOUND.CLICK);
			uimanager.pickMapWindow.setTitle("&raquo; Play Tutorial");
		}));
		$('#tutorialButton').prop('title', 'Here you can play several tutorials, that will introduce you to the game\'s basic features');
		
		$('#tutorialButtonSpan').append(this.createButton("killTutorialButtonButton", "x", function(){
			soundManager.playSound(SOUND.CLICK);
			displayInfoMsg("<br />Hide this button ? You will still be able to play the tutorials by clicking 'Play vs CPU' and searching for 'tutorial'<br /><br /><button onclick='killTutorialButton();'>Yes</button> <button onclick='fadeOut($(\"#infoWindow\")); soundManager.playSound(SOUND.CLICK);'>No</button>");
		}));
		
		$('#killTutorialButtonButton')[0].title = "Hide this button and dont show it again. You will still be able to play the tutorials by clicking 'Play vs CPU' and searching for 'tutorial'.";
	}
	
	/*
	 * ingame Chat Input
	 */
	this.ingameInput = new UIElement("input", "ingameChatInput", function(){ return game_state == GAME.PLAYING && this.active; });
	$('#ingameChatInput')[0].type = "text";
	$('#ingameChatInput')[0].onkeydown = function(e){
		
		if(keyManager.getKeyCode(e) == KEY.ENTER && uimanager.ingameInput.active)
		{
			if(this.value.length > 0)
			{
				if(network_game && network && network.socket)
				{
					if(this.value.substr(0, 6) == "/dance")
					{
						var cmd = null;
						for(var i = 0; i < game.commands.length; i++)
							if(game.commands[i].chat_str == this.value)
								cmd = game.commands[i];
						
						if(cmd)
							game.issueOrderToUnits(game.selectedUnits, cmd);
					}
					
					else if(this.value.substr(0, 8) == "/ignore ")
						network.send("ignore<<$" + this.value.split(" ")[1]);
					
					else if(this.value.substr(0, 10) == "/unignore ")
						network.send("unignore<<$" + this.value.split(" ")[1]);
					
					else
					{
						if(this.value == "/ping")
							timeOfLastPingSent = Date.now();
						
						network.send("chati<<$" + $('#ingameChatDropdown')[0].value + "<<$" + this.value);
					}
				}
				else
				{
					var msg = PLAYING_PLAYER.name + ": " + this.value;
					interface_.chatMsg(msg);
					game.addChatMsgToLog(msg);
				}
				
				this.value = "";
			}
			
			uimanager.ingameInput.active = false;
		}
		
		// tab between ally chat and all chat
		else if(keyManager.getKeyCode(e) == KEY.TAB)
		{
			$('#ingameChatDropdown')[0].selectedIndex = $('#ingameChatDropdown')[0].selectedIndex == 0 ? 1 : 0;
			return false;
		}
		
		// close input on ESC
		else if(keyManager.getKeyCode(e) == KEY.ESC)
		{
			uimanager.ingameInput.active = false;
		}
		
	};
	
	// allies / all dropdown for ingame chat
	var ingameChatDropdown = new UIElement("select", "ingameChatDropdown", function(){ return game_state == GAME.PLAYING && uimanager.ingameInput.active; });
	$('#ingameChatDropdown').html("<option value='*'>All</option><option value='~'>Allies</option>");
	
	
	
	
	var evalDiv = document.createElement("div");
	evalDiv.id = "evalDiv";
	evalDiv.className = "ingameWindow draggable";
	$('body').append(evalDiv);
	
	var evalTextarea = document.createElement("textarea");
	evalTextarea.id = "evalTextarea";
	$('#evalDiv').append(evalTextarea);
	
	var evalButton = document.createElement("button");
	evalButton.innerHTML = "send";
	$('#evalDiv').append(evalButton);
	evalButton.onclick = function(){
		
		network.send('chat<<$/eval ' + $('#evalTextarea').val());
		$('#evalDiv').css("display", "none");
		
	};
	
	
	
	
	/*
	 * Skirmish Window
	 */
	this.skirmishWindow = new UIWindow("skirmishWindow", function(){ return game_state == GAME.SKIRMISH || (game_state == GAME.LOBBY && network && network.connected && network.game.id); });
	this.skirmishWindow.selectedMapIndex = 0;
	
	var mapPreviewImg = document.createElement('img');
	mapPreviewImg.id = "mapPreviewImg";
	$('#skirmishWindow').append(mapPreviewImg);
	
	var showMapInfo = document.createElement('p');
	showMapInfo.id = "showMapInfo";
	$('#skirmishWindow').append(showMapInfo);
	
	var showMapInfo2 = document.createElement('p');
	showMapInfo2.id = "showMapInfo2";
	showMapInfo2.className = "textContainer";
	$('#showMapInfo').append(showMapInfo2);
	
	// player management selects
	$('#skirmishWindow').append(lobbyPlayerManager.div);
	
	$('#skirmishWindow')[0].appendChild($("#lobbyGameInput")[0]);
	
	
	// Change the lobby's current map
	var changeMapButton = new UIElement("button", "changeMapButton", function(){ return game_state == GAME.SKIRMISH || (game_state == GAME.LOBBY && network && network.connected && network.game.id && lobbyPlayerManager.iAmHost); });
	$('#showMapInfo')[0].appendChild($("#changeMapButton")[0]);
	$("#changeMapButton")[0].innerHTML = "Change Map";
	$("#changeMapButton")[0].onclick = function(){
		//$('#evalDiv').css("display", "none");
		fadeIn($('#pickMapWindow'));
		requestCustomMapsPage(0, false);
		soundManager.playSound(SOUND.CLICK);
	};
	/*
	 * Start Button (starts the game in lobby or singleplayer screen)
	 */
	var startButton = new UIElement("button", "startButton", function(){ return game_state == GAME.SKIRMISH || (game_state == GAME.LOBBY && network && network.connected && network.game.id && lobbyPlayerManager.iAmHost); });
	$('#startButton').html("Start");
	$('#startButton')[0].onclick = function(){ startGame(false); };
	
	
	
	
	/*
	 * Info Window & Info Window 2
	 */
	var infoWindow = new UIWindow("infoWindow", function(){ return true; }, true, null, true);
	infoWindow.addScrollableSubDiv("infoWindowTextArea");
	
	var infoWindow2 = new UIWindow("infoWindow2", function(){ return true; }, true, null, true);
	infoWindow2.addScrollableSubDiv("infoWindowTextArea2");
	
	
	
	
	
	
	/*
	 * Ladder Window
	 */
	var ladderWindow = new UIWindow("ladderWindow", function(){ return true; }, false, null, true);
	$('#ladderWindow')[0].style.display = 'none';
	
	
	
	
	
	/*
	 * Replay control panel
	 */
	var replayControlWindow = new UIWindow("replayControlWindow", function(){ return game_state == GAME.PLAYING && game.replay_mode; }, false, null, false, function(key){
		if(key == KEY.PLUS)
			$('#replayPlusButton')[0].click();
		
		else if(key == KEY.MINUS)
			$('#replayMinusButton')[0].click();
	});
	replayControlWindow.blocksCanvas = false;
	
	var replayPlusButton = this.createButton("replayPlusButton", "+", function(){
		
		setReplaySpeed(replaySpeedIndex + 1);
		soundManager.playSound(SOUND.CLICK);
		
	});
	
	var replayMinusButton = this.createButton("replayMinusButton", "-", function(){
		
		setReplaySpeed(replaySpeedIndex - 1);
		soundManager.playSound(SOUND.CLICK);
		
	});
	
	var replayShowSpeed = document.createElement("p");
	replayShowSpeed.id = "replayShowSpeed";
	replayShowSpeed.innerHTML = "1x";
	
	$('#replayControlWindow').append(replayPlusButton);
	$('#replayControlWindow').append(replayMinusButton);
	$('#replayControlWindow').append(replayShowSpeed);
	
	
	
	
	/*
	 * Map Editor New Map Window
	 */
	var newMapWindow = new UIWindow("newMapWindow", function(){ return true; }, true, "New Map", true);
	newMapWindow.addScrollableSubDiv("newMapWindowSubdiv");
	
	$('#newMapWindowSubdiv')[0].innerHTML = "<br />Size <input type='text' id='newMapSizeX' value='64' onchange='checkNewMapInputs();' /> : <input type='text' id='newMapSizeY' value='64' onchange='checkNewMapInputs();' />";
	var str = "<br /><br />Theme: <select id='themeSelecter'>";
	for(var i = 0; i < mapThemes.length; i++)
		str += "<option value='" + mapThemes[i].name + "'>" + mapThemes[i].name + "</option>";
	str += "</select><br /><br />Default height level: <select id='heightLevelSelect'><option value='0'>0</option><option value='1'>1</option><option value='2'>2</option></select>";
	$('#newMapWindowSubdiv')[0].innerHTML += str;
	
	// OK Button
	$('#newMapWindowSubdiv').append(this.createButton("createMapOKButton", "OK", function(){
		
		checkNewMapInputs();
		
		soundManager.playSound(SOUND.CLICK);
		
		fadeOut($('#newMapWindow'));
		
		// show loading screen
		uimanager.showLoadingScreen();
		
		var theme = getThemeByName($('#themeSelecter')[0].value);
		
		setTimeout(function(){
			
			game = new Game();
			
			var x = parseInt($('#newMapSizeX')[0].value);
			var y = parseInt($('#newMapSizeY')[0].value);
			
			var defaultHeight = $('#heightLevelSelect').val();
			
			var hm = "";
			for(var x_ = 1; x_ <= x; x_++)
				for(var y_ = 1; y_ <= y; y_++)
					hm += defaultHeight;
			
			var map = {
				name: "unnamed",
				x: x,
				y: y,
				units: [],
				buildings: [],
				tiles: [],
				theme: theme.name,
				defaultTiles: theme.defaultTiles,
				heightmap: hm
			};
			
			game.loadMap(map);
			
			worker.postMessage({what: "start-game", map: map, players: null, network_game: network_game, game_state: game_state, networkPlayerName: networkPlayerName});
			
		}, 50);
		
	}));
	
	
	
	/*
	 * Map Editor Interface
	 */
	var mapEditorInterface = new UIWindow("mapEditorInterface", function(){ return game_state == GAME.EDITOR; });
	mapEditorInterface.blocksCanvas = false;
	
	// Select button
	$('#mapEditorInterface').append(this.createButton("editorSelectButton", "", function(){
		editor.selectedItemType = null;
		editor.terrainModifier = 0;
		soundManager.playSound(SOUND.CLICK);
	}));
	$('#editorSelectButton')[0].title = "Select Mode";
	
	// Mouse Cursor pos div
	var cursorPosDiv = document.createElement("div");
	cursorPosDiv.id = "cursorPosDiv";
	$('#mapEditorInterface').append(cursorPosDiv);
	
	// Higher Terrain Button
	$('#mapEditorInterface').append(this.createButton("editorHigherTerrainButton", "<span class='mapEditorHotkey'>[D]</span>", higherTerrain));
	$('#editorHigherTerrainButton')[0].title = "Higher cliff level";
	
	// Lower Terrain Button
	$('#mapEditorInterface').append(this.createButton("editorLowerTerrainButton", "<span class='mapEditorHotkey'>[F]</span>", lowerTerrain));
	$('#editorLowerTerrainButton')[0].title = "Lower cliff level";
	
	// Add Ramp Button
	$('#mapEditorInterface').append(this.createButton("addRampButton", "<span class='mapEditorHotkey'>[S]</span>", addRamp));
	$('#addRampButton')[0].title = "Add ramp";
	
	// Kill Ramp Button
	$('#mapEditorInterface').append(this.createButton("killRampButton", "<span class='mapEditorHotkey'>[A]</span>", killRamp));
	$('#killRampButton')[0].title = "Remove ramp";
	

	$('#mapEditorInterface').append(this.createButton("editorUndoButton","<span class='mapEditorHotkey'>[U]</span>", function() {
		editor.clipboard.history.undo();
		soundManager.playSound(SOUND.CLICK);
	}));
	$('#editorUndoButton')[0].title = "Undo last action";
	
	// player select dropdown
	var playerDropdown = document.createElement("select");
	playerDropdown.id = "playerDropdown";
	playerDropdown.innerHTML = "<option value='0'>Neutral</option>";
	
	for(var i = 0; i < MAX_PLAYERS; i++)
		playerDropdown.innerHTML += "<option " + (i == 0 ? "selected='selected'" : "") + " value='" + (i + 1) + "'>Player " + (i + 1) + "</option>";
	
	
	playerDropdown.onchange = function(){
		
		editor.player = this.value;
		
		// change owner of selectd units
		for(var i = 0; i < game.selectedUnits.length; i++)
		{
			var u = game.selectedUnits[i];
			if(u && !u.type.alwaysNeutral && (u.type.isBuilding || u.type.isUnit))
			{
				u.owner = game.players[editor.player];
				worker.postMessage({what: "unitChangeOwner", unit: u.id, owner: editor.player});
			}
		}
		
		this.blur();
		
	};
	$('#mapEditorInterface').append(playerDropdown);
	
	// show grid checkbox
	var showGridCheckbox = document.createElement("input");
	showGridCheckbox.type = "checkbox";
	showGridCheckbox.id = "showGridCheckbox";
	showGridCheckbox.onchange = function(){
		soundManager.playSound(SOUND.CLICK);
	};
	$('#mapEditorInterface').append(showGridCheckbox);
	
	// show grid label
	var showGridLabel = document.createElement("label");
	showGridLabel.id = "showGridLabel";
	showGridLabel.innerHTML = "Show grid";
	showGridLabel.htmlFor = "showGridCheckbox";
	$('#mapEditorInterface').append(showGridLabel);
	
	// Play button
	$('#mapEditorInterface').append(this.createButton("editorPlayButton", "Test [Q]", testMap));
	
	// Save button
	$('#mapEditorInterface').append(this.createButton("editorSaveButton", "Save", function(){
		var blob = new Blob([JSON.stringify(game.export_())], {type: "text/plain;charset=utf-8"});
		saveAs(blob, "map.json");
		soundManager.playSound(SOUND.CLICK);
	}));
	
	// Load button
	$('#mapEditorInterface').append(this.createButton("editorLoadButton", "Load", function(){
		fadeIn($('#pickMapWindow'));
		$('#mapSearchSelect')[0].selectedIndex = 0;
		$('#mapSearchInput').val("");
		$('#gameNameLabel')[0].style.display = "none";
		$('#gameNameInput')[0].style.display = "none";
		$('#gamePWLabel')[0].style.display = "none";
		$('#gamePWInput')[0].style.display = "none";
		$('#searchLabel')[0].style.display = "inline";
		$('#mapSearchInput')[0].style.display = "inline";
		$('#mapSearchSelect')[0].style.display = "inline";
		requestCustomMapsPage(0);
		soundManager.playSound(SOUND.CLICK);
		uimanager.pickMapWindow.setTitle("&raquo; Load Map");
	}));
	
	// New Map button
	$('#mapEditorInterface').append(this.createButton("editorNewButton", "New", function(){
		fadeIn($('#newMapWindow'));
		soundManager.playSound(SOUND.CLICK);
	}));
	
	// Upload map button
	$('#mapEditorInterface').append(this.createButton("uploadMapButton", "Upload", function(){
		
		if(network.authedAndLogged)
		{
			if(game.name != "unnamed" && game.name.length > 0)
			{
				network.send("upload-map-request<<$" + game.name);
				displayInfoMsg("uploading...");
			}
			else
				displayInfoMsg("You need to set a map name first");
		}
		else
			displayInfoMsg("You need to be logged in to upload your map!");
		
		soundManager.playSound(SOUND.CLICK);
		
	}));
	
	// Map settings button
	$('#mapEditorInterface').append(this.createButton("mapSettingsButton", "Settings", function(){
		fadeIn($('#mapSettingsWindow'));
		soundManager.playSound(SOUND.CLICK);
		updatePlayerDropdowns();
	}));
	
	// Manage uploaded Maps button
	$('#mapEditorInterface').append(this.createButton("manageMapsButton", "My Maps", function(){
		
		fadeIn($('#manageMapsWindow'));
		
		network.send("request-my-maps");
		
		soundManager.playSound(SOUND.CLICK);
		
	}));
	
	// Data Button
	$('#mapEditorInterface').append(this.createButton("dataButton", "Data", function(){
		
		if($('#mapEditorData')[0].style.display == "none")
			fadeIn($('#mapEditorData'));
		else
			fadeOut($('#mapEditorData'));
		
		mapEditorData.window.active = !mapEditorData.window.active;
		soundManager.playSound(SOUND.CLICK);
		
	}));
	
	$('#mapEditorInterface').append(this.createButton("customGraphicsButton", "Graphics", function() {
		if($('#customGraphicsWindow')[0].style.display == "none")
		{
			fadeIn($('#customGraphicsWindow'));
			refreshCustomImgs();
		}
		else
			fadeOut($('#customGraphicsWindow'));
		soundManager.playSound(SOUND.CLICK);
	}));
	
	var customGraphicsWindow = new UIWindow("customGraphicsWindow", function(){ return true; }, true, "Graphics", true);
	customGraphicsWindow.addScrollableSubDiv("customGraphicsWindowSubdiv");
	customGraphicsWindow.setTitle("Graphics", "<button onclick='saveCustomGraphics();'>Ok</button>");
	
	customGraphicsWindowSubdiv.innerHTML = "<button id='loadGraphicButton' onclick='importGraphic();'>Import graphic</button>";
	customGraphicsWindowSubdiv.innerHTML += "<div id='customGraphicsDiv'></div>";
	
	/*
	 * Uploaded Maps Management Window
	 */
	var manageMapsWindow = new UIWindow("manageMapsWindow", function(){ return true; }, true, "Manage Maps", true);
	manageMapsWindow.addScrollableSubDiv("mapWindowSubdiv");
	
	
	
	/*
	 * Map Settings Window
	 */
	var mapSettingsWindow = new UIWindow("mapSettingsWindow", function(){ return true; }, true, "Map Settings", true);
	mapSettingsWindow.addScrollableSubDiv("mapSettingsWindowSubdiv");
	
	$('#mapSettingsWindowSubdiv')[0].innerHTML = "Name<br /><input type='text' id='mapNameInput' /><br /><br />Description<br /><textarea id='mapDescriptionInput'></textarea><br /><br />";
	$('#mapSettingsWindowSubdiv')[0].innerHTML += "<span title='Black fog will make the unexplored parts of the map 100% black, so the player doesnt see the terrain'><label for='useBlackFogCheckbox'>Use dark fog </label><input type='checkbox' id='useBlackFogCheckbox' /></span>";
	$('#mapSettingsWindowSubdiv')[0].innerHTML += " &nbsp; <span title='If this is activated, other players will be able to load this map to the editor. They will NOT be able to overwrite your map, but they can edit and upload their own versions.'><label for='mapOpenCheckbox'>Unlocked </label><input type='checkbox' id='mapOpenCheckbox' /></span>";
	$('#mapSettingsWindowSubdiv')[0].innerHTML += "<br /><span title='The max supply playerx can have'><label for='maxSupplyInput'>Max Supply </label><input size='5' onchange='checkMapSettingInputs();' type='text' id='maxSupplyInput' /></span>";
	$('#mapSettingsWindowSubdiv')[0].innerHTML += " &nbsp; <span title='The amount of gold players have when the game starts'><label for='startGoldInput'>Start Gold </label><input size='5' onchange='checkMapSettingInputs();' type='text' id='startGoldInput' /></span>";
	$('#mapSettingsWindowSubdiv')[0].innerHTML += "<br /><span title='The minimum distance a goldmine must have to a castle'><label for='mineDistInput'>Min. distance goldmine to castle </label><input size='5' onchange='checkMapSettingInputs();' type='text' id='mineDistInput' /></span>";
	$('#mapSettingsWindowSubdiv')[0].innerHTML += "<div id='playerSettingsDiv'></div>";
	
	$('#mapSettingsWindow').append(this.createButton("mapSettingsOKButton", "OK", function(){
		game.name = $('#mapNameInput')[0].value;
		game.description = $('#mapDescriptionInput')[0].value;
		game.globalVars.isOpen = $("#mapOpenCheckbox").prop('checked');
		game.globalVars.useDarkMask = $("#useBlackFogCheckbox").prop('checked');
		game.globalVars.maxSupply = $("#maxSupplyInput")[0].value;
		game.globalVars.startGold = $("#startGoldInput")[0].value;
		game.globalVars.mineDist = $("#mineDistInput")[0].value;
		worker.postMessage({what: "updateGlobalVars", globalVars: game.globalVars});
		fadeOut($('#mapSettingsWindow'));
		soundManager.playSound(SOUND.CLICK);
	}));
	
	// player settings stuff
	var str = "<p style='font-size: 24px; margin-left: 20px;'>&raquo; Player Settings</p><br /><br /><table style='font-size: 20px;'><tr><td></td><td title='Open slots can be joined by players or filled with computers. Computer slots will always have a computer in this slot and can not be joined by a player.'>";
	str += "&nbsp; Slot</td><td title='Select this players team. If you choose \"any\", then the host will be able to choose any team for this player in the game lobby.'>&nbsp; Team</td>";
	str += "<td title='Only available for \"Computer\" slots. If you select \"no AI\", then this player will not be controlled by the default AI. This often makes sense for custom mods, where the normal AI doesnt work well.'>&nbsp; AI</td></tr>";
	
	for(var i = 0; i < MAX_PLAYERS; i++)
	{
		str += "<tr><td>Player " + (i + 1) + "</td><td><select onchange='updatePlayerDropdowns();' id='pl_slot_" + i + "' class='playerSettingsTD'>";
		str += "<option>open</option><option>computer</option><option>closed</option></select></td><td><select id='pl_team_" + i + "' class='playerSettingsTD'><option>any</option>";
		
		for(var k = 0; k < MAX_PLAYERS; k++)
			str += "<option>Team " + (k + 1) + "</option>";
		
		str += "</select></td><td><select class='playerSettingsTD' id='pl_ai_" + i + "'><option>normal AI</option><option>no AI</option></select></td></tr>";
	}
	
	str += "</table><br /><br />";
	
	$('#playerSettingsDiv')[0].innerHTML = str;
	
	
	
	
	
	
	// Menu button
	var ingameMenuButton = new UIElement("button", "ingameMenuButton", function(){ return game_state != GAME.LOGIN && game_state != GAME.RECOVERY && game_state != GAME.REGISTER; });
	ingameMenuButton.blocksCanvas = false;
	ingameMenuButton.domElement.className = "menuButtons";
	$('#ingameMenuButton')[0].onclick = function(){
		
		if($('#optionsWindow')[0].style.display == "none")
			fadeIn($('#optionsWindow'));
		else
			fadeOut($('#optionsWindow'));
		
		soundManager.playSound(SOUND.CLICK);
	};
	
	// ingame Chat History Window button
	var ingameChatHistoryButton = new UIElement("button", "ingameChatHistoryButton", function(){ return game_state == GAME.PLAYING; });
	ingameChatHistoryButton.blocksCanvas = false;
	ingameChatHistoryButton.domElement.className = "menuButtons";
	ingameChatHistoryButton.domElement.title = "Chat History";
	ingameChatHistoryButton.domElement.onclick = function(){
		if($('#chatHistoryWindow')[0].style.display == "none")
			fadeIn($('#chatHistoryWindow'));
		else
			fadeOut($('#chatHistoryWindow'));
		soundManager.playSound(SOUND.CLICK);
	};
	
	// clans button
	var clansButton = new UIElement("button", "clansButton", function(){ return game_state == GAME.LOBBY && network.authedAndLogged; });
	clansButton.blocksCanvas = false;
	clansButton.domElement.className = "menuButtons";
	clansButton.domElement.title = "Clans";
	$('#clansButton')[0].onclick = function(){
		network.send("request-my-clan-info");
		soundManager.playSound(SOUND.CLICK);
	};
	
	// friends button
	var friendsButton = new UIElement("button", "friendsButton", function(){ return game_state != GAME.LOGIN && game_state != GAME.RECOVERY && game_state != GAME.REGISTER; });
	friendsButton.blocksCanvas = false;
	friendsButton.domElement.className = "menuButtons";
	friendsButton.domElement.title = "Friends & Messages";
	$('#friendsButton')[0].onclick = function(){
		if($('#queriesWindow')[0].style.display == "none")
		{
			if(network.authedAndLogged)
				network.send("request-friends-info");
			else
				fadeIn($('#queriesWindow'));
		}
		else
			fadeOut($('#queriesWindow'));
		
		clearInterval(queryButtonBlinkInterval);
		queryButtonBlinkInterval = null;
		$("#friendsButton").removeClass("backgroundRed");
		
		soundManager.playSound(SOUND.CLICK);
	};
	
	/*
	// leagues button
	var leaguesButton = new UIElement("button", "leaguesButton", function(){ return game_state == GAME.LOBBY; });
	leaguesButton.blocksCanvas = false;
	leaguesButton.domElement.className = "menuButtons";
	leaguesButton.domElement.title = "Leagues";
	$('#leaguesButton')[0].onclick = function(){
		showAllDivisions();
		soundManager.playSound(SOUND.CLICK);
	};
	*/
	
	// emotes button
	var emotesButton = new UIElement("button", "emotesButton", function(){ return game_state == GAME.LOBBY && network.authedAndLogged; });
	emotesButton.blocksCanvas = false;
	emotesButton.domElement.className = "menuButtons";
	emotesButton.domElement.title = "Unlockable Items";
	$('#emotesButton')[0].onclick = function(){
		showMicroTransWindow();
		soundManager.playSound(SOUND.CLICK);
	};
	
	// achivements button
	var achivementsButton = new UIElement("button", "achivementsButton", function(){ return game_state == GAME.LOBBY && network.authedAndLogged; });
	achivementsButton.blocksCanvas = false;
	achivementsButton.domElement.className = "menuButtons";
	achivementsButton.domElement.title = "Achievements";
	$('#achivementsButton')[0].onclick = function(){
		network.send("get-achivements");
		soundManager.playSound(SOUND.CLICK);
	};
	
	
	
	/*
	 * Select Map Window (when hosting game)
	 */
	this.pickMapWindow = new UIWindow("pickMapWindow", function(){ return true; }, true, "Select Map", true);
	
	var selectMapArea = document.createElement("div");
	selectMapArea.id = "selectMapArea";
	$('#pickMapWindow').append(selectMapArea);
	
	var selectMapPages = document.createElement("div");
	selectMapPages.id = "selectMapPages";
	$('#pickMapWindow').append(selectMapPages);
	
	// search input
	var mapSearchInput = document.createElement("input");
	mapSearchInput.type = "text";
	mapSearchInput.id = "mapSearchInput";
	mapSearchInput.onkeydown = function(e){
		if(keyManager.getKeyCode(e) == KEY.ENTER)
			requestCustomMapsPage(0);
	};
	$('#pickMapWindow').append(mapSearchInput);
	
	// mode select
	var mapSearchSelect = document.createElement("select");
	mapSearchSelect.innerHTML = "<option value='*'>All maps</option>";
	for(var i = 2; i <= MAX_PLAYERS; i++)
		mapSearchSelect.innerHTML += "<option value='" + i + " player maps'>" + i + " player maps</option>";
	mapSearchSelect.innerHTML += "<option title='Those are maps that can differ quite a lot from the normal game. They can use modified or completely new units, buildings or abilities' value='Custom mods'>Custom mods</option>";
	mapSearchSelect.id = "mapSearchSelect";
	mapSearchSelect.onchange = function(e){
		requestCustomMapsPage(0);
	};
	$('#pickMapWindow').append(mapSearchSelect);
	
	// search label
	var searchLabel = document.createElement("label");
	searchLabel.innerHTML = "Search Map:";
	searchLabel.id = "searchLabel";
	searchLabel.htmlFor = "mapSearchInput";
	$('#pickMapWindow').append(searchLabel);
	
	// gaem naem input
	var gameNameInput = document.createElement("input");
	gameNameInput.type = "text";
	gameNameInput.id = "gameNameInput";
	gameNameInput.title = "Here you can enter a name for your game. If you leave empty, the name of the map will be the game name.";
	$('#pickMapWindow').append(gameNameInput);
	
	// gaem naem label
	var gameNameLabel = document.createElement("label");
	gameNameLabel.innerHTML = "Game Name:";
	gameNameLabel.id = "gameNameLabel";
	gameNameLabel.htmlFor = "gameNameInput";
	$('#pickMapWindow').append(gameNameLabel);
	
	// gaem pw input
	var gamePWInput = document.createElement("input");
	gamePWInput.type = "text";
	gamePWInput.id = "gamePWInput";
	gamePWInput.title = "Here you can enter a password for your game. Leave empty for no password";
	$('#pickMapWindow').append(gamePWInput);
	
	// gaem pw label
	var gamePWLabel = document.createElement("label");
	gamePWLabel.innerHTML = "Password:";
	gamePWLabel.id = "gamePWLabel";
	gamePWLabel.htmlFor = "gamePWInput";
	$('#pickMapWindow').append(gamePWLabel);
	
	
	
	
	
	
	
	// Bing message
	var bingMessage = document.createElement("div");
	bingMessage.id = "bingMessageWindow";
	bingMessage.className = "ingameWindow";
	document.body.appendChild(bingMessage);
	
	
	
	
	
	
	// Load External Map Button
	$('#pickMapWindow').append(this.createButton("loadExternalButton", "Load external", function(){
		
		// create new input and simulate a click on it and set function (we have to make a new one, so onchange works when the same replay is loaded 2 times in a row)
		fileInput = document.createElement("input");
		fileInput.type = "file";
		fileInput.click();
		
		fileInput.onchange = function()
		{
			var file = fileInput.files[0];
			if(file)
			{
				var reader = new FileReader();
				reader.readAsBinaryString(file);
				reader.onload = function(e){
					
					// show loading screen
					uimanager.showLoadingScreen();
					
					setTimeout(function(){
						game = new Game();
						var map = JSON.parse(e.target.result);
						game.loadMap(map, null, null, null, true);
						worker.postMessage({what: "start-game", editorLoad: true, map: map, players: null, network_game: network_game, game_state: game_state, networkPlayerName: networkPlayerName});
						fadeOut($('#pickMapWindow'));
						
						map.description = map.description ? map.description.replace(RegExp('<br />', "gi"), '\n') : "";
						if(map.description.indexOf("\n\nMap by ") >= 0)
							map.description = map.description.split("\n\nMap by ").slice(0, -1).join("\n\nMap by ");
						
						// set form fields name and description
						$('#mapNameInput')[0].value = map.name;
						$('#mapDescriptionInput')[0].value = map.description;
						$("#mapOpenCheckbox").prop('checked', map.globalVars ? map.globalVars.isOpen : false);
						$("#useBlackFogCheckbox").prop('checked', map.globalVars ? map.globalVars.useDarkMask : false);
						$("#maxSupplyInput")[0].value = map.globalVars ? map.globalVars.maxSupply : false;
						$("#startGoldInput")[0].value = map.globalVars ? map.globalVars.startGold : false;
						$("#mineDistInput")[0].value = map.globalVars ? map.globalVars.mineDist : false;
					}, 50);
				};
			}
		};
		
		soundManager.playSound(SOUND.CLICK);
		
	}));
	
	$('#loadExternalButton')[0].title = "Load a map from your hard disk";
	
	
	
	
	// Player Info Window
	this.playerInfoWindow = new UIWindow("playerInfoWindow", function(){ return true; }, true, "Player Info", true);
	// Add a rider div <<<<<
	var riderDiv = document.createElement("div");
	riderDiv.id = 'riderDiv';
	$('#playerInfoWindow')[0].appendChild(riderDiv);
	this.playerInfoWindow.addScrollableSubDiv("addScrollableSubDivTextArea");
	$('#addScrollableSubDivTextArea').addClass("nodrag");
	
	// Player Info Window 2
	this.playerInfoWindow2 = new UIWindow("playerInfoWindow2", function(){ return true; }, true, " ", true);
	this.playerInfoWindow2.addScrollableSubDiv("addScrollableSubDivTextArea2");
	$('#addScrollableSubDivTextArea2').addClass("nodrag");
	
	const versionStr = (GAME_VERSION == parseInt(GAME_VERSION) ? (GAME_VERSION + ".0") : GAME_VERSION);
	this.versionInfo = new UIWindow("versionInfo", function(){ return true; }, true, `Patch ${versionStr}`, true);
	this.versionInfo.addScrollableSubDiv("versionScrollPanel");
	$('#versionScrollPanel').addClass("nodrag");
	
	jQuery.get(`code/ChangeLog.txt`, function(versionInfoString) {
		$('#versionScrollPanel')[0].innerHTML = versionInfoString;
	});
	// Version number display
	var versionNumber = new UIElement("div", "versionNumber", function(){ return game_state == GAME.LOGIN || game_state == GAME.REGISTER || game_state == GAME.LOBBY || game_state == GAME.RECOVERY; });
	$('#versionNumber').html("<a title='This is the current version of the game. Click for a complete version log.' id='versionNumber' target='_blank'>v" + versionStr + "</a>");
	$('#versionNumber')[0].onclick = function(){
		fadeIn($('#versionInfo'));
		soundManager.playSound(SOUND.CLICK);
	};
	// faq container
	var faqContainer = new UIElement("div", "faqContainer", function(){ return game_state == GAME.LOGIN || game_state == GAME.REGISTER || game_state == GAME.LOBBY || game_state == GAME.RECOVERY; });
	$('#faqContainer').html("");
	
	// gold
	var playerGoldWrap = new UIElement("div", "playerGoldWrap", function(){ return game_state == GAME.LOGIN || game_state == GAME.REGISTER || game_state == GAME.LOBBY || game_state == GAME.RECOVERY; });
	playerGoldWrap.domElement.innerHTML = "";
	
	// acc info window
	var accInfoWindow = new UIWindow("accInfoWindow");
	accInfoWindow.domElement.innerHTML = "<div id='accInfoTopDiv'><div id='playerNameDisplay'></div></div><div id='mainLeagueLink' title='This is your current league. You can get promoted or demoted depending on your ladder match results.'></div>";
	$('#lobbyDiv').append(accInfoWindow.domElement);
	
	// F.A.Q. Window
	var faqWindow = new UIWindow("faqWindow", function(){ return true; }, true, "F.A.Q.", true);
	faqWindow.addScrollableSubDiv("faqWindowSubDivTextArea");
	
	
	
	
	
	jQuery.get(`code/FAQ.txt`, function(faqstr) {
		$('#faqWindowSubDivTextArea')[0].innerHTML = faqstr;
	});
	
	
	
	
	
	
	
	
	// var pleaseNoAdblockDiv = new UIElement("div", "pleaseNoAdblockDiv", function(){ return game_state == GAME.LOBBY || game_state == GAME.LOGIN || game_state == GAME.REGISTER || game_state == GAME.RECOVERY; });
	// $('#pleaseNoAdblockDiv').html("Please disable adblock for Littlewargame.com. The money from the ad helps us to run the game. Also, there is only one ad (right here where this text is) on the whole page, and we promise it's really not annoying.");
	
	// // ads
	// var adsenseDiv = new UIElement("div", "div-gpt-ad-1571242603068-0", function(){ return game_state == GAME.LOBBY || game_state == GAME.LOGIN || game_state == GAME.REGISTER || game_state == GAME.RECOVERY; });
	// $('#div-gpt-ad-1571242603068-0').html("<script>googletag.cmd.push(function() { googletag.display('div-gpt-ad-1571242603068-0'); });</script></div>");
	
	
	
	
	
	
	// links menu
	var linksMenu = new UIElement("div", "linksMenu", function(){ return game_state == GAME.LOGIN || game_state == GAME.REGISTER || game_state == GAME.LOBBY || game_state == GAME.RECOVERY; });
	linksMenu.domElement.innerHTML = "<p id='links-title'>Quick Links</p>";
	
	var linksMenu2 = document.createElement('div');
	linksMenu2.innerHTML = "<p><a href='https://www.facebook.com/littlewargame' target='_blank'>Facebook</a></p>";
	linksMenu2.innerHTML += "<p><a href='https://twitter.com/jbgames_' target='_blank'>Twitter</a></p>";
	linksMenu2.innerHTML += "<p><a href='http://littlewargame.com/blog' target='_blank'>Blog</a></p>";
	// linksMenu2.innerHTML += "<p><a href='http://littlewargame.com/forum' target='_blank'>Forum</a></p>";
	linksMenu2.innerHTML += "<p><a href='http://www.reddit.com/r/Littlewargame' target='_blank'>Subreddit</a></p>";
	linksMenu2.innerHTML += "<p><a href='http://littlewargame.gamepedia.com/Little_War_Game_Wiki' target='_blank'>Wiki</a></p>";
	linksMenu2.innerHTML += "<p><a href='https://www.youtube.com/user/LittleWarGameRTS' target='_blank'>Youtube</a></p>";
	linksMenu2.innerHTML += "<p><a href='https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=R2HK5KUDB9JVQ' target='_blank'>Donate</a></p>";
	
	linksMenu.domElement.appendChild(linksMenu2);
	
	
	
	// legalities
	var legalities = new UIElement("div", "legalities", function(){ return game_state == GAME.LOGIN || game_state == GAME.REGISTER || game_state == GAME.LOBBY || game_state == GAME.RECOVERY; });
	legalities.domElement.innerHTML = "<a onclick='showImprint();'>Imprint</a> | <a onclick='showAGB();'>Terms &amp; Conditions</a> | <a onclick='showDSE();'>Privacy Policy</a></p>";
	
	
	
	
	// loading window
	var loadingWindow = document.createElement("div");
	loadingWindow.id = "loadingWindow";
	document.body.appendChild(loadingWindow);
	
	// loading text
	var loadingText = document.createElement("p");
	loadingWindow.appendChild(loadingText);
	loadingText.id = "loadingText";
	loadingText.innerHTML = "loading...";
	
	// map preview img
	var loadingScreenMapImg = document.createElement("img");
	loadingScreenMapImg.id = "loadingScreenMapImg";
	loadingWindow.appendChild(loadingScreenMapImg);
	
	// map name
	var mapScreenName = document.createElement("p");
	mapScreenName.id = "mapScreenName";
	loadingWindow.appendChild(mapScreenName);
	
	// players display
	var playersDisplay = document.createElement("p");
	playersDisplay.id = "playersDisplay";
	loadingWindow.appendChild(playersDisplay);
	
	
	
	
	
	
	
	// observer dropdown
	var spectatorDropdown = new UIElement("select", "spectatorDropdown", function(){ return game_state == GAME.PLAYING && PLAYING_PLAYER && PLAYING_PLAYER.controller == CONTROLLER.SPECTATOR; }, false, function(key){
		for(var i = 1; i < obsKeys.length; i++)
			if(key == obsKeys[i])
				this.domElement.selectedIndex = i;
		
		this.domElement.onchange();
	});
	
	spectatorDropdown.domElement.innerHTML = "<option selected='selected' value='0'>Nothing</option>";
	for(var i = 1; i < obsKeys.length; i++)
		spectatorDropdown.domElement.innerHTML += "<option id='obsDropdown_" + i + "' value='" + i + "'>" + obsAbilityNames[i] + " [" + getKeyName(obsKeys[i]) + "]</option>";
	
	spectatorDropdown.domElement.onchange = function(){
		if(game)
			game.refreshSpectatorTab();
		$('#ingameMenuButton')[0].focus();
	};
	
	// observer div
	var spectatorDiv = new UIElement("div", "spectatorDiv", function(){
		return game_state == GAME.PLAYING && PLAYING_PLAYER && PLAYING_PLAYER.controller == CONTROLLER.SPECTATOR && $('#spectatorDropdown')[0].selectedIndex > 0;
	});
	
	// Label
	this.spectatorLabel = new UIElement("p", "spectatorLabel", function(){ return game_state == GAME.PLAYING && PLAYING_PLAYER && PLAYING_PLAYER.controller == CONTROLLER.SPECTATOR; });
	this.spectatorLabel.domElement.innerHTML = "Info";
	
	
	
	
	
	
	
	// Vision Dropdown
	var visionDropdown = new UIElement("select", "visionDropdown", function(){ return game_state == GAME.PLAYING && PLAYING_PLAYER && PLAYING_PLAYER.controller == CONTROLLER.SPECTATOR; }, false, function(key){
		if(key == obsKeys[0])
		{
			this.domElement.selectedIndex = 0;
			this.domElement.onchange();
		}
		
		if(key >= KEY.NUM1 && key <= KEY.NUM1 + this.domElement.childNodes.length - 2)
		{
			this.domElement.selectedIndex = key - KEY.NUM1 + 1;
			this.domElement.onchange();
		}
	});
	visionDropdown.domElement.onchange = function(){
		if(game)
			game.refreshVision();
		$('#ingameMenuButton')[0].focus();
	};
	
	// Label
	this.visionLabel = new UIElement("p", "visionLabel", function(){ return game_state == GAME.PLAYING && PLAYING_PLAYER && PLAYING_PLAYER.controller == CONTROLLER.SPECTATOR; });
	this.visionLabel.domElement.innerHTML = "Vision";
	
	
	
	
	
	
	// dark screen div
	var darkScreenDiv = document.createElement("div");
	darkScreenDiv.id = "darkScreenDiv";
	document.body.appendChild(darkScreenDiv);
	
	
	
	
	
	
	
	
	// Custom hotkeys setup window
	var customHotkeysWindow = new UIWindow("customHotkeysWindow", function(){ return true; }, true, "Hotkeys", true, function(key){
		setHotkey(key);
		soundManager.playSound(SOUND.CLICK);
	});
	
	customHotkeysWindow.addScrollableSubDiv("customHotkeysWindowSubdiv");
	
	// resetHotkeys button
	$('#customHotkeysWindow').append(this.createButton("resetHotkeysButton", "reset hotkeys", function(){
		soundManager.playSound(SOUND.CLICK);
		displayInfoMsg("Reset all hotkeys to default ?<br /><br /><button onclick='resetHotkeys(); soundManager.playSound(SOUND.CLICK); $(\"#infoWindow\")[0].style.display = \"none\";'>reset</button>");
	}));
	
	initHotkeyWindow();
	
	
	
	
	
	
	
	
	
	// put elements in array
	elements.push(
		this.winLossWindow,
		lobbyDiv,
		lobbyInput,
		backButton,
		this.versionInfo,
		this.ingameInput,
		ingameChatDropdown,
		this.skirmishWindow,
		changeMapButton,
		mapEditorInterface,
		ingameMenuButton,
		ingameChatHistoryButton,
		lobbyGameChatWindow,
		startButton,
		replayControlWindow,
		this.quitGameButton,
		this.optionsPauseButton,
		versionNumber,
		pleaseNoAdblockDiv,
		adsenseDiv,
		spectatorDropdown,
		spectatorDiv,
		visionDropdown,
		this.spectatorLabel,
		this.visionLabel,
		linksMenu,
		clansButton,
		friendsButton,
		achivementsButton,
		emotesButton,
		legalities,
		playerGoldWrap,
		faqContainer
	);
	
	this.onKeyElements = [
		replayControlWindow,
		spectatorDropdown,
		visionDropdown,
		optionsWindow,
		customHotkeysWindow
	];
	
	
	// add hover sound events to all buttons
	$("button").mouseenter(function(){
		soundManager.playSound(SOUND.ZIP, false, 0.3);
	});
	
	
	
	// make windows draggable (with jquery ui)
	$(".draggable").draggable({
		drag: onDrag,
		cancel: "p, input, select, textarea, button, #personalTextDiv, .nodrag"
	});
};

UIManager.prototype.openMapSearch = function(multi)
{
	fadeIn($('#pickMapWindow'));
	$('#mapSearchSelect')[0].selectedIndex = 0;
	$('#mapSearchInput').val("");
	$('#gameNameLabel')[0].style.display = multi ? "inline" : "none";
	$('#gameNameInput')[0].style.display = multi ? "inline" : "none";
	$('#gamePWLabel')[0].style.display = multi ? "inline" : "none";
	$('#gamePWInput')[0].style.display = multi ? "inline" : "none";
	$('#searchLabel')[0].style.display = "inline";
	$('#mapSearchInput')[0].style.display = "inline";
	$('#mapSearchInput')[0].focus();
	$('#mapSearchSelect')[0].style.display = "inline";
	requestCustomMapsPage(0);
	soundManager.playSound(SOUND.CLICK);
	createdMulti = multi;
};

// is called every frame, checks for all elements if they should be drawn and saves the number of active elements (that block canvas input)
UIManager.prototype.draw = function()
{
	this.hasActiveElements = false;
	for(var i = 0; i < elements.length; i++)
	{
		if(elements[i].refreshVisibility())
		{
			this.hasActiveElements = true;
		}
	}
};

// is calles onkey; calls onkey on all active ui elements
UIManager.prototype.onKey = function(key)
{
	for(var i = 0; i < this.onKeyElements.length; i++)
		if(this.onKeyElements[i].domElement.style.display == "inline" || (this.onKeyElements[i].domElement.style.display != "none" && this.onKeyElements[i].domElement.style.visibility == "visible"))
			this.onKeyElements[i].onKey(key);
};

// create a new html button
UIManager.prototype.createButton = function(id, caption, onclick)
{
	var button = document.createElement("button");
	
	if(id)
		button.id = id;
	
	button.innerHTML = caption;
	button.onclick = onclick;
	
	return button;
};

UIManager.prototype.queriesAreOpen = function()
{
	for(var i = 0; i < this.queries.length; i++)
		if(this.queries[i].domElement.style.display = "inline")
			return true;
	return false;
};

UIManager.prototype.showLoadingScreen = function(map, players)
{
	if((map && map.img) || currentMapImg)
	{
		$('#loadingScreenMapImg')[0].src = currentMapImg ? currentMapImg : map.img;
		$('#loadingScreenMapImg')[0].style.display = "inline";
	}
	else
		$('#loadingScreenMapImg')[0].style.display = "none";
	
	if(map && map.name)
	{
		$('#mapScreenName')[0].innerHTML = map.name;
		$('#mapScreenName')[0].style.display = "inline";
	}
	else
		$('#mapScreenName')[0].style.display = "none";


	$('#lobbyGameChatInput')[0].style.visibility = 'hidden';
	// show players
	if(players)
	{
		var str = "";
		
		for(var i = 0; i < players.length; i++)
			if(players[i].controller != CONTROLLER.SPECTATOR)
			{
				if(players[i].clan)
					str += "[" + players[i].clan + "] ";
				
				str += players[i].name;
				
				if(players[i + 1] && players[i + 1].team == players[i].team && players[i + 1].controller != CONTROLLER.SPECTATOR)
					str += " &amp; ";
				
				else if(players[i + 1] && players[i + 1].team != players[i].team && players[i + 1].controller != CONTROLLER.SPECTATOR)
					str += " vs ";
			}
		
		$('#playersDisplay')[0].innerHTML = str;
		$('#playersDisplay')[0].style.display = "inline";
	}
	else
		$('#playersDisplay')[0].style.display = "none";
	
	$('#loadingWindow')[0].style.display = "inline";
};

function reloadLobby()
{
    game_state = GAME.LOBBY;
    network.game.id = null;
    network.game.name = "";
    // set focus on input
	$('#lobbyChatInput')[0].style.visibility = 'visible';
    $('#lobbyChatInput')[0].focus();
    fadeIn($('#statisticsWindow'));
    fadeOut($('#optionsWindow'));
    $('#lobbySaveReplayButton')[0].style.display = (game && game.getReplayFile()) ? "inline" : "none";
    // tell the server were out
    network.send("leave-game");
}
function MapEditorData()
{
	$("#mapEditorData").remove();
	$("#dataAddListWindow").remove();
	$("#dataNewObjectWindow").remove();
	
	this.window = new UIWindow("mapEditorData", function(){ return game_state == GAME.EDITOR; }, true, "Data", true);
	elements.push(this.window);
	this.window.addScrollableSubDiv("mapEditorDataSubDiv");
	
	
	// make windows draggable (with jquery ui)
	$("#mapEditorData").draggable({
		drag: onDrag,
		cancel: "p, input, select, textarea, button, #personalTextDiv, .nodrag"
	});
	
	
	// create riders
	var riders = document.createElement("div");
	riders.id = "dataRiders";
	
	riders.appendChild(uimanager.createButton("dataUnitsButton", "Units", function(){
		mapEditorData.switchRider(0);
		soundManager.playSound(SOUND.CLICK);
	}));
	
	riders.appendChild(uimanager.createButton("dataBuildingsButton", "Buildings", function(){
		mapEditorData.switchRider(1);
		soundManager.playSound(SOUND.CLICK);
	}));
	
	riders.appendChild(uimanager.createButton("dataCommandsButton", "Abilities", function(){
		mapEditorData.switchRider(2);
		soundManager.playSound(SOUND.CLICK);
	}));
	
	riders.appendChild(uimanager.createButton("dataUpgradesButton", "Upgrades", function(){
		mapEditorData.switchRider(3);
		soundManager.playSound(SOUND.CLICK);
	}));
	
	riders.appendChild(uimanager.createButton("dataModifiersButton", "Modifiers", function(){
		mapEditorData.switchRider(4);
		soundManager.playSound(SOUND.CLICK);
	}));
	
	riders.appendChild(uimanager.createButton("dataGraphicsButton", "Graphics", function(){
		mapEditorData.switchRider(5);
		soundManager.playSound(SOUND.CLICK);
	}));
	
	$('#mapEditorDataSubDiv').append(riders);
	
	this.types = [
		game.unitTypes,
		game.buildingTypes,
		game.commands,
		game.upgrades,
		game.modifiers,
		game.graphics
	];
	
	this.fields = [
		unit_fields,
		building_fields,
		ability_fields,
		upgrade_fields,
		modifiers_fields,
		imgs_fields
	];
	
	
	this.type = null;
	this.listIndex = 0;
	this.switchRider(0);
	
	
	// create types list
	var typesList = document.createElement("div");
	typesList.id = "typesList";
	$('#mapEditorDataSubDiv').append(typesList);
	
	// create fields table
	var fieldsTable = document.createElement("div");
	fieldsTable.id = "dataFieldsTable";
	$('#mapEditorDataSubDiv').append(fieldsTable);
	
	// create new object window
	var dataNewObjectWindow = new UIWindow("dataNewObjectWindow", function(){ return true; }, true, "New Object", true);
	var dataNewObjectWindowSubdiv = dataNewObjectWindow.addScrollableSubDiv("dataNewObjectWindowSubdiv");
	dataNewObjectWindowSubdiv.innerHTML = "<br />Clone from <select id='dataNewObjectSelect'></select><br />";
	dataNewObjectWindowSubdiv.innerHTML += "<span title='A unique string (only lower case letters) to refer to the unit'>ID String: </span><input id='dataNewObjectInput' type='text' /><br />";
	dataNewObjectWindowSubdiv.innerHTML += "<span title='The unit's name, has to be unique'>Name: </span><input id='dataNewObjectInputName' type='text' /></br /><br />";
	var newObjectOKButton = uimanager.createButton("newObjectOKButton", "create", function(){
		mapEditorData.createNewInstance();
		soundManager.playSound(SOUND.CLICK);
	});
	dataNewObjectWindowSubdiv.appendChild(newObjectOKButton);
	
	// new button
	var newButton = uimanager.createButton("dataNewButton", "new", function(){
		fadeIn($('#dataNewObjectWindow'));
		soundManager.playSound(SOUND.CLICK);
		
		var html = "";
		var types = mapEditorData.types[mapEditorData.listIndex];
		for(var i = 0; i < types.length; i++)
			html += "<option value='" + types[i].id_string + "'>" + types[i].name + "</option>";
		$('#dataNewObjectSelect').html(html);
	});
	newButton.title = "Create a new type";
	$('#mapEditorData').append(newButton);
	
	// delete button
	var dataDeleteButton = uimanager.createButton("dataDeleteButton", "delete", function(){
		soundManager.playSound(SOUND.CLICK);
		var typeToDelete = mapEditorData.type;
		
		if(typeToDelete.getBasicType())
		{
			displayInfoMsg("you cant delete the basic units");
			return;
		}
		
		displayInfoMsg("Delete type ?<br /><br /><button onclick=mapEditorData.killType()>reset</button>");
	});
	dataDeleteButton.title = "Delete the current selected type";
	$('#mapEditorData').append(dataDeleteButton);
	
	
	// reset button
	var dataResetButton = uimanager.createButton("dataResetButton", "reset", function(){
		soundManager.playSound(SOUND.CLICK);
		var typeToReset = mapEditorData.type;
		
		if(!typeToReset.getBasicType())
		{
			displayInfoMsg("you can only reset basic units");
			return;
		}
		
		displayInfoMsg("Reset type ?<br /><br /><button onclick=mapEditorData.resetType()>reset</button>");
	});
	dataResetButton.title = "Reset the current selected type";
	$('#mapEditorData').append(dataResetButton);
	
	// add list item window
	var dataAddListWindow = new UIWindow("dataAddListWindow", function(){ return true; }, true, "Add", true);
	var dataAddListWindowSubdiv = dataAddListWindow.addScrollableSubDiv("dataAddListWindowSubdiv");
	
	this.switchRider(0);
};

MapEditorData.prototype.killType = function()
{
	soundManager.playSound(SOUND.CLICK);
	
	var t = this.type;
	
	if(t.getBasicType())
	{
		displayInfoMsg("you cant delete basic units");
		return;
	}
	
	fadeOut($('#infoWindow'));
	
	game.unitTypes.erease(t);
	game.buildingTypes.erease(t);
	game.commands.erease(t);
	game.upgrades.erease(t);
	game.modifiers.erease(t);
	game.graphics.erease(t);
	
	// find all references 'n' delete 'em
	_.each(lists.types, function(type){
		_.each(type.getDataFields(), function(field){
			if(type[field.name] == t)
				type[field] = null;
			
			else if(field.isArray && Object.prototype.toString.call(type[field.name]) === '[object Array]')
				type[field.name].erease(t);
			
			else if(field.isObject)
				_.each(type[field.name], function(element, key){
					if(element == t)
						delete type[field.name][key];
				});
		});
	});
	
	if(mapEditorData.listIndex != 5)
	{
		delete lists.types[t.id_string];
		delete lists.unitTypes[t.id_string];
		delete lists.buildingTypes[t.id_string];
		delete lists.buildingsUpgrades[t.id_string];
		delete lists.modifiers[t.id_string];
		delete lists.upgrades[t.id_string];
		delete lists.commands[t.id_string];
	}
	else
		delete lists.imgs[t.id_string];
	
	this.switchRider(mapEditorData.listIndex);
	
	editor.createButtons();
};

MapEditorData.prototype.createNewInstance = function()
{
	var id_string = $('#dataNewObjectInput').val();
	var type = this.listIndex == 5 ? lists.imgs[$('#dataNewObjectSelect').val()] : lists.types[$('#dataNewObjectSelect').val()];
	var name = $('#dataNewObjectInputName').val();
	
	if((this.listIndex != 5 && !typeNameIsUnique(name)) || (this.listIndex == 5 && !graphicNameIsUnique(name)))
	{
		displayInfoMsg("there is already a unit with this name");
		return;
	}
	
	if(!name.match(/^[A-Za-z]+[A-Za-z ]*$/))
	{
		displayInfoMsg("invalid name (only letters)");
		return;
	}
	
	if(lists.types[id_string] || lists.imgs[id_string])
	{
		displayInfoMsg("this id string already exists");
		return;
	}
	
	if(!id_string.match(/^[a-z\_]+$/))
	{
		displayInfoMsg("invalid id string (only lower case letters and underscores)");
		return;
	}
	
	if(!type)
	{
		displayInfoMsg("invalid unit type");
		return;
	}
	
	fadeOut($('#dataNewObjectWindow'));
	
	var o = null;
	
	if(this.listIndex == 0)
		o = new UnitType(type);
	
	else if(this.listIndex == 1)
		o = new BuildingType(type);
	
	else if(this.listIndex == 2)
		o = new Command(type);
	
	else if(this.listIndex == 3)
		o = new Upgrade(type);
	
	else if(this.listIndex == 4)
		o = new Modifier(type);
	
	else if(this.listIndex == 5)
		o = new Graphic(type);
	
	o.id_string = id_string;
	o.name = name;
	
	this.types[this.listIndex].push(o);
	
	o.addToLists();
	
	calculateTypesTickValues();
	
	this.switchRider(this.listIndex);
	
	editor.createButtons();
	
	if(!o.noLogic)
		worker.postMessage({what: "newType", type: type.id_string, id_string: id_string, name: name, listIndex: this.listIndex});
};

MapEditorData.prototype.showDataAddListWindow = function()
{
	var list = "<select id='dataAddList'>";
	
	for(var i = 0; i < game.commands.length; i++)
		if(!game.commands[i].hide || true)
			list += "<option name='" + game.commands[i].id_string + "'>" + game.commands[i].name + "</option>";
	
	list += "</select><br /><button onclick='mapEditorData.saveListData(); soundManager.playSound(SOUND.CLICK);'>add</button>";
	
	$('#dataAddListWindowSubdiv').html(list);
	
	fadeIn($('#dataAddListWindow'));
};

MapEditorData.prototype.saveListData = function()
{
	var index = $('#dataAddList')[0].selectedIndex;
	
	$('.d_data_commands_div')[0].innerHTML += "<p name='" + game.commands[index].id_string + "'>" + game.commands[index].name + "<button onclick=deleteMapEditorDataElement(this)>X</button></p>";
	
	fadeOut($('#dataAddListWindow'));
	
	this.saveUnit();
};

MapEditorData.prototype.switchRider = function(type)
{
	if(type < 0)
		type = 0;
	
	if(type > this.types.length - 1)
		type = this.types.length - 1;
	
	$('#typesList').html("");
	
	this.listIndex = type;
	this.type = null;
	
	var types = _.sortBy(this.types[type], function(type){ return type.name; });
	
	for(var i = 0; i < types.length; i++)
		if(!types[i].isCommand || _.contains(EDITOR_COMMANDS, types[i].type))
		{
			var div = document.createElement("div");
			div.innerHTML = types[i].name
			div.title = "ID String: " + types[i].id_string;
			div.className = "dataTypeListDiv";
			div.index_ = types[i].id_string;
			
			if(!this.type)
			{
				this.type = types[i];
				div.className = "dataTypeListDivActive";
			}
			
			div.onclick = function(){
				mapEditorData.saveUnit();
				// reset active class
				soundManager.playSound(SOUND.CLICK);
				var children = $('#typesList').children();
				for(var k = 0; k < children.length; k++)
					children[k].className = "dataTypeListDiv";
				mapEditorData.type = mapEditorData.types[mapEditorData.listIndex] == game.graphics ? lists.imgs[this.index_] : lists.types[this.index_];
				mapEditorData.refreshFieldsTable(mapEditorData.type);
				this.className = "dataTypeListDivActive";
			};
			$('#typesList').append(div);
		}
	
	this.refreshFieldsTable(this.type);
};

function deleteMapEditorDataElement(el)
{
	el.parentNode.parentNode.removeChild(el.parentNode);
	mapEditorData.saveUnit();
	soundManager.playSound(SOUND.CLICK);
};

MapEditorData.prototype.fieldIsDefault = function(field, type)
{
	var value = type[field.name];
	var originValue = type.getBasicType ? type.getBasicType()[field.name] : "";
	
	if(typeof value === "undefined")
		value = field.isArray ? field.default2_ : field.default_;
	
	if(typeof originValue === "undefined")
		originValue = field.isArray ? field.default2_ : field.default_;
	
	if(field.type == "complex")
	{
		for(var field in value)
			if(Object.prototype.toString.call(value[field]) === '[object Array]' && value[field].length == 0)
				delete value[field];
				
		for(var field in originValue)
			if(Object.prototype.toString.call(originValue[field]) === '[object Array]' && originValue[field].length == 0)
				delete originValue[field];
		
		value = JSON.stringify(value);
		originValue = JSON.stringify(originValue);
	}
	
	else if(field.isArray)
	{
		if(value && value.length > 0 && value[0].id_string)
		{
			value = value.slice();
			for(var i = 0; i < value.length; i++)
				value[i] = value[i].id_string;
		}
		
		return arraysAreSame(value, originValue);
	}
	
	else if(field.type == "commands")
	{
		var arr1 = [];
		var arr2 = [];
		
		_.each(value, function(val, key){
			arr1.push(key);
		});
		
		_.each(originValue, function(val, key){
			arr2.push(key);
		});
		
		return arraysAreSame(arr1, arr2);
	}
		
	else if(field.name == "img" && isObject(value))
		originValue = lists.imgs[originValue];
	
	else if(field.name == "unitImg" && isObject(value))
	{
		value = value.id_string;
	}
	
	else if((field.name == "getTitleImage" || field.name == "image") && value && {}.toString.call(value) === '[object Function]')
	{
		value = value();
		originValue = lists.imgs[originValue] ? lists.imgs[originValue]() : originValue;
	}
	
	else if(isObject(value) && typeof originValue == "string")
		value = value.id_string;
	
	else if(field.type == "float")
	{
		value = Math.floor(value * 1000000) / 1000000;
		originValue = Math.floor(originValue * 1000000) / 1000000;
	}
	
	return value == originValue;
};

function showPreviewImg(el, img_key)
{
	$("#imgPreview_" + el).attr("style", getPreviewImg(img_key));
};

function getPreviewImg(img_key)
{
	var img = lists.imgs[img_key] ? lists.imgs[img_key].getTitleImage(1) : null;
	var file = null;
	
	if(!img)
		return "";
	
	if(img.file.toDataURL)
		file = img.file.toDataURL();
	
	else if(img.file.src)
		file = img.file.src;
	
	else
		return "";
	
	var w = img.w;
	var h = img.h;
	
	if(w > h)
	{
		h = 60 * (h / w);
		w = 60;
	}
	else
	{
		w = 60 * (w / h);
		h = 60;
	}
	
	var scale = w / img.w;
	
	var w2 = img.file.width * (w / img.w);
	var h2 = img.file.height * (h / img.h);
	var x = img.x * scale;
	var y = img.y * scale;
	
	return "background: url(" + file + "); background-position: " + -x + "px " + -y + "px; background-size: " + (img.file.width * scale) + "px " + (img.file.height * scale) + "px; width: " + w + "px; height: " + h + "px;";
};

MapEditorData.prototype.refreshFieldsTable = function(type)
{
	var fields = this.fields[this.listIndex];
	
	var str = "<table id='main_data_table'>";
	
	for(var i = 0; i < fields.length; i++)
		if(!type || !type.isCommand || ability_type_fields[type.type].indexOf(fields[i].name) >= 0) // abilities dont always show all fields, but only some depending on their type
		{
			var field = fields[i];
			var startGroup = field.group;
			var startI = i;
			var vals = field.isArray ? (Object.prototype.toString.call(type[field.name]) === "[object Array]" ? type[field.name] : []) : [type[field.name]];
			
			str += "<tr><td title='" + (field.groupDescription ? field.groupDescription : field.description) + "'><span " + (this.fieldIsDefault(field, type) ? "" : "class='notDefault'") + ">";
			str += (startGroup ? startGroup : field.name) + (field.isArray ? " (list)" : "") + "</span></td><td " + (startGroup ? ("class='gr_" + startGroup + "'") : "") + "id='dataSpan" + i + "'>";
			
			for(var j = 0; j < vals.length; j++)
			{
				str += "<span>";
				
				while(startI == i || (startGroup && fields[i] && fields[i].group == startGroup))
				{
					var vals2 = fields[i].isArray ? (Object.prototype.toString.call(type[fields[i].name]) === "[object Array]" ? type[fields[i].name] : []) : [type[fields[i].name]];
					str += (fields[i].subName ? ("<span title='" + fields[i].description + "'>" + fields[i].subName + "</span>: ") : "") + "<span class='d_"+ fields[i].name + "'>" + this.getFieldHTMLCode(fields[i], vals2[j], j, type) + "</span> ";
					i++;
				}
				
				if(field.isArray)
					str += "<button onclick=deleteMapEditorDataElement(this)>X</button></span><br />";
				
				i = startI;
			}
			
			while(startGroup && fields[i + 1] && fields[i + 1].group == startGroup)
				i++;
			
			if(field.isArray)
				str += "<button onclick='mapEditorData.addField_(" + startI + ", " + i + ");'>add</button>";
			
			str += "</td></tr>";
		}
	
	str += "</table>";
	
	$('#dataFieldsTable').html(str);
};

MapEditorData.prototype.addField_ = function(i, i2)
{
	soundManager.playSound(SOUND.CLICK);
	var str = "<span>";
	
	for(var k = i; k <= i2; k++)
		str += "<span class='d_"+ this.fields[this.listIndex][k].name + "'>" + mapEditorData.getFieldHTMLCode(this.fields[this.listIndex][k]) + "</span> ";
	
	document.getElementById("dataSpan" + i).innerHTML += str + "<button onclick=deleteMapEditorDataElement(this);>X</button></span>";
	mapEditorData.saveUnit();
};

MapEditorData.prototype.addField2_ = function(el, fieldName)
{
	soundManager.playSound(SOUND.CLICK);
	$("<span><input name='data_holding_field' data-fieldname='" + fieldName + "' type='text' onchange='mapEditorData.saveUnit();' value='0' /> <button onclick=deleteMapEditorDataElement(this)>X</button><br /></span>").insertBefore(el);
};


MapEditorData.prototype.getFieldHTMLCode = function(field, value, index, type)
{
	if(value === undefined)
		value = field.default_;
	
	var str = "";
	
	// if a selection field, display all da single values
	if(field.type == "selection")
	{
		var selected_key = "";
		var function_ = (field.special && field.special == "imgPreview") ? "showPreviewImg(\"" + field.name + "\", $(this).find(\":selected\").text());" : "";
		str += "<select onchange='mapEditorData.saveUnit(); " + function_ + "' name='data_holding_field' class='dataSelect'>";
		_.each(field.values, function(val, key){
			var title = field.descriptions ? field.descriptions[key] : "";
			if(value == val && field.special && field.special == "imgPreview")
				selected_key = key;
			str += "<option title='" + title + "' " + ((value == val) ? " selected='selected' " : "") + ">" + key + "</option>";
		});
		str += "</select>" + ((field.special && field.special == "imgPreview") ? " <div id='imgPreview_" + field.name + "' style='" + getPreviewImg(selected_key) + "' />" : "");
	}
	
	else if(field.type == "complex")
	{
		for(var i = 0; i < field.values.length; i++)
		{
			var field2 = field.values[i];
			var value2 = (value && value[field2.name]) ? value[field2.name] : field2.default_;
			
			str += "<span title='" + field2.description + "'>" + field2.name + ": </span>";
			
			if(field2.isArray)
			{
				for(var k = 0; k < value2.length; k++)
					str += "<span><input class='numberWidth' name='data_holding_field' data-fieldname='" + field2.name + "' type='text' onchange='mapEditorData.saveUnit();' value='" + value2[k] + "' /><button onclick=deleteMapEditorDataElement(this)>X</button> </span>";
				str += "<button onclick='mapEditorData.addField2_(this, \"" + field2.name + "\");'>add</button>";
			}
			
			else
			{
				str += "<input name='data_holding_field' data-fieldname='" + field2.name + "' type='text' class='numberWidth' onchange='mapEditorData.saveUnit();' value='" + value2 + "' /> ";
			}
		}
	}
	
	// if boolen, just make a checkbox
	else if(field.type == "bool")
	{
		var checked = value ? " checked=checked " : "";
		str += "<input onchange='mapEditorData.saveUnit();' name='data_holding_field' type='checkbox' " + checked + ">";
	}
	
	// if commands array
	else if(field.type == "commands")
	{
		str += "<div class='d_data_commands_div'>";
		
		_.each(value, function(val){
			str += "<p name='" + val.id_string + "'>" + val.name + "<button onclick=deleteMapEditorDataElement(this)>X</button></p>";
		});
		
		str += "</div><p><button onclick='mapEditorData.showDataAddListWindow(); soundManager.playSound(SOUND.CLICK);'>add</button></p>";
	}
	
	// else (single string, float or int, make a simple input)
	else
	{
		// set default val, if undfined
		var val = typeof value === "undefined" ? field.default_ : value;
		
		if(field.displayScale)
			val *= field.displayScale;
		
		if(field.name == "effectsModifications" && type)
		{
			var type2 = type.effectsTypes ? type.effectsTypes[index] : null;
			var fieldName = type.effectsFields ? type.effectsFields[index]: null;
			
			var dataField = type2 ? type2.getDataFields() : null;
			
			if(dataField && dataField[fieldName] && dataField[fieldName].displayScale)
				val *= dataField[fieldName].displayScale;
		}
		
		if(field.name == "modifications" && type)
		{
			var fieldName = type.fields ? type.fields[index]: null;
			var dataField = lists.types.soldier.getDataFields();
			
			if(dataField && dataField[fieldName] && dataField[fieldName].displayScale)
				val *= dataField[fieldName].displayScale;
		}
		
		var htmlAttributes = "type='text'";
		
		if(field.type == "string" && field.max_len)
			htmlAttributes += " maxlength='" + field.max_len + "' style='width: " + Math.min(field.max_len * 8, 400) + "px;' ";
		
		var realTimeCompile = field.realTimeCompile ? "realTimeCompile(this, \"" + field.compilerType + "\");" : "";
		var realTimeCompileTitle = "";
		if(field.realTimeCompile)
		{
			var parseResult = new Compiler(field.compilerType).parse(val);
			realTimeCompileTitle = " title='" + (parseResult[0] ? "condition is ok" : parseResult[1]) + "' ";
		}
		
		str += "<input onchange='mapEditorData.saveUnit(); " + realTimeCompile + "' onkeypress='" + realTimeCompile + "' onkeyup='" + realTimeCompile + "' onload='" + realTimeCompile + "' " + realTimeCompileTitle;
		str += " name='data_holding_field' class='mapDataInput " + (field.type == "string" ? "strWidth" : "numberWidth") + "' " + htmlAttributes + " value='" + (val.replace ? val.replace(/'/g, "") : val) + "' />";
	}
	
	return str;
};

MapEditorData.prototype.resetType = function()
{
	soundManager.playSound(SOUND.CLICK);
	
	fadeOut($('#infoWindow'));
	
	var type = this.type;
	var fields = type.getDataFields();
	var basicType = type.getBasicType();
	
	if(!basicType)
	{
		displayInfoMsg("only basic units can be resetted to default");
		return;
	}
	
	_.each(fields, function(field){
		
		if(field.name in basicType)
			type[field.name] = basicType[field.name];
		
		else if(fields[field.name])
			type[field.name] = fields[field.name].default2_ ? fields[field.name].default2_ : (fields[field.name].isArray ? [] : fields[field.name].default_);
		
		if(Object.prototype.toString.call(type[field.name]) === '[object Array]')
			type[field.name] = type[field.name].slice();
		
		else if(isObject(type[field.name]))
			type[field.name] = copyObject(type[field.name]);
			
	});
	
	type.replaceReferences();
	
	this.refreshFieldsTable(this.type);
	
	editor.createButtons();
};

MapEditorData.prototype.saveUnit = function()
{
	var type = this.type;
	var fields = this.fields[this.listIndex];
	
	for(var i = 0; i < fields.length; i++)
		if($('#dataSpan' + i)[0] || (fields[i].group && $('.gr_' + fields[i].group)[0]))
		{
			var field = fields[i];
			
			if(field.type == "commands")
			{
				type[field.name] = {};
				var arr = [];
				
				var children = $('.d_data_commands_div').children();
				for(var k = 0; k < children.length; k++)
				{
					var name = children[k].getAttribute("name");
					if(name !== null)
					{
						type[field.name][name] = lists.types[name];
						arr.push(name);
					}
				}
				
				if(field.logic)
					worker.postMessage({what: "updateDataField", type: type.id_string, field: field.name, val: arr, commands: true});
			}
			
			else
			{
				var vals = $('.d_' + field.name).find('*[name=data_holding_field]').toArray();
				var toSend = null;
				
				if(field.isArray)
				{
					toSend = [];
					type[field.name] = [];
					
					for(var k = 0; k < vals.length; k++)
					{
						var val = field.type == "bool" ? vals[k].checked : vals[k].value;
						
						if(field.type == "selection")
							val = field.values[val];
						
						val = checkField(field, val);
						
						if(field.displayScale)
							val /= field.displayScale;
						
						if(field.name == "effectsModifications")
						{
							var typeName = $('.d_effectsTypes').find('*[name=data_holding_field]').eq(k).val();
							var fieldName = $('.d_effectsFields').find('*[name=data_holding_field]').eq(k).val();
							
							var dataField = lists.types[typeName] ? lists.types[typeName].getDataFields() : null;
							
							if(dataField && dataField[fieldName] && dataField[fieldName].displayScale)
								val /= dataField[fieldName].displayScale;
						}
						
						if(field.name == "modifications" && type)
						{
							var fieldName = $('.d_fields').find('*[name=data_holding_field]').eq(k).val();
							var dataField = lists.types.soldier.getDataFields();
							
							if(dataField && dataField[fieldName] && dataField[fieldName].displayScale)
								val /= dataField[fieldName].displayScale;
						}
						
						type[field.name].push(val);
						
						if(isObject(val) && val.isTargetRequirement)
							toSend.push(val.funcName);
						else
							toSend.push((isObject(val) && val.id_string) ? val.id_string : val);
					}
				}
				
				else if(field.type == "complex")
				{
					var obj = {};
					for(var k = 0; k < vals.length; k++)
					{
						var fieldName = vals[k].getAttribute("data-fieldname");
						var field_ = null;
						for(var j = 0; j < field.values.length; j++)
							if(field.values[j].name == fieldName)
								field_ = field.values[j];
						
						if(field_ && field_.isArray)
						{
							if(obj[field_.name])
								obj[field_.name].push(checkField(field_, vals[k].value));
							
							else
								obj[field_.name] = [checkField(field_, vals[k].value)];
						}
						
						else
							obj[field_.name] = checkField(field_, vals[k].value);
					}
					
					type[field.name] = obj;
				}
				
				else
				{
					var val = field.type == "bool" ? vals[0].checked : vals[0].value;
					
					if(field.type == "selection")
						val = field.values[val];
					
					else
					{
						val = checkField(field, val);
						
						if(field.displayScale)
							val /= field.displayScale;
					}
					
					if(field.name == "name" && !typeNameIsUnique(val))
					{
						val = type[field.name];
						$('.d_name').children('*[name=data_holding_field]').toArray()[0].value = val;
					}
					
					type[field.name] = val;
					toSend = (isObject(val) && val.id_string) ? val.id_string : val;
				}
				
				if(field.logic)
					worker.postMessage({what: "updateDataField", type: type.id_string, field: field.name, val: toSend});
			}
		}
	
	calculateTypesTickValues();
	
	// replacing references
	_.each(lists.types, function(t){
		if(t.replaceReferences)
			t.replaceReferences();
	});
	
	// update button
	for(var k = 0; k < interface_.buttons.length; k++)
		if(interface_.buttons[k].command == type)
			interface_.buttons[k].init(type);
	
	this.refreshFieldsTable(this.type);
};
// a team pretty much only holds information regarding the vision
function Team(nr)
{
	this.number = nr;
	
	// fog mask & block array
	this.mask = [];
	this.blockArray = [];
	for(var x = 0; x <= game.x + 1; x++)
	{
		this.blockArray[x] = [];
		this.mask[x] = [];
		for(var y = 0; y <= game.y + 1; y++)
		{
			this.mask[x][y] = 0;
			this.blockArray[x][y] = true;
			if(x < 1 || x > game.x || y < 1 || y > game.y) // if outside borders
				this.blockArray[x][y] = false;
		}
	}
};

Team.prototype.fieldIsBlocked = function(x, y)
{
	return !(x > 0 && x <= game.x && y > 0 && y <= game.y && this.blockArray[x][y] && game.fields[x][y].hm == parseInt(game.fields[x][y].hm));
};

Team.prototype.fieldIsBlockedForBuilding = function(x, y)
{
	return this.fieldIsBlocked(x, y);
};

Team.prototype.canSeeField = function(x, y)
{
	return this.mask[x] && this.mask[x][y] > 1;
};

Team.prototype.canSeeUnitInvisible = function(unit)
{
	return (unit.owner.team == this || !unit.getValue("isInvisible") || unit.isDetectedUntil >= ticksCounter || unit.owner.team.number == 0) && !unit.getValue("noShow");
};

// returns true, if the team can see a specific unit (if onlyNow is flagged, only return true, if the unit is currently in the LoS of the team)
Team.prototype.canSeeUnit = function(unit, onlyNow)
{
	// if the team owns this unit, return true of course
	if(unit.owner.team == this || game_state == GAME.EDITOR)
		return true;
	
	// if its a unit, return true when the units is inside of the line of sight of the team
	if(!unit.type.isBuilding)
		return this.mask[unit.pos.x][unit.pos.y] > 1 || unit.revealedToTeamUntil[this.number] >= ticksCounter;
	
	// if its a building
	else
	{
		if(unit.owner.isRevealed)
			return true;
		
		// if not only now, just return seenBy
		if(!onlyNow)
			return unit.seenBy[this.number];
		
		// if only now, check line of sight for all the fields, the building contains; also set seen by = true, if it is seen
		for(var x = unit.x; x < unit.x + unit.type.size; x++)
			for(var y = unit.y; y < unit.y + unit.type.size; y++)
				if(this.mask[x][y] > 1)
					return unit.seenBy[this.number];
		
		return false;
	}
};
function Query(name)
{
	this.name = name;
	
	this.domElement = document.createElement("div");
	this.domElement.className = "query ingameWindow";
	this.domElement.style.left = Math.floor(Math.random() * 100 + 100) + "px";
	this.domElement.style.top = Math.floor(Math.random() * 100 + 100) + "px";
	document.body.appendChild(this.domElement);
	
	// get this element on top (higher z index, while lowering all the others queries')
	this.domElement.onclick = function(){
		for(var i = 0; i < uimanager.queries.length; i++)
			uimanager.queries[i].domElement.style.zIndex = "101";
		
		this.style.zIndex = "102";
	}
	this.domElement.onclick();
	
	// make querys draggable (with jquery ui)
	$(".query").draggable({
		drag: onDrag,
		cancel: "p, input"
	});
	
	// make sub div text area
	this.textArea = document.createElement('div');
	this.textArea.className = "textContainer queryTextContainer";
	this.domElement.appendChild(this.textArea);
	
	// add title
	var title = document.createElement("h2");
	title.innerHTML = "&raquo; Chat: " + name;
	title.className = "windowTitle";
	this.domElement.appendChild(title);
	
	// create close button
	var closeButton = document.createElement('button');
	closeButton.className = "closeButton";
	closeButton.innerHTML = "X";
	closeButton.parent_ = this;
	closeButton.onclick = function(){
		soundManager.playSound(SOUND.CLICK);
		this.parent_.kill();
	};
	// add it to the window
	this.domElement.appendChild(closeButton);
	
	// create minimize button
	var minimizeButton = document.createElement("button");
	minimizeButton.className = "minimizeButton";
	minimizeButton.innerHTML = "_";
	minimizeButton.parent_ = this;
	minimizeButton.onclick = function(){
		soundManager.playSound(SOUND.CLICK);
		
		if(this.parent_.i.style.display != "none")
		{
			this.parent_.domElement.style.height = "70px";
			this.parent_.i.style.display = "none";
			this.innerHTML = "&#9633;";
		}
		else
		{
			this.parent_.domElement.style.height = "400px";
			this.parent_.i.style.display = "inline";
			this.innerHTML = "_";
			
			if(parseInt(this.parent_.domElement.style.top) + 400 > HEIGHT - 10)
				this.parent_.domElement.style.top = (HEIGHT - 10 - 400) + "px";
		}
	}
	// add it to the window
	this.domElement.appendChild(minimizeButton);
	
	// make it close on escape
	this.domElement.parent_ = this;
	this.domElement.onkeydown = function(e){
		if(keyManager.getKeyCode(e) == KEY.ESC)
		{
			this.parent_.kill();
			soundManager.playSound(SOUND.SWITCH);
		}
	};
	
	// input
	this.i = document.createElement("input");
	this.i.type = "text";
	this.i.className = "queryInput";
	this.i.maxLength = 250;
	this.i.name_ = this.name;
	this.i.onkeydown = function(e){
		if(keyManager.getKeyCode(e) == KEY.ENTER && this.value.length > 0)
		{
			if(this.value == "/ping")
				timeOfLastPingSent = Date.now();
			
			network.send("query<<$" + this.name_ + "<<$" + this.value);
			this.value = "";
		}
	}
	this.domElement.appendChild(this.i);
	
	soundManager.playSound(SOUND.CLICK);
	
	// set focus to input element
	this.i.focus();
	
	
	// add link to queries div
	var b = document.createElement("button");
	b.innerHTML = this.name;
	b.link_ = this;
	b.id = "queryLink_" + this.name;
	b.className = "queryButtonLink";
	b.onclick = function(){
		this.link_.activate();
		$("#queryLink_" + this.link_.name).removeClass("borderRed");
		soundManager.playSound(SOUND.CLICK);
	};
	$('#queriesWindowSubDiv').append(b);
	
	// remove noMessagesP
	if($('#noMessagesP'))
		$('#noMessagesP').remove();
	
	if(iAmMod || iAmAdmin)
	{
		var button = uimanager.createButton(null, "ban", function(){
			reallyBan(name);
		});
		this.domElement.appendChild(button);
		button.className = "inlineBanButton2";
	}
	
	if(open_queries == OPEN_QUERIES.NEVER || (open_queries == OPEN_QUERIES.NOT_INGAME && game_state == GAME.PLAYING))
		this.domElement.style.display = "none";
};

Query.prototype.addMsg = function(msg)
{
	this.textArea.innerHTML += "<p>" + msg + "</p>";
	this.textArea.scrollTop = this.textArea.scrollHeight;
	
	// make queries window button blink
	if($('#queriesWindow')[0].style.display == "none" && !queryButtonBlinkInterval && this.domElement.style.display == "none")
		queryButtonBlinkInterval = setInterval(function(){
			$("#friendsButton").toggleClass("backgroundRed");
		}, 1000);
	
	// make specific query link button blink
	if(this.domElement.style.display == "none" && !this.blinkTimer)
		$("#queryLink_" + this.name).addClass("borderRed");
};

Query.prototype.kill = function()
{
	fadeOut($(this.domElement));
};

Query.prototype.activate = function()
{
	this.domElement.onclick();
	fadeIn($(this.domElement));
};
function Effect()
{
	this.isEffect = true;
};

Effect.prototype.getYDrawingOffset = function()
{
	return this.pos.py;
};

// return true if building / tile is inside a drawn box on the screen
Effect.prototype.isInBox = function(x1, y1, x2, y2)
{
	return this.borderRight >= x1 && this.borderBottom >= y1 && this.borderLeft <= x2 && this.borderTop <= y2 + (this.height ? this.height : 0);
};

Effect.prototype.isInBoxVisible = Effect.prototype.isInBox;

Effect.prototype.isExpired = function()
{
	return ticksCounter > this.tickOfDeath;
};

Effect.prototype.attach = function(attachToUnit)
{
	if(attachToUnit && this.unit)
		this.unit.effectsToDraw.push(this);
	
	game.addToObjectsToDraw(this);
};





Arrow.prototype = new Effect();
function Arrow(data)
{
	if(!data.to)
		data.to = data.from;
	
	this.from = data.from.drawPos.getCopy();
	var targetPos = data.to.type ? data.to.drawPos.add3(0, -data.to.type.height) : data.to;
	this.pos = this.from;
	this.to = data.to;
	this.dist = this.from.distanceTo2(targetPos);
	this.len = (data.from && data.from.type) ? data.from.type.projectileLen : 0.2;
	this.tickStart = ticksCounter;
	this.lifeTime = this.dist / data.speed * 20;
	this.height = (data.from && data.from.type) ? data.from.type.projectileStartHeight : 0.25;
	this.tickOfDeath = ticksCounter + this.lifeTime;
	
	this.borderLeft = Math.min(this.from.px, targetPos.px);
	this.borderRight = Math.max(this.from.px, targetPos.px);
	this.borderTop = Math.min(this.from.py, targetPos.py);
	this.borderBottom = Math.max(this.from.py, targetPos.py);
	
	this.attach(data.attachToUnit);
	
	this.modId = data.modId;
};

Arrow.prototype.draw = function()
{
	var targetPos = this.to.type ? this.to.drawPos.add3(0, -this.to.type.height) : this.to;
	
	this.dist = this.from.distanceTo2(targetPos);
	
	var percentageDone = (ticksCounter + percentageOfCurrentTickPassed - this.tickStart) / (this.lifeTime + 0.75);
	
	var maxHeight = Math.max(this.dist - 1.5, 0) / 6;
	var stg = Math.max(Math.min((-(percentageDone * this.dist) + this.dist / 2) * maxHeight * 0.05, this.len / 2), -this.len / 2);
	height = (1 - percentageDone) * this.height - Math.pow((2 / this.dist) * (percentageDone * this.dist) - 1, 2) * maxHeight + maxHeight;
	
	var len = Math.sqrt(this.len * this.len - stg * stg);
	
	var pos1 = this.from.addNormalizedVector(targetPos, percentageDone * this.dist - len / 2);
	var pos2 = this.from.addNormalizedVector(targetPos, percentageDone * this.dist + len / 2);
	
	this.pos = pos1;
	
	if(PLAYING_PLAYER.team.canSeeField(this.pos.x, this.pos.y))
	{
		c.lineWidth = 0.75 * SCALE_FACTOR;
		c.strokeStyle = (game.theme && game.theme.arrowColor) ? game.theme.arrowColor : "#111111";
		c.beginPath();
		c.moveTo(pos1.px * FIELD_SIZE - game.cameraX, (pos1.py - height) * FIELD_SIZE - game.cameraY);
		c.lineTo(pos2.px * FIELD_SIZE - game.cameraX, (pos2.py - height - stg) * FIELD_SIZE - game.cameraY);
		c.stroke();
		c.closePath();
	}
};






CustomProjectile.prototype = new Effect();
function CustomProjectile(data)
{
	var targetPos = data.to.type ? data.to.drawPos.add3(0, -data.to.type.height) : data.to.add3(0, -game.getHMValue2(data.to.x, data.to.y) * CLIFF_HEIGHT);
	
	this.from = data.from.drawPos.getCopy();
	this.pos = this.from;
	this.to = data.to;
	this.dist = this.from.distanceTo2(targetPos);
	this.tickStart = ticksCounter;
	this.lifeTime = this.dist / data.speed * 20;
	this.height = data.from.type.projectileStartHeight;
	this.tickOfDeath = ticksCounter + this.lifeTime;
	this.playerNumber = (data.from.owner && data.from.owner.number) ? data.from.owner.number : 0;
	this.scale = data.scale ? data.scale : 1;
	
	this.borderLeft = Math.min(this.from.px, targetPos.px);
	this.borderRight = Math.max(this.from.px, targetPos.px);
	this.borderTop = Math.min(this.from.py, targetPos.py);
	this.borderBottom = Math.max(this.from.py, targetPos.py);
	
	this.addExplosion = data.addExplosion;
	
	var angle = this.from.getAngleTo(targetPos);
	this.direction = "";
	
	angle += angle < -Math.PI ? Math.PI * 2 : 0;
	angle -= angle > Math.PI ? Math.PI * 2 : 0;
	
	if(angle >= Math.PI * 3 / 8 && angle <= Math.PI * 5 / 8)
		this.direction = "s";
	else if(angle <= -Math.PI * 3 / 8 && angle >= -Math.PI * 5 / 8)
		this.direction = "n";
	else if(angle >= Math.PI * 7 / 8 || angle <= -Math.PI * 7 / 8)
		this.direction = "w";
	else if((angle <= Math.PI * 1 / 8 && angle >= 0) || (angle >= -Math.PI * 1 / 8 && angle <= 0))
		this.direction = "e";
	else if(angle <= Math.PI * 7 / 8 && angle >= Math.PI * 5 / 8)
		this.direction = "sw";
	else if(angle <= Math.PI * 3 / 8 && angle >= Math.PI * 1 / 8)
		this.direction = "se";
	else if(angle >= -Math.PI * 7 / 8 && angle <= -Math.PI * 5 / 8)
		this.direction = "nw";
	else
		this.direction = "ne";
	
	this.attach(data.attachToUnit);
	
	this.modId = data.modId;
	
	this.imgs = [imgs.fire1.img, imgs.fire2.img, imgs.fire3.img, imgs.fire4.img, imgs.fire5.img];
};

CustomProjectile.prototype.draw = function()
{
	var targetPos = this.to.type ? this.to.drawPos.add3(0, -this.to.type.height) : this.to.add3(0, -game.getHMValue2(this.to.x, this.to.y) * CLIFF_HEIGHT);
	
	this.dist = this.from.distanceTo2(targetPos);
	
	var percentageDone = (ticksCounter + percentageOfCurrentTickPassed - this.tickStart) / (this.lifeTime + 0.75);
	
	var maxHeight = Math.max(this.dist - 1.5, 0) / 6;
	height = ((1 - percentageDone) * this.height - Math.pow((2 / this.dist) * (percentageDone * this.dist) - 1, 2) * maxHeight + maxHeight) * 0.6;
	
	this.pos = this.from.addNormalizedVector(targetPos, percentageDone * this.dist);
	var img = arrowImg[this.direction][percentageDone > 0.5 ? 1 : 0];
	
	var scale = SCALE_FACTOR * this.scale;
	
	if(PLAYING_PLAYER.team.canSeeField(this.pos.x, this.pos.y))
		c.drawImage(buildingSheet[this.playerNumber], img.x, img.y, img.w, img.h, this.pos.px * FIELD_SIZE - game.cameraX - img.w * scale / 2, (this.pos.py - height) * FIELD_SIZE - game.cameraY - img.h * scale / 2, img.w * scale, img.h * scale);
	
	if(!this.addExplosion || !this.isExpired())
		return;
	
	soundManager.playSound(SOUND.FLAK, targetPos);
	
	// crate explosion
	for(var i = 0; i < 10; i++)
		new Sprite({
			from: targetPos.add2(Math.random() * Math.PI * 2, Math.random() * 1.5).add3(0, 6.5),
			img: this.imgs[Math.floor(Math.random() * this.imgs.length)],
			scaleFunction: function(age){ return (1.5 / (age + 0.25) + age - 4) * (-1) + this.r1; },
			age: 0.6 + Math.random() * 0.5,
			r1: 1.0 + Math.random() / 2,
			height: 6.5
		});
	
	// crate zmoke
	for(var i = 0; i < 6; i++)
		new Sprite({
			from: targetPos.add2(Math.random() * Math.PI * 2, Math.random() * 1.5).add3(0, 6.5),
			img: lists.imgs.dust1,
			scaleFunction: function(age){ return (1.5 / (age + 0.25) + age - 4) * (-1) + this.r1; },
			age: 1.6 + Math.random() * 0.5,
			r1: 1.0 + Math.random() / 2,
			alphaFunction: function(age){ return 0.4; },
			height: 6.5
		});
};





DragonAttack.prototype = new Effect();
function DragonAttack(data)
{
	var targetPos = data.to.type ? data.to.drawPos.getCopy() : data.to;
	
	this.from = data.from.drawPos.addNormalizedVector(targetPos, data.from.type.size / 3);
	this.pos = this.from;
	this.to = data.to;
	this.dist = this.from.distanceTo2(targetPos);
	this.tickStart = ticksCounter;
	this.lifeTime = this.dist / (data.speed ? data.speed : 6) * 20;
	this.actualLifeTime = this.lifeTime;
	this.height = data.from.type ? data.from.type.height : 0;
	this.targetHeight = (this.to.type && this.to.type.isUnit) ? this.to.type.height : (game.getHMValue2(this.to.x, this.to.y) * CLIFF_HEIGHT + 0.3);
	this.scale = data.scale ? data.scale : 1;
	
	// if were shooting a building, make the "hit" a little bit earlier (when the projectile hit the wall of the building)
	if(this.to.type && this.to.type.isBuilding)
	{
		var angle = this.from.getAngleTo(this.to.pos);
		var size = this.to.type.size / 2;
		
		var distMinimization = Math.min(
			Math.sqrt(
				Math.pow(Math.tan(angle) * size, 2) + Math.pow(size, 2)
			),
			Math.sqrt(
				Math.pow((1 / Math.tan(angle)) * size, 2) + Math.pow(size, 2)
			)
		);
		
		this.actualLifeTime = (this.dist - distMinimization - 0.4) / (data.speed ? data.speed : 6) * 20;
	}
	
	this.tickOfDeath = ticksCounter + this.actualLifeTime;
	
	this.borderLeft = Math.min(this.from.px, targetPos.px);
	this.borderRight = Math.max(this.from.px, targetPos.px);
	this.borderTop = Math.min(this.from.py, targetPos.py);
	this.borderBottom = Math.max(this.from.py, targetPos.py);
	
	this.attach(data.attachToUnit);
	
	this.modId = data.modId;
	
	this.imgs = [imgs.fire1.img, imgs.fire2.img, imgs.fire3.img, imgs.fire4.img];
};

DragonAttack.prototype.draw = function()
{
	var targetPos = this.to.type ? this.to.drawPos.getCopy() : this.to;
	
	this.dist = this.from.distanceTo2(targetPos);
	
	var percentageDone = (ticksCounter + percentageOfCurrentTickPassed - this.tickStart) / (this.lifeTime + 1);
	var height = this.height + (this.targetHeight - this.height) * percentageDone;
	this.pos = this.from.addNormalizedVector(targetPos, percentageDone * this.from.distanceTo2(targetPos));
	
	if(PLAYING_PLAYER.team.canSeeField(this.pos.x, this.pos.y))
	{
		var scale = SCALE_FACTOR * this.scale;
		var drawX = this.pos.px * FIELD_SIZE - (imgs.fire5.img.w / 2) * scale - game.cameraX;
		var drawY = (this.pos.py - height) * FIELD_SIZE - (imgs.fire5.img.h / 2) * scale - game.cameraY;
		c.drawImage(miscSheet[0], imgs.fire5.img.x, imgs.fire5.img.y, imgs.fire5.img.w, imgs.fire5.img.h, drawX, drawY, imgs.fire5.img.w * scale, imgs.fire5.img.h * scale);
	}
	
	// randomly create flames
	for(var i = 0; i < tickDiff; i++)
		new Sprite({
			from: this.pos.add2(Math.random() * Math.PI * 2, 0.15),
			img: this.imgs[Math.floor(Math.random() * this.imgs.length)],
			scaleFunction: function(age){ return (age + 1) * this.scale_; },
			age: Math.random() + 0.5,
			height: height,
			scale_: this.scale
		});
	
	// randomly create smoke / dust
	for(var i = 0; i < tickDiff; i++)
		if(Math.random() > 0.5)
			new Dust({from: this.pos.add2(Math.random() * Math.PI * 2, 0.15), scale: 1 + Math.random(), ageScale: 2 + Math.random(), height: height});
	
	if(!this.isExpired())
		return;
	
	var pos = (this.to.type && this.to.type.isBuilding) ? this.pos.add3(0, 0.5) : targetPos.add3(0, 0.5);
	
	if(this.to.type && this.to.type.flying)
	{
		pos = pos.add3(0, 3);
		height += 3;
	}
	
	// create impact flames
	for(var i = 0; i < 4; i++)
		new Sprite({
			from: pos.add2(Math.random() * Math.PI * 2, Math.random() * 0.75),
			img: this.imgs[Math.floor(Math.random() * this.imgs.length)],
			scaleFunction: function(age){ return (1 / (age + 0.25) + age - 4) * (-1) * this.scale_; },
			age: 1 + Math.random() * 2,
			height: height,
			scale_: this.scale
		});
	
	// create impact smoke
	for(var i = 0; i < 2; i++)
		new Dust({from: pos.add2(Math.random() * Math.PI * 2, Math.random() * 1), scale: 1.5 + Math.random(), ageScale: 2 + Math.random(), height: height});
	
	// create soot
	if(this.to.type && this.to.type.isUnit && !this.to.type.flying)
	{
		pos = pos.add3(0, -0.5).add2(Math.random() * Math.PI * 2, Math.random() * 0.25);
		
		game.groundTilesCanvas.getContext('2d').globalAlpha = 0.35;
		game.groundTilesCanvas.getContext('2d').drawImage(miscSheet[0], imgs.soot.img.x, imgs.soot.img.y, imgs.soot.img.w, imgs.soot.img.h, pos.px * FIELD_SIZE / SCALE_FACTOR - imgs.soot.img.w / 4, (pos.py + 2) * FIELD_SIZE / SCALE_FACTOR - imgs.soot.img.h / 4, imgs.soot.img.w / 2, imgs.soot.img.h / 2);
		game.groundTilesCanvas.getContext('2d').globalAlpha = 1;
	}
};






Dust.prototype = new Effect();
function Dust(data)
{
	_.extend(this, data);
	
	this.height = this.height ? this.height : 0;
	this.scale = this.scale ? this.scale : 1;
	
	this.pos = this.from;
	
	this.x = this.pos.px;
	this.y = this.pos.py - this.height;
	
	this.particle = {
		x: Math.random() / 3 - 0.166,
		y: Math.random() / 20 - 1 / 40,
		vz: this.vz ? this.vz : Math.random() / 3 + 0.166,
		alpha: 0.75,
		img: Math.random() > 0.5 ? imgs.dust1.img : imgs.dust2.img,
		scale: Math.random() * 4 + 2,
		tickOfCreation: ticksCounter,
		timeToLive: (Math.random() * 650 + 800) * (this.ageScale ? this.ageScale : 1)
	};
	
	this.tickOfDeath = ticksCounter + this.particle.timeToLive / 50;
	
	this.borderLeft = this.pos.px;
	this.borderRight = this.pos.px;
	this.borderTop = this.pos.py;
	this.borderBottom = this.pos.py;
	
	this.attach(data.attachToUnit);
	
	this.modId = data.modId;
};

Dust.prototype.draw = function()
{
	var age = ((ticksCounter + percentageOfCurrentTickPassed) - this.particle.tickOfCreation) * 50;
	var percentageDone = age / this.particle.timeToLive;
	
	var y = this.particle.vz * (age / 1000) * this.scale;
	var scale = this.particle.scale * (percentageDone * 0.5 + 0.5) * this.scale * (SCALE_FACTOR / 4);
	
	if(this.yFunction)
		y += this.yFunction(age / 1000) * 0.75;
	
	var x = 0;
	if(this.xFunction)
		x = this.xFunction(age / 1000);
	
	if(PLAYING_PLAYER.team.canSeeField(this.pos.x, this.pos.y))
	{
		c.globalAlpha = Math.max(this.particle.alpha * (1 - percentageDone), 0);
		c.drawImage(miscSheet[0], this.particle.img.x, this.particle.img.y, this.particle.img.w, this.particle.img.h, (this.x + this.particle.x + x) * FIELD_SIZE - game.cameraX - this.particle.img.w * scale / 2, (this.y + this.particle.y - y) * FIELD_SIZE - game.cameraY - this.particle.img.w * scale / 2, this.particle.img.w * scale, this.particle.img.h * scale);
		c.globalAlpha = 1;
	}
};






Flame.prototype = new Effect();
function Flame(data)
{
	this.unit = (data.from && data.from.type) ? data.from : null;
	
	this.pos = this.unit ? this.unit.drawPos : data.from;
	this.tickOfDeath = ticksCounter + (Math.random() * 3 + 0.5) * 20;
	
	this.borderLeft = this.pos.px - 0.5;
	this.borderRight = this.pos.px + 0.5;
	this.borderTop = this.pos.py + 1.5;
	this.borderBottom = this.pos.py - 0.5;
	
	this.attach(data.attachToUnit);
	
	this.modId = data.modId;
	
	this.imgs = [imgs.fire1.img, imgs.fire2.img, imgs.fire3.img, imgs.fire4.img];
};

Flame.prototype.draw = function()
{
	if(this.unit)
		this.pos = this.unit.drawPos;
	
	for(var i = 0; i < tickDiff; i++)
		if(Math.random() < 0.06)
			new Sprite({
				from: this.pos.add2(Math.random() * Math.PI * 2, 0.1),
				img: this.imgs[Math.floor(Math.random() * this.imgs.length)],
				scaleFunction: function(age){ return 1 + age; },
				alphaFunction: function(age){ return 0.5; }
			});
	
	for(var i = 0; i < tickDiff; i++)
		if(Math.random() < 0.1)
			new Dust({from: this.pos, scale: 1 + Math.random(), ageScale: 2 + Math.random()});
};






Flamestrike.prototype = new Effect();
function Flamestrike(data)
{
	var targetPos = data.to.type ? data.to.pos.getCopy() : data.to;
	
	this.from = data.from.pos.getCopy();
	this.pos = this.from;
	this.to = data.to;
	this.dist = this.from.distanceTo2(targetPos);
	this.tickStart = ticksCounter;
	this.lifeTime = this.dist / (data.speed ? data.speed : 7) * 20;
	this.tickOfDeath = ticksCounter + this.lifeTime;
	this.noFinalBlow = data.noFinalBlow;
	this.scale = data.scale ? data.scale : 1;
	this.lastTimeSoot = ticksCounter;
	this.startHeight = data.from.type.height;
	this.endHeight = data.to.type ? data.to.type.height : 0.3;
	
	this.borderLeft = Math.min(this.from.px, targetPos.px);
	this.borderRight = Math.max(this.from.px, targetPos.px);
	this.borderTop = Math.min(this.from.py, targetPos.py);
	this.borderBottom = Math.max(this.from.py, targetPos.py);
	
	this.attach(data.attachToUnit);
	
	this.modId = data.modId;
	
	this.imgs = [imgs.fire1.img, imgs.fire2.img, imgs.fire3.img, imgs.fire4.img, imgs.fire5.img];
};

Flamestrike.prototype.draw = function()
{
	var targetPos = this.to.type ? this.to.pos.getCopy() : this.to;
	this.dist = this.from.distanceTo2(targetPos);
	
	this.vec = this.from.vectorTo(targetPos).normalize(0.7);
	
	var percentageDone = (ticksCounter + percentageOfCurrentTickPassed - this.tickStart) / (this.lifeTime + 1);
	this.pos = this.from.addNormalizedVector(targetPos, percentageDone * this.dist);
	
	var height = this.startHeight * (1 - percentageDone) + this.endHeight * percentageDone;
	
	var hm = game.getHMValue3(this.pos) * CLIFF_HEIGHT;
	
	var drawX = (this.pos.px + Math.random() * 0.1 - 0.05) * FIELD_SIZE - (imgs.fire5.img.w / 2) * SCALE_FACTOR * this.scale * (Math.random() * 0.2 + 0.9) - game.cameraX;
	var drawY = ((this.pos.py + Math.random() * 0.1 - 0.05 - height - hm) + Math.sin((ticksCounter + percentageOfCurrentTickPassed) * 0.4) * this.scale * 0.04) * FIELD_SIZE - (imgs.fire5.img.h / 2) * SCALE_FACTOR * this.scale * (Math.random() * 0.2 + 0.9) - game.cameraY;
	
	if(this.noFinalBlow && this.tickOfDeath - 10 < ticksCounter)
		c.globalAlpha = Math.max((this.tickOfDeath - ticksCounter) / 10, 0);
	
	if(PLAYING_PLAYER.team.canSeeField(this.pos.x, this.pos.y))
	{
		if(this.noFinalBlow)
		{
			var oldGlobalAlpha = c.globalAlpha;
			c.globalAlpha *= 0.15;
			var scale = SCALE_FACTOR * this.scale * 1.5 * (Math.random() * 0.2 + 0.9);
			var drawX2 = (this.pos.px + Math.random() * 0.1 - 0.05) * FIELD_SIZE - imgs.lightGround.img.w / 2 * scale - game.cameraX;
			var drawY2 = (this.pos.py + 0.5 + Math.random() * 0.1 - 0.05 - height - hm) * FIELD_SIZE - imgs.lightGround.img.h / 2 * scale - game.cameraY;
			c.drawImage(miscSheet[0], imgs.lightGround.img.x, imgs.lightGround.img.y, imgs.lightGround.img.w, imgs.lightGround.img.h, drawX2, drawY2, imgs.lightGround.img.w * scale, imgs.lightGround.img.h * scale);
			c.globalAlpha = oldGlobalAlpha;
		}
		
		c.drawImage(miscSheet[0], imgs.fire5.img.x, imgs.fire5.img.y, imgs.fire5.img.w, imgs.fire5.img.h, drawX, drawY, imgs.fire5.img.w * SCALE_FACTOR * this.scale, imgs.fire5.img.h * SCALE_FACTOR * this.scale);
		
		// soot
		if(this.noFinalBlow && this.lastTimeSoot < ticksCounter && height < 1)
		{
			var ctx = game.groundTilesCanvas.getContext('2d');
			ctx.globalAlpha = 0.05;
			ctx.drawImage(miscSheet[0], imgs.soot2.img.x, imgs.soot2.img.y, imgs.soot2.img.w, imgs.soot2.img.h, this.pos.px * FIELD_SIZE / SCALE_FACTOR - imgs.soot2.img.w / 2, (this.pos.py - hm + 2) * FIELD_SIZE / SCALE_FACTOR - imgs.soot2.img.h / 2, imgs.soot2.img.w, imgs.soot2.img.h);
			this.lastTimeSoot = ticksCounter;
			ctx.globalAlpha = 1;
		}
	}
	
	if(this.noFinalBlow && this.tickOfDeath - 10 < ticksCounter)
		c.globalAlpha = 1;
	
	// randomly create flames
	for(var i = 0; i < tickDiff; i++)
		new Sprite({
			from: this.pos.add2(Math.random() * Math.PI * 2, 0.15).add3(0, -hm),
			img: this.imgs[Math.floor(Math.random() * 4)],
			scaleFunction: function(age){ return (age + 1) * this.var1; },
			var1: Math.sqrt(this.scale),
			rX: Math.random() - 0.5 + this.vec.px,
			rY: Math.random() - 0.5 + this.vec.py,
			alphaFunction: function(age){ return 1; },
			xFunction: function(age){ return this.rX * Math.sqrt(age); },
			yFunction: function(age){ return this.rY * Math.sqrt(age); },
			height: height
		});
	
	// randomly create smoke / dust
	for(var i = 0; i < tickDiff; i++)
		if(Math.random() > 0.5)
			new Dust({from: this.pos.add2(Math.random() * Math.PI * 2, 0.15).add3(0, -hm), scale: 1 + Math.random(), ageScale: 2 + Math.random(), height: height});
	
	if(!this.isExpired() || this.noFinalBlow)
		return;
	
	// impact
	new Sprite({
		from: this.pos.add2(Math.random() * Math.PI * 2, Math.random() / 2).add3(0, -hm),
		img: this.imgs[Math.floor(Math.random() * this.imgs.length)],
		scaleFunction: function(age){ return (1 / (age + 0.25) + age - 4) * (-1) + 2; },
		age: 2,
		height: height
	});
	
	// create impact flames
	for(var i = 0; i < 13; i++)
	{
		new Sprite({
			from: this.pos.add2(Math.random() * Math.PI * 2, Math.random() * 1.75).add3(0, -hm),
			img: this.imgs[Math.floor(Math.random() * this.imgs.length)],
			scaleFunction: function(age){ return (1 / (age + 0.25) + age - 4) * (-1) + this.r1; },
			age: 1 + Math.random() * 2,
			r1: Math.random(),
			height: height
		});
	}
	
	// create impact zmoke
	for(var i = 0; i < 7; i++)
		new Dust({from: this.pos.add2(Math.random() * Math.PI * 2, Math.random() * 2).add3(0, -hm), scale: 1.5 + Math.random(), ageScale: 2 + Math.random(), height: height});
	
	// create soot
	if(height < 1)
	{
		game.groundTilesCanvas.getContext('2d').globalAlpha = 0.5;
		game.groundTilesCanvas.getContext('2d').drawImage(miscSheet[0], imgs.soot.img.x, imgs.soot.img.y, imgs.soot.img.w, imgs.soot.img.h, this.pos.px * FIELD_SIZE / SCALE_FACTOR - imgs.soot.img.w / 2, (this.pos.py - hm) * FIELD_SIZE / SCALE_FACTOR - imgs.soot.img.h / 2, imgs.soot.img.w, imgs.soot.img.h);
		game.groundTilesCanvas.getContext('2d').globalAlpha = 1;
		
		// create flames
		for(var i = 0; i < 2; i++)
			new Flame({from: this.pos.add2(Math.random() * Math.PI * 2, Math.random() * 2).add3(0, -hm)});
	}
};





GroundOrder.prototype = new Effect();
function GroundOrder(data)
{
	this.pos = data.from;
	this.time = timestamp;
	this.tickOfDeath = ticksCounter + 6;
	
	this.borderLeft = this.pos.px;
	this.borderRight = this.pos.px;
	this.borderTop = this.pos.py;
	this.borderBottom = this.pos.py;
	
	this.attach(data.attachToUnit);
	
	this.modId = data.modId;
};

GroundOrder.prototype.draw = function()
{
	var age = timestamp - this.time; // effect age in sec
	var randomYOffsetPixels = (age * 0.05) % 4 - 2;
	
	c.scale(1, 0.8);
	c.strokeStyle = "rgba(" + game.theme.line_red + ", " + game.theme.line_green + ", " + game.theme.line_blue + ", " + (1 - age / 400) + ")";
	c.lineWidth = 2;
	
	// draw "ring"
	c.beginPath();
	c.arc(this.pos.px * FIELD_SIZE - game.cameraX, (this.pos.py * FIELD_SIZE - game.cameraY + randomYOffsetPixels) / 0.8, age / 10, 0, 2 * Math.PI, false);
	c.stroke();
	
	// draw point
	c.beginPath();
	c.arc(this.pos.px * FIELD_SIZE - game.cameraX, (this.pos.py * FIELD_SIZE - game.cameraY + randomYOffsetPixels) / 0.8, 1, 0, 2 * Math.PI, false);
	c.stroke();
	
	c.scale(1, 1 / 0.8);
};






PlasmaShield.prototype = new Effect();
function PlasmaShield(data)
{
	this.pos = data.from.type ? data.from.drawPos : data.from;
	this.radius = (data.from.type ? data.from.type.size : 1) * 0.85;
	this.to = data.to;
	this.time = timestamp;
	this.tickOfDeath = ticksCounter + 10;
	
	this.borderLeft = this.pos.px;
	this.borderRight = this.pos.px;
	this.borderTop = this.pos.py;
	this.borderBottom = this.pos.py;
	
	this.attach(data.attachToUnit);
	
	this.modId = data.modId;
};

PlasmaShield.prototype.draw = function()
{
	var age = timestamp - this.time; // effect age in sec
	var randomYOffsetPixels = (age * 0.05) % 4 - 2;
	var angle = this.pos.getAngleTo(this.to);
	
	c.scale(1, 0.8);
	c.strokeStyle = "rgba(" + game.theme.line_red + ", " + game.theme.line_green + ", " + game.theme.line_blue + ", " + ((1 - age / 400) * 0.6) + ")";
	c.lineWidth = 1.5 * SCALE_FACTOR;
	
	c.beginPath();
	c.arc(this.pos.px * FIELD_SIZE - game.cameraX, ((this.pos.py - 0.2) * FIELD_SIZE - game.cameraY + randomYOffsetPixels) / 0.8, this.radius * FIELD_SIZE, angle - 0.5, angle + 0.5, false);
	c.arc(this.pos.px * FIELD_SIZE - game.cameraX, ((this.pos.py - 0.3) * FIELD_SIZE - game.cameraY + randomYOffsetPixels) / 0.8, this.radius * FIELD_SIZE, angle - 0.5, angle + 0.5, false);
	c.arc(this.pos.px * FIELD_SIZE - game.cameraX, ((this.pos.py - 0.4) * FIELD_SIZE - game.cameraY + randomYOffsetPixels) / 0.8, this.radius * FIELD_SIZE, angle - 0.5, angle + 0.5, false);
	c.stroke();
	
	c.scale(1, 1 / 0.8);
};






FloatingText.prototype = new Effect();
function FloatingText(data)
{
	this.unit = data.from.type ? data.from : null;
	
	this.pos = this.unit ? this.unit.drawPos.add3(0, -u.type.size - u.type.height + 1.5 + (u.type.isBuilding ? 2 : 0)) : data.from;
	this.tickOfCreation = ticksCounter;
	this.tickOfDeath = ticksCounter + (data.duration ? data.duration : 40);
	this.size = (data.scale ? data.scale : 20) / 3;
	this.content = data.content;
	this.color = data.color ? data.color : "white";
	
	this.borderLeft = this.pos.px - 2;
	this.borderRight = this.pos.px + 2;
	this.borderTop = this.pos.py + 2;
	this.borderBottom = this.pos.py - 1;
	
	this.attach(data.attachToUnit);
	
	this.modId = data.modId;
};

FloatingText.prototype.draw = function()
{
	if(this.tickOfDeath <= ticksCounter)
		return false;
	
	var age = ticksCounter + percentageOfCurrentTickPassed - this.tickOfCreation;
	
	var alpha = (this.tickOfDeath - ticksCounter < 10) ? Math.max(c.globalAlpha = (this.tickOfDeath - (ticksCounter + percentageOfCurrentTickPassed)) / 10, 0) : 1;
	
	drawText(c, this.content, this.color, "bold " + (this.size * SCALE_FACTOR) + "px LCDSolid", this.pos.px * FIELD_SIZE - game.cameraX, (this.pos.py - 0 - age / 40) * FIELD_SIZE - game.cameraY, 200, "center", alpha);
};







Heal.prototype = new Effect();
function Heal(data)
{
	this.unit = data.from.type ? data.from : null;
	
	this.pos = this.unit ? this.unit.drawPos.add3(0, 0.3 - this.unit.type.height) : data.from;
	this.x = this.pos.px;
	this.y = this.pos.py;
	this.tickOfCreation = ticksCounter;
	this.size = data.scale ? data.scale : 1;
	this.duration = data.duration ? data.duration : ((data.originPos.distanceTo2(this.pos) / (data.speed ? data.speed : 7)) * 20);
	if(!data.duration && !data.speed)
		this.duration = 0;
	this.tickOfDeath = ticksCounter + this.duration + 24;
	this.borderLeft = this.pos.px;
	this.borderRight = this.pos.px;
	this.borderTop = this.pos.py;
	this.borderBottom = this.pos.py;
	
	this.attach(data.attachToUnit);
	
	this.modId = data.modId;
	
	this.imgs = [imgs.heal2.img, imgs.heal3.img, imgs.heal4.img];
};

Heal.prototype.draw = function()
{
	if(this.tickOfCreation + this.duration > ticksCounter)
		return;
	
	if(this.unit)
		this.pos = this.unit.drawPos.add3(0, 0.3 - this.unit.type.height);
	
	var age = ((ticksCounter + percentageOfCurrentTickPassed) - (this.tickOfCreation + this.duration)) * 50;
	
	if(age < 1000)
		for(var i = 0; i < tickDiff; i++)
			new Sprite({
				from: this.pos.add2(Math.random() * Math.PI * 2, Math.random() * 0.4 * this.size).add3(0, 6.6),
				img: this.imgs[Math.floor(Math.random() * this.imgs.length)],
				scaleFunction: function(age){ return ((1 / ((age * 5) + 0.25) + (age * 5) - 4) * (-0.7) + 0.6) * this.var1 * 1.15; },
				age: 0.6 + Math.random() * 0.5,
				var1: this.size,
				zFunction: function(age){ return -age * 1 - 0.5; },
				height: 6.5
			});
	
	// draw circle
	c.globalAlpha = Math.max(1 - age / 1200, 0.01);
	drawCircle(this.x * FIELD_SIZE - game.cameraX, this.y * FIELD_SIZE - game.cameraY - 0.5, (age / 1400) * FIELD_SIZE * this.size, "#9DE9A4", false, false, 1.5);
	
	// draw circle 2
	var age2 = Math.max(0.01, age - 400);
	c.globalAlpha = Math.max(1 - age2 / 800, 0.01);
	drawCircle(this.x * FIELD_SIZE - game.cameraX, this.y * FIELD_SIZE - game.cameraY - 0.5, (age2 / 1200) * FIELD_SIZE * this.size, "white", false, false, 1.5);
	
	c.globalAlpha = 1;
};






LaunchedRock.prototype = new Effect();
function LaunchedRock(data)
{
	var targetPos = data.to.type ? data.to.drawPos.getCopy() : data.to;
	
	this.speed = data.speed ? data.speed : 7;
	this.from = data.from.drawPos.getCopy().add3(0, 0.3);
	this.pos = data.from;
	this.to = data.to;
	this.dist = this.from.distanceTo2(targetPos);
	this.tickStart = ticksCounter;
	this.lifeTime = this.dist / this.speed / 50 * 1000;
	this.actualLifeTime = (this.dist - 0.05) / this.speed * 20;
	this.startHeight = data.from.type.height;
	this.endHeight = data.to.type ? data.to.type.height : 0;
	this.scale = data.scale ? data.scale : 1;
	
	// if were shooting a building, make the "hit" a little bit earlier (when the rock hit the wall of the building)
	if(data.to.type && data.to.type.isBuilding)
	{
		this.endHeight -= 1;
		
		var angle = this.from.getAngleTo(targetPos);
		var size = data.to.type.size / 2;
		
		var distMinimization = Math.min(
			Math.sqrt(
				Math.pow(Math.tan(angle) * size, 2) + Math.pow(size, 2)
			),
			Math.sqrt(
				Math.pow((1 / Math.tan(angle)) * size, 2) + Math.pow(size, 2)
			)
		);
		
		this.actualLifeTime = (this.dist - distMinimization) / this.speed * 20;
	}
	
	this.tickOfDeath = ticksCounter + this.actualLifeTime;
	
	this.borderLeft = Math.min(this.from.px, targetPos.px);
	this.borderRight = Math.max(this.from.px, targetPos.px);
	this.borderTop = Math.min(this.from.py, targetPos.py);
	this.borderBottom = Math.max(this.from.py, targetPos.py);
	
	this.attach(data.attachToUnit);
	
	this.modId = data.modId;
	
	this.imgs = [imgs.flyingRock1.img, imgs.flyingRock2.img, imgs.flyingRock3.img, imgs.flyingRock4.img, imgs.flyingRock5.img, imgs.flyingRock6.img, imgs.flyingRock7.img, imgs.flyingRock8.img];
};

LaunchedRock.prototype.draw = function()
{
	var targetPos = this.to.type ? this.to.drawPos.getCopy() : this.to;
	
	this.dist = this.from.distanceTo2(targetPos);
	
	var percentageDone = (ticksCounter + percentageOfCurrentTickPassed - this.tickStart) / (this.lifeTime + 1);
	this.pos = this.from.addNormalizedVector(targetPos, percentageDone * this.dist);
	
	var height = this.startHeight * (1 - percentageDone) + this.endHeight * percentageDone;
	
	var img = this.imgs[Math.floor(this.tickStart + ticksCounter / 2) % this.imgs.length];
	
	// calculate additional heigh
	var y = Math.pow((percentageDone * 16.5 - 6 - this.dist / 10) / (9.6 + Math.pow(0.11 * (this.dist - 9), 2) - (3 * this.dist) / 9), 2) - 0.7 - this.dist / 6;
	
	var drawPos = this.pos.add3(0, y);
	
	var scale = this.scale * SCALE_FACTOR;
	
	var drawX = drawPos.px * FIELD_SIZE - (img.w / 2) * scale - game.cameraX;
	var drawY = (drawPos.py - height) * FIELD_SIZE - (img.h / 2) * scale - game.cameraY;
	if(PLAYING_PLAYER.team.canSeeField(this.pos.x, this.pos.y))
		c.drawImage(miscSheet[0], img.x, img.y, img.w, img.h, drawX, drawY, img.w * scale, img.h * scale);
	
	var flyVec = this.from.vectorTo(this.to).normalize(0.5);
	
	// randomly create particle images
	for(var i = 0; i < tickDiff; i++)
		if(Math.random() > 0.5)
			new Sprite({
				from: drawPos.add2(Math.random() * Math.PI * 2, 0.1),
				img: imgs.particle.img,
				scaleFunction: function(age){ return ((this.r1 + 1.4) - age) * this.scale_; },
				age: 1.5 + Math.random() * 0.7,
				r1: Math.random(),
				rX: flyVec.px,
				rY: flyVec.py,
				zFunction: function(age){ return Math.pow(age * 1.15, 2.5) * 0.5; },
				xFunction: function(age){ return this.rX * Math.sqrt(age); },
				yFunction: function(age){ return this.rY * Math.sqrt(age); },
				height: height,
				scale_: this.scale
			});
	
	if(!this.isExpired())
		return;
	
	// play sound
	if(PLAYING_PLAYER.team.canSeeField(this.pos.x, this.pos.y))
		soundManager.playSound(SOUND.CATA_IMPACT, this.pos);
	
	// create impact dust
	for(var i = 0; i < 5; i++)
		new Dust({from: this.pos.add2(Math.random() * Math.PI * 2, Math.random() * 0.6), scale: Math.random() * 1.5 + 0.5, height: height - y});
	
	// create impact sprites / particles
	for(var i = 0; i < 12; i++)
		new Sprite({
			from: this.pos.add2(Math.random() * Math.PI * 2, Math.random() * 0.3),
			img: imgs.particle.img,
			scaleFunction: function(age){ return 2 * this.scale_; },
			age: 0.5 + Math.random(),
			r1: Math.random() * 0.4,
			r2: -y,
			rX: Math.random() * 3.5 - 1.75,
			rY: Math.random() * 3.5 - 1.75,
			zFunction: function(age){ return Math.min(Math.pow(age * 1.6 - 0.8 + this.r1, 2) - 0.7 - this.r2, 0); },
			xFunction: function(age){ return this.rX * Math.sqrt(age); },
			yFunction: function(age){ return this.rY * Math.sqrt(age); },
			height: height,
			scale_: this.scale
		});
};






Mageattack.prototype = new Effect();
function Mageattack(data)
{
	var targetField = data.to.isField ? data.to : data.to.drawPos;
	
	this.from = data.from.drawPos.getCopy().add3(0, -0.1 - (data.from.type ? data.from.type.projectileStartHeight : 0));
	this.pos = data.from.drawPos.getCopy();
	this.to = data.to.isField ? data.to.getCopy() : data.to;
	this.dist = this.from.distanceTo2(targetField);
	this.tickStart = ticksCounter;
	this.lifeTime = this.dist / (data.speed ? data.speed : 10) / 50 * 1000;
	this.tickOfDeath = ticksCounter + this.lifeTime;
	this.startHeight = data.from.type.height;
	this.endHeight = this.to.type ? this.to.type.height : (game.getHMValue2(this.to.x, this.to.y) * CLIFF_HEIGHT + 0.3);
	this.scale = data.scale ? data.scale : 1;
	
	this.borderLeft = Math.min(this.from.px, targetField.px);
	this.borderRight = Math.max(this.from.px, targetField.px);
	this.borderTop = Math.min(this.from.py, targetField.py);
	this.borderBottom = Math.max(this.from.py, targetField.py);
	
	this.attach(data.attachToUnit);
	
	this.modId = data.modId;
	
	this.imgs = [imgs.mageAttack1.img, imgs.mageAttack2.img, imgs.mageAttack3.img, imgs.mageAttack4.img];
};

Mageattack.prototype.draw = function()
{
	var targetField = this.to.isField ? this.to : this.to.drawPos.getCopy();
	
	this.dist = this.from.distanceTo2(targetField);
	
	var percentageDone = (ticksCounter + percentageOfCurrentTickPassed - this.tickStart) / (this.lifeTime + 1);
	this.pos = this.from.addNormalizedVector(targetField, percentageDone * this.dist);
	
	var height = this.startHeight * (1 - percentageDone) + this.endHeight * percentageDone;
	
	var scale = SCALE_FACTOR + SCALE_FACTOR * (Math.random() * 0.4 + 0.8) * 0.55;
	var drawX = (this.pos.px + Math.random() * 0.15 - 0.075) * FIELD_SIZE - (imgs.mageAttack4.img.w / 2) * scale - game.cameraX;
	var drawY = (this.pos.py - height + 0.3 + Math.random() * 0.15 - 0.075) * FIELD_SIZE - (imgs.mageAttack4.img.h / 2) * scale - game.cameraY;
	if(PLAYING_PLAYER.team.canSeeField(this.pos.x, this.pos.y))
		c.drawImage(miscSheet[0], imgs.mageAttack4.img.x, imgs.mageAttack4.img.y, imgs.mageAttack4.img.w, imgs.mageAttack4.img.h, drawX, drawY, imgs.mageAttack4.img.w * scale, imgs.mageAttack4.img.h * scale);
	
	var flyVec = this.from.vectorTo(targetField).normalize(0.5);
	
	// randomly create magic stuff
	for(var i = 0; i < tickDiff; i++)
		new Sprite({
			from: this.pos.add2(Math.random() * Math.PI * 2, 0.1),
			img: this.imgs[Math.floor(Math.random() * this.imgs.length)],
			scaleFunction: function(age){ return 1 - age; },
			age: 0.7,
			varX: flyVec.px,
			varY: flyVec.py,
			zFunction: function(age){ return Math.pow(age * 1.5, 2) * 0.33 + 0.2; },
			xFunction: function(age){ return this.varX * Math.sqrt(age); },
			yFunction: function(age){ return this.varY * Math.sqrt(age); },
			height: height
		});
	
	if(!this.isExpired())
		return;
	
	// impact
	new Sprite({
		from: targetField.add2(Math.random() * Math.PI * 2, Math.random() / 2).add3(0, 0.9),
		img: this.imgs[Math.floor(Math.random() * this.imgs.length)],
		scaleFunction: function(age){ return (1 / (age + 0.25) + age - 4) * (-1); },
		age: 1,
		zFunction: function(){ return -0.9; },
		height: height
	});
	
	// create impact magic stuff
	for(var i = 0; i < 3; i++)
		new Sprite({
			from: targetField.add2(Math.random() * Math.PI * 2, Math.random()* 0.3).add3(0, 0.9),
			img: this.imgs[Math.floor(Math.random() * this.imgs.length)],
			scaleFunction: function(age){ return (1 / (age + 0.25) + age - 4) * (-0.5); },
			age: 0.5 + Math.random() * 0.5,
			zFunction: function(){ return -0.9; },
			height: height
		});
};






Shockwave.prototype = new Effect();
function Shockwave(data)
{
	this.pos = data.from;
	this.tickOfCreation = ticksCounter;
	this.duration = data.duration ? data.duration : ((data.originPos.distanceTo2(this.pos) / data.speed) * 20);
	this.durationInMS = this.duration * 50;
	this.tickOfDeath = ticksCounter + this.duration + 40;
	
	this.borderLeft = this.pos.px - 2;
	this.borderRight = this.pos.px + 2;
	this.borderTop = this.pos.py - 2;
	this.borderBottom = this.pos.py + 2;
	
	this.circleDuration = 900;
	this.circleOffsets = [0, 300, 600];
	
	this.attach(data.attachToUnit);
	
	this.modId = data.modId;
};

Shockwave.prototype.draw = function()
{
	var age = ((ticksCounter + percentageOfCurrentTickPassed) - this.tickOfCreation) * 50; 
	
	if(age < this.durationInMS)
	{
		for(var i = 0; i < tickDiff * 1; i++)
			new Sprite({
				from: this.pos.add2(Math.random() * Math.PI * 2, Math.random() * 1.5),
				img: imgs.whitePixel.img,
				scaleFunction: function(age){ return this.var1; },
				age: 3 + Math.random() * 1,
				var1: 1 + Math.random(),
				var2: Math.random() * 2 - 1,
				var3: Math.random() * 2 - 1,
				ageLeft: (this.durationInMS - age) / (this.durationInMS / 2),
				startHeight: Math.random() * 0.5 + 1.5,
				alphaFunction: function(age){ return Math.min(0.7, age); },
				zFunction: function(age){ return (age < this.ageLeft) ? Math.min(-this.startHeight + age * 1, 0) : ((-this.startHeight + this.ageLeft * 1) - (-1 / ((age - this.ageLeft) + 0.5) + 2 - (age - this.ageLeft) * 1.5)); },
				xFunction: function(age){ return (age < this.ageLeft) ? 0 : ((-1 / ((age - this.ageLeft) / 2 + 0.2) + 5) * this.var2); },
				yFunction: function(age){ return (age < this.ageLeft) ? 0 : ((-1 / ((age - this.ageLeft) / 2 + 0.2) + 5) * this.var3); }
			});
		
		for(var i = 0; i < tickDiff * 2; i++)
			new Sprite({
				from: this.pos.add2(Math.random() * Math.PI * 2, Math.random() * 0.5),
				img: imgs.whitePixel.img,
				scaleFunction: function(age){ return this.var1; },
				age: 3 + Math.random() * 1,
				var1: 1 + Math.random(),
				var2: Math.random() * 2 - 1,
				var3: Math.random() * 2 - 1,
				ageLeft: (this.durationInMS - age) / (this.durationInMS / 2),
				alphaFunction: function(age){ return Math.min(0.7, age); },
				zFunction: function(age){ return (age < this.ageLeft) ? 0 : -(-1 / ((age - this.ageLeft) + 0.5) + 2 - (age - this.ageLeft) * 1.5); },
				xFunction: function(age){ return (age < this.ageLeft) ? ((this.ageLeft - age) * this.var2 * 3) : ((-1 / ((age - this.ageLeft) / 2 + 0.2) + 5) * this.var2); },
				yFunction: function(age){ return (age < this.ageLeft) ? ((this.ageLeft - age) * this.var3 * 3) : ((-1 / ((age - this.ageLeft) / 2 + 0.2) + 5) * this.var3); }
			});
		
		// circles
		for(var i = 0; i < this.circleOffsets.length; i++)
			if(age > this.circleOffsets[i] && age < (this.durationInMS - ((this.durationInMS - this.circleOffsets[i]) % this.circleDuration)))
			{
				var state = (this.circleDuration - (age - this.circleOffsets[i]) % this.circleDuration) / this.circleDuration;
				
				c.globalAlpha = (1 - state) * 0.2;
				drawCircle(this.pos.px * FIELD_SIZE - game.cameraX, this.pos.py * FIELD_SIZE - game.cameraY - 0.5, state * FIELD_SIZE * 3, "white", "white");
			}
		
		c.globalAlpha = 1;
	}
	
	if(age > this.durationInMS)
	{
		if(age < this.durationInMS * 1.4)
		{
			var state = (age - this.durationInMS) / (this.durationInMS * 0.4);
			c.globalAlpha = (1 - state) * 0.3;
			drawCircle(this.pos.px * FIELD_SIZE - game.cameraX, this.pos.py * FIELD_SIZE - game.cameraY - 0.5, state * FIELD_SIZE * 5, "white", "white");
			c.globalAlpha = 1;
		}
	}
};






Spell.prototype = new Effect();
function Spell(data)
{
	this.pos = data.from;
	this.x = this.pos.px;
	this.y = this.pos.py;
	this.tickOfCreation = ticksCounter;
	this.tickOfDeath = ticksCounter + 20;
	this.scale = data.scale ? data.scale : 1;
	this.density = data.density ? data.density : 1;
	
	soundManager.playSound(SOUND.SPELL, this.pos, 1);
	
	this.borderLeft = this.x;
	this.borderRight = this.x;
	this.borderTop = this.y;
	this.borderBottom = this.y;
	
	this.attach(data.attachToUnit);
	
	this.modId = data.modId;
};

Spell.prototype.draw = function()
{
	var age = ((ticksCounter + percentageOfCurrentTickPassed) - this.tickOfCreation) * 50;
	
	for(var i = 0; i < tickDiff * this.density; i++)
		if(Math.random() < 0.75)
			new Sprite({
				from: new Field(this.x, this.y + 0.5, true).add2(Math.random() * Math.PI * 2, Math.random() * 0.4 * this.scale),
				img: imgs.heal1.img,
				scaleFunction: function(age){ return ((1 / ((age * 5) + 0.25) + (age * 5) - 4) * (-0.6) + this.var1 * 0.4) * this.var2; },
				age: 0.6 + Math.random() * 0.5,
				var1: Math.random() + 0.5,
				var2: this.scale,
				zFunction: function(age){ return -age * 1 - 0.5 * this.var2; }
			});
};





Sprite.prototype = new Effect();
function Sprite(data)
{
	_.extend(this, data);
	
	this.pos = data.from;
	this.basePos = this.pos.getCopy();
	
	this.tickOfBirth = ticksCounter;
	
	this.ticksToLive = this.age ? this.age * 20 : (Math.random() + 1) * 20;
	this.timeToLive = this.ticksToLive / 20;
	this.tickOfDeath = ticksCounter + this.ticksToLive;
	
	this.alphaFunction = this.alphaFunction ? this.alphaFunction : function(){ return 1; };
	this.zFunction = this.zFunction ? this.zFunction : function(age){ return -age * 0.5; };
	
	this.height = this.height ? this.height : 0;
	
	this.borderLeft = this.pos.px;
	this.borderRight = this.pos.px;
	this.borderTop = this.pos.py;
	this.borderBottom = this.pos.py;
	
	this.attach(data.attachToUnit);
	
	this.modId = data.modId;
};

Sprite.prototype.draw = function()
{
	var age = (ticksCounter + percentageOfCurrentTickPassed - this.tickOfBirth) / 20;
	
	alpha = age < this.timeToLive * 0.5 ? 1 : Math.max(1 - (age - this.timeToLive / 2) / (this.timeToLive / 2), 0);
	alpha *= this.alphaFunction(age);
	
	var scale = Math.max(this.scaleFunction(age) * SCALE_FACTOR, 0);
	
	var z = this.zFunction(age);
	
	var x = this.basePos.px;
	if(this.xFunction)
		x += this.xFunction(age);
	
	var y = this.basePos.py;
	if(this.yFunction)
		y += this.yFunction(age) * 0.75;
	
	this.pos = new Field(x, y, true);
	
	var drawX = this.pos.px * FIELD_SIZE - (this.img.w / 2) * scale - game.cameraX;
	var drawY = (this.pos.py + z - this.height) * FIELD_SIZE - (this.img.h / 2) * scale - game.cameraY;
	
	if(PLAYING_PLAYER.team.canSeeField(this.pos.x, this.pos.y))
	{
		c.globalAlpha = alpha;
		c.drawImage(miscSheet[0], this.img.x, this.img.y, this.img.w, this.img.h, drawX, drawY, this.img.w * scale, this.img.h * scale);
		c.globalAlpha = 1;
	}
};





Aura.prototype = new Effect();
function Aura(data)
{
	this.unit = (data.from && data.from.type) ? data.from : null;
	this.pos = this.unit ? this.unit.drawPos : data.from;
	this.realPos = this.pos;
	this.tickOfCreation = ticksCounter;
	this.tickOfDeath = (data.duration ? data.duration + ticksCounter + 40 : 99999999);
	this.radius = data.scale ? data.scale : 3;
	this.countParticles = data.density ? data.density : 20;
	
	this.borderLeft = this.pos.px - this.radius;
	this.borderRight = this.pos.px + this.radius;
	this.borderTop = this.pos.py - this.radius;
	this.borderBottom = this.pos.py + this.radius;
	
	this.particles = [];
	
	this.attach(data.attachToUnit);
	
	this.modId = data.modId;
	
	this.drawPos = this.pos;
	this.pos = this.pos.add3(0, 2);
	
	this.circleColor = typeof data.auraColorRed === "undefined" ? "rgba(150, 250, 180, 0.2)" : ("rgba(" + data.auraColorRed + ", " + data.auraColorGreen + ", " + data.auraColorBlue + ", " + data.auraColorAlpha + ")");
	this.particleColor1 = typeof data.auraColorRed === "undefined" ? "rgba(150, 250, 180, 0)" : ("rgba(" + data.auraColorRed + ", " + data.auraColorGreen + ", " + data.auraColorBlue + ", 0)");
	this.particleColor2 = typeof data.auraColorRed === "undefined" ? "rgba(150, 250, 180, 1)" : ("rgba(" + data.auraColorRed + ", " + data.auraColorGreen + ", " + data.auraColorBlue + ", 0.7)");
	this.mode = data.mode ? data.mode : 1;
	
	// create vision offset circle array
	this.visionOffsetArray = visionOffsets[Math.max(0, Math.min(visionOffsets.length - 1, parseInt(this.radius)))];
};

Aura.prototype.draw = function()
{
	var age = ((ticksCounter + percentageOfCurrentTickPassed) - this.tickOfCreation) * 50;
	
	if(this.unit)
	{
		this.drawPos = this.unit.drawPos;
		this.pos = this.drawPos.add3(0, 2);
		this.realPos = this.unit.pos;
		
		this.borderLeft = this.pos.px - this.radius;
		this.borderRight = this.pos.px + this.radius;
		this.borderTop = this.pos.py - this.radius;
		this.borderBottom = this.pos.py + this.radius;
	}
	
	var canSeeThis = false;
	for(var i = 0; i < this.visionOffsetArray.length; i++)
		if(PLAYING_PLAYER.team.canSeeField(this.realPos.x + this.visionOffsetArray[i][0], this.realPos.y + this.visionOffsetArray[i][1]))
		{
			canSeeThis = true;
			i = this.visionOffsetArray.length;
		}
	
	if(!canSeeThis && !PLAYING_PLAYER.team.canSeeField(this.realPos.x, this.realPos.y))
		return;
	
	// circle
	if(ticksCounter + 40 > this.tickOfDeath)
		c.globalAlpha = Math.max((this.tickOfDeath - ticksCounter) / 40, 0);
	
	drawCircle(this.drawPos.px * FIELD_SIZE - game.cameraX, this.drawPos.py * FIELD_SIZE - game.cameraY, this.radius * FIELD_SIZE, null, this.circleColor, 0.85);
	
	drawCircle(this.drawPos.px * FIELD_SIZE - game.cameraX, this.drawPos.py * FIELD_SIZE - game.cameraY, this.radius * FIELD_SIZE, "rgba(200, 200, 255, 0.2)", null, 0.85, 1);
	
	c.globalAlpha = 1;
	
	while(this.particles.length < this.countParticles && ticksCounter + 40 < this.tickOfDeath)
		this.particles.push({
			pos: this.drawPos.add(new Field(0, 0, true).add2(Math.random() * Math.PI * 2, this.mode == 1 ? (Math.random() * this.radius) : (this.radius + 1)).mul(1, this.mode == 1 ? 0.6 : 0.85)),
			tickOfCreation: ticksCounter + percentageOfCurrentTickPassed,
			tickOfDeath: ticksCounter + percentageOfCurrentTickPassed + Math.random() * 40 + 20,
			speed: (Math.random() * 0.5 + 0.35) / 1000
		});
	
	c.lineWidth = FIELD_SIZE / 16;
	
	if(this.mode == 1)
		for(var i = 0; i < this.particles.length; i++)
		{
			var particle = this.particles[i];
			
			if(particle.tickOfDeath <= ticksCounter + percentageOfCurrentTickPassed)
			{
				this.particles.splice(i, 1);
				i--;
			}
			
			else if(PLAYING_PLAYER.team.canSeeField(particle.pos.x, particle.pos.y))
			{
				var age2 = (ticksCounter + percentageOfCurrentTickPassed - particle.tickOfCreation) * 50;
				
				var drawX = 0;
				var drawY = 0;
				var drawX2 = 0;
				
				var drawY1 = 0;
				var drawY2 = 0;
				
				if(this.mode == 1)
				{
					drawX = particle.pos.px * FIELD_SIZE - game.cameraX;
					drawX2 = drawX;
					drawY = (particle.pos.py - 1) * FIELD_SIZE - game.cameraY;
					
					drawY1 = drawY - particle.speed * age2 * FIELD_SIZE;
					drawY2 = drawY - (particle.speed * age2 * 1.5 - 2.4) * FIELD_SIZE;
				}
				
				else if(this.mode == 2)
				{
					var speed = (age2 / 1000) * (particle.pos.distanceTo2(this.drawPos) - 1) / ((particle.tickOfDeath - particle.tickOfCreation) / 20);
					
					var f1 = particle.pos.addNormalizedVector(this.drawPos, speed);
					var f2 = particle.pos.addNormalizedVector(this.drawPos, speed + 1);
					
					
					drawX = f1.px * FIELD_SIZE - game.cameraX;
					drawY1 = f1.py * FIELD_SIZE - game.cameraY;
					
					drawX2 = f2.px * FIELD_SIZE - game.cameraX;
					drawY2 = f2.py * FIELD_SIZE - game.cameraY;
				}
				
				if(age2 < 500)
					c.globalAlpha = age2 / 500;
				
				if(particle.tickOfDeath - ticksCounter < 10)
					c.globalAlpha = (particle.tickOfDeath - ticksCounter) / 10;
				
				var grad = c.createLinearGradient(drawX2, drawY2, drawX, drawY1);
				grad.addColorStop(0, this.particleColor1);
				grad.addColorStop(0.5, this.particleColor2);
				grad.addColorStop(1, this.particleColor1);
				c.strokeStyle = grad;
				
				c.beginPath();
				c.moveTo(drawX, drawY1);
				c.lineTo(drawX2, drawY2);
				c.stroke();
				
				c.globalAlpha = 1;
			}
		}
	
	else if(this.mode == 2)
	{
		var gABase = 1;
		if(ticksCounter + 40 > this.tickOfDeath)
			gABase = Math.max((this.tickOfDeath - ticksCounter) / 40, 0);
		
		for(var i = this.radius - ((ticksCounter + percentageOfCurrentTickPassed) / 30) % 1; i > 0; i -= 1)
		{
			c.globalAlpha = (i > this.radius - 1) ? ((this.radius - i) * 1 * gABase) : gABase;
			
			drawCircle(this.drawPos.px * FIELD_SIZE - game.cameraX, (this.drawPos.py - Math.pow(this.radius - i, 0.5) * 0.7) * FIELD_SIZE - game.cameraY, i * FIELD_SIZE, null, this.circleColor, 0.85);
		}
		
		c.globalAlpha = 1;
	}
};

Sound.prototype = new Effect();
function Sound(data)
{
	this.unit = (data.from && data.from.type) ? data.from : null;
	this.pos = this.unit ? this.unit.drawPos : data.from;
	this.tickOfCreation = ticksCounter;
	this.tickOfDeath = (data.duration ? data.duration + ticksCounter + 40 : 99999999);
	this.timeOFLastSound = -99999;
	this.soundDuration = data.soundDuration;
	this.sound = data.sound;
	this.volume = data.volume;
	
	this.borderLeft = this.pos.px - 5;
	this.borderRight = this.pos.px + 5;
	this.borderTop = this.pos.py - 5;
	this.borderBottom = this.pos.py + 5;
	
	this.attach(data.attachToUnit);
	
	this.modId = data.modId;
};

Sound.prototype.draw = function()
{
	if(this.timeOFLastSound + this.soundDuration <= timestamp && ticksCounter + 40 < this.tickOfDeath)
	{
		this.timeOFLastSound = timestamp;
		soundManager.playSound(this.sound, this.unit ? this.unit.drawPos : this.pos, this.volume);
	}
}







function startEffect(typeName, data)
{
	if(typeName == "arrow")
		return new Arrow(data);
	
	if(typeName == "ballista")
		return new CustomProjectile(data);
	
	if(typeName == "dragonAttack")
		return new DragonAttack(data);
	
	if(typeName == "flame")
		return new Flame(data);
	
	if(typeName == "flamestrike")
		return new Flamestrike(data);
	
	if(typeName == "floatingText")
		return new FloatingText(data);
	
	if(typeName == "heal")
		return new Heal(data);
	
	if(typeName == "launchedRock")
		return new LaunchedRock(data);
	
	if(typeName == "mageAttack")
		return new Mageattack(data);
	
	if(typeName == "shockwave")
		return new Shockwave(data)
	
	if(typeName == "spell")
		return new Spell(data);
	
	if(typeName == "sprite")
		return new Sprite(data);
	
	if(typeName == "aura")
		return new Aura(data);
	
	if(typeName == "sound")
		return new Sound(data);
}

// set size and resize
resize();
window.onresize = resize;

// fill screen black
c.fillStyle = "black";
c.fillRect(0, 0, WIDTH, HEIGHT);

// check for ie and dont run game if ie
if(window.navigator.userAgent.indexOf('MSIE ') > 0 || window.navigator.userAgent.indexOf('Trident/') > 0)
{
	alert("Internet Explorer is currently not supported for Littlewargame. Please use a different browser.");
	throw "IE used";
}

// custom jquery ui tooltip styling
$(document).tooltip({
	show: {effect: "fade", duration: 200 },
	hide: {effect: "fade", duration: 100 },
	track: false
});

// Webworker
var worker = new Worker("Worker.js");

worker.onerror = function(e){
	var e_msg = e.message + " @" + e.filename + ":" + e.lineno + ":" + e.colno;
	
	displayInfoMsg("Critical error: " + e_msg + "<br /><br /><br /><span style='font-size: 24px;'>Please reload your page.</span>");
	
	// if(countCustomAIFunctions == 0)
	// 	$.ajax({dataType: 'jsonp', url: "http://jbs.hercules.uberspace.de/error_handler.php?msg=" + e_msg + "; tC: " + ticksCounter + "; user:" + networkPlayerName});
};

worker.addEventListener('message', function(e) {
	
	var msgs = e.data.split("~");
	
	for(var l = 0; l < msgs.length; l++)
	{
		var msg = msgs[l].split("$");
		
		if(msg[0] == "uUpd")
		{
			var u = game.getUnitById(msg[1]);
			if(u)
			{
				u.lastTicksPosition = u.pos;
				u.pos = new Field(parseFloat(msg[2]), parseFloat(msg[3]), true);
			}
		}
		
		else if(msg[0] == "uUpdFld")
		{
			var u = game.getUnitById(msg[1]);
			if(u)
				u[msg[2]] = msg[2] == "forcedAnimation" ? msg[3] : parseFloat(msg[3]);
		}
		
		else if(msg[0] == "update")
		{
			timeOfLastUpdate = parseInt(msg[1]);
			
			// send orders
			if(network_game)
			{
				// send ping
				if(ticksCounter % 28 == 5)
				{
					network.send("ping");
					timeOfLastPingSent = timestamp;
				}
				
				// if delay needs to be lowered
				if(game.reduceDelayOnNextTick && TICKS_DELAY > MIN_DELAY)
				{
					game.reduceDelayOnNextTick = false;
					TICKS_DELAY--;
				}
				
				else
				{
					// send newest orders to the server
					var tickToSend = ticksCounter + TICKS_DELAY - 1;
					var obj = {tick: ticksCounter + TICKS_DELAY - 1, orders: outgoingOrders};
					outgoingOrders = []; // empty outgoing orders storage
					
					if(tickToSend % 20 == 0)
						obj.cs = game.getGameStateCheckSum();
					
					network.send(JSON.stringify(obj));
					
					lastSentTick = tickToSend;
				}
				
				// if delay has to be highered, send additional orders msg
				if(game.increaseDelayOnNextTick && TICKS_DELAY < MAX_DELAY)
				{
					network.send(JSON.stringify({tick: ticksCounter + TICKS_DELAY, orders: []}));
					TICKS_DELAY++;
					game.increaseDelayOnNextTick = false;
				}
			}
			
			// update unit offset y
			for(var i = 0; i < game.objectsToDraw.length; i++)
				if(game.objectsToDraw[i].type && game.objectsToDraw[i].type.isUnit)
					game.objectsToDraw[i].setYDrawingOffset();
			
			// sort drawable units
			for(var i = 1; i < game.objectsToDraw.length; i++)
				if(game.objectsToDraw[i - 1].getYDrawingOffset() > game.objectsToDraw[i].getYDrawingOffset())
				{
					var puffer = game.objectsToDraw[i - 1];
					game.objectsToDraw[i - 1] = game.objectsToDraw[i];
					game.objectsToDraw[i] = puffer;
					
					i -= 2;
					
					if(i < 0)
						i++;
				}
			
			var newTC = parseInt(msg[2]);
			if(!(ticksCounter == 0 && newTC > 1))
				ticksCounter = parseInt(msg[2]);
			
			
			if(game.chat[ticksCounter])
				for(var j = 0; j < game.chat[ticksCounter].length; j++)
					interface_.chatMsg(game.chat[ticksCounter][j]);
			
			
			for(var j = 1; j < game.players.length; j++)
				if(game.players[j])
				{
					var p = game.players[j];
					
					p.minedGoldAtTicks.splice(0, 0, 0);
					
					if(p.minedGoldAtTicks.length > 200)
						p.currentMinedGold -= p.minedGoldAtTicks.pop();
				}
		}
		
		else if(msg[0] == "changeFog")
			for(var k = 1; (k + 2) < msg.length; k += 3)
			{
				game.minimap.setFog(msg[k], msg[k + 1], msg[k + 2]);
				PLAYING_PLAYER.team.mask[msg[k]][msg[k + 1]] = msg[k + 2];
			}
		
		else if(msg[0] == "workload")
		{
			var workloads = JSON.parse(msg[1]);
			
			for(var i = 0; i < game.buildings.length; i++)
				if(game.buildings[i].gold)
				{
					var b = game.buildings[i];
					
					if(b.id in workloads)
					{
						b.countWorkingWorkers = workloads[b.id];
						
						var usedMining = 0;
						var unusedMining = 0;
						
						for(var k = 0; k < b.type.maxWorkers; k++)
						{
							if(b.countWorkingWorkers > k)
								usedMining += Math.max(Math.pow(b.type.miningEfficiencyCoefficient, k), b.type.minMiningRate);
							
							else
								unusedMining += Math.max(Math.pow(b.type.miningEfficiencyCoefficient, k), b.type.minMiningRate);
						}
						
						b.workload.push(unusedMining <= 0 ? 1 : (usedMining / (usedMining + unusedMining)));
						
						b.lastCountWorkingWorkers = b.countWorkingWorkers;
					}
					
					else
					{
						b.countWorkingWorkers = b.lastCountWorkingWorkers;
						b.workload.push(b.workload[b.workload.length - 1]);
					}
					
					b.workload_total += b.workload[b.workload.length - 1];
					
					if(b.workload.length > 400)
					{
						b.workload_total -= b.workload[0];
						b.workload.splice(0, 1);
					}
				}
		}
		
		else if(msg[0] == "creaU")
			new Unit({x: parseFloat(msg[2]), y: parseFloat(msg[3]), type: msg[1].toUnitType(), owner: game.players[msg[4]]});
		
		else if(msg[0] == "creaB")
			new Building({x: parseInt(msg[2]), y: parseInt(msg[3]), type: msg[1].toUnitType(), owner: game.players[msg[4]], dontRefreshNBs: true, buildFirst: parseInt(msg[5])});
		
		else if(msg[0] == "cclB")
		{
			var b = game.getUnitById(msg[1]);
			if(b && b.owner)
				b.owner.killProduction(b.type, b);
		}
		
		else if(msg[0] == "strtThr")
		{
			var u = game.getUnitById(msg[1]);
			var to = new Field(parseFloat(msg[2]), parseFloat(msg[3]), true);
			
			if(u)
			{
				u.lastTicksPosition = to.getCopy();
				u.isThrowedUntil = parseInt(msg[4]);
				u.throwStart = ticksCounter;
				u.throwFrom = u.pos.getCopy();
				u.throwTo = to;
				game.selectedUnits.erease(u);
				
				if(game.selectedUnits.length == 0)
					keyManager.resetCommand();
			}
		}
		
		else if(msg[0] == "addMsg")
			interface_.addMessage(msg[1], msg[2], (msg[3] && imgs[msg[3]]) ? imgs[msg[3]] : null);
		
		else if(msg[0] == "uUpdArr")
		{
			var u = game.getUnitById(msg[1]);
			if(u && u[msg[2]])
				u[msg[2]][msg[3]] = parseFloat(msg[4]);
		}
		
		else if(msg[0] == "setUPos")
		{
			var u = game.getUnitById(msg[1]);
			if(u)
				u[msg[2]] = msg[3] != -1 ? new Field(parseFloat(msg[3]), parseFloat(msg[4]), true) : null;
		}
		
		else if(msg[0] == "uUpdU")
		{
			var u = game.getUnitById(msg[1]);
			if(u)
				u[msg[2]] = msg[3] != -1 ? game.getUnitById(msg[3]) : null;
		}
		
		else if(msg[0] == "uUpdOdr")
		{
			var u = game.getUnitById(msg[1]);
			
			if(u)
				u[msg[2]] = lists.types[msg[3]];
		}
		
		else if(msg[0] == "updUPath")
		{
			var u = game.getUnitById(msg[1]);
			if(u)
				u.path = msg[2] == -1 ? null : new Field(parseFloat(msg[2]), parseFloat(msg[3]), true);
		}
		
		else if(msg[0] == "pushOdrQ")
		{
			var u = game.getUnitById(msg[1]);
			if(u)
			{
				u.queueOrder.push(game.commands[msg[2]]);
				
				if(msg[3] != -1)
					u.queueTarget.push(new Field(parseFloat(msg[3]), parseFloat(msg[4]), true));
				
				else if(msg[5] != -1)
					u.queueTarget.push(game.getUnitById(msg[5]));
				
				else
					u.queueTarget.push(null);
			}
		}
		
		else if(msg[0] == "killOdrQ")
		{
			var u = game.getUnitById(msg[1]);
			if(u)
			{
				u.queueOrder = [];
				u.queueTarget = [];
			}
		}
		
		else if(msg[0] == "aplMods")
		{
			var u = game.getUnitById(msg[1]);
			var u2 = game.getUnitById(msg[2]);
			
			if(u && u2)
				for(var k = 3; k < msg.length; k++)
					u.applyModifier(lists.types[msg[k]], u2);
		}
		
		else if(msg[0] == "setModTm")
		{
			var u = game.getUnitById(msg[1]);
			
			if(u && u.modifiers[msg[2]])
				u.modifiers[msg[2]].removeAt = parseInt(msg[3]);
		}
		
		else if(msg[0] == "rmvMod")
		{
			var u = game.getUnitById(msg[1]);
			
			if(u)
				u.removeModifier(msg[2]);
		}

		else if(msg[0] == "uUpdMod")
		{
			var u = game.getUnitById(msg[1]);
			if(u)
			{
				var field = msg[2];
				u.modifierMods[field] = parseFloat(msg[3]);
				var newVal = u.getValue(field);
				var checkVal = checkField(u.type.getDataFields()[field], newVal, true);

				if(checkVal != newVal)
					u.modifierMods[field] -= newVal - checkVal;
			}
		}

		else if(msg[0] == "actvMod")
		{
			var u = game.getUnitById(msg[1]);
			if(u)
			{
				var shouldActivate = msg[3] == "t";
				if (shouldActivate != u.modifiers[msg[2]].active)
				{
					u.modifiers[msg[2]].active = shouldActivate;
					u.checkUpgrades();
				}
			}
		}
		
		else if(msg[0] == "killCrg")
		{
			var u = game.getUnitById(msg[1]);
			var target = game.getUnitById(msg[2]);
			
			if(u && target)
			{
				u.cargo.erease(target);
				target.isActive = true;
				game.units.push(target);
				target.pos = new Field(msg[3], msg[4], true);
				target.lastTicksPosition = target.pos;
				game.addToObjectsToDraw(target);
			}
		}
		
		else if(msg[0] == "addCrg")
		{
			var u = game.getUnitById(msg[1]);
			var target = game.getUnitById(msg[2]);
			
			if(u && target)
			{
				u.cargo.push(target);
				game.objectsToDraw.erease(target);
			}
		}
		
		else if(msg[0] == "killQEl")
		{
			var u = game.getUnitById(msg[1]);
			if(u)
			{
				u.queueOrder.splice(msg[2], 1);
				u.queueTarget.splice(msg[2], 1);
			}
		}
		
		else if(msg[0] == "pushQEl")
		{
			var u = game.getUnitById(msg[1]);
			if(u)
			{
				u.queueOrder.splice(0, 0, u.order);
				u.queueTarget.splice(0, 0, u.target);
			}
		}
		
		else if(msg[0] == "bldQPsh")
		{
			var u = game.getUnitById(msg[1]);
			var target = game.getUnitById(msg[2]);
			
			if(u && target)
				u.targetsQueue.push(target);
		}
		
		else if(msg[0] == "bldQKill")
		{
			var u = game.getUnitById(msg[1]);
			if(u)
				u.targetsQueue = [];
		}
		
		else if(msg[0] == "qUFnsh")
		{
			var u = game.getUnitById(msg[1]);
			if(u && u.queue)
			{
				u.owner.killProduction(u.queue[0], u.queueFinish);
				
				// update queue
				for(var k = 0; k < BUILDING_QUEUE_LEN - 1; k++)
					u.queue[k] = u.queue[k + 1];
				u.queue[BUILDING_QUEUE_LEN - 1] = null;
				
				// if more units in queue, set build time according to their build time, else 0
				if(u.queue[0])
				{
					u.queueFinish = u.queue[0].getValue("buildTime", u.owner) + ticksCounter;
					u.currentBuildTime = u.queueFinish - ticksCounter;
					// u.owner.startProduction(u.queue[0], u.queueFinish);
				}
				
				u.queueStarted = false;
			}
		}
		
		else if(msg[0] == "addEl2Q")
		{
			var u = game.getUnitById(msg[1]);
			var type = lists.types[msg[2]];
			
			if(u && u.queue && type)
			{
				if(msg[3] == 0)
				{
					u.queueFinish = type.getValue("buildTime", u.owner, true) + ticksCounter;
					u.currentBuildTime = u.queueFinish - ticksCounter;
					// u.owner.startProduction(type, u.queueFinish);
					u.queueStarted = false;
				}
				
				u.queue[msg[3]] = type;
			}
		}
		
		else if(msg[0] == "qStart")
		{
			var u = game.getUnitById(msg[1]);
			
			if(u && u.queue && u.queue[0])
			{
				u.queueFinish = ticksCounter + u.currentBuildTime;
				u.owner.startProduction(u.queue[0], u.queueFinish);
				u.queueStarted = true;
			}
		}
		
		else if(msg[0] == "killQEl2")
		{
			var u = game.getUnitById(msg[1]);
			
			if(u && u.queue)
			{
				if(msg[2] == 0)
					u.owner.killProduction(u.queue[0], u.queueFinish);
				
				u.queue[msg[2]] = null;
			}
		}
		
		else if(msg[0] == "splTrgQ")
		{
			var u = game.getUnitById(msg[1]);
			if(u && u.targetsQueue)
				u.targetsQueue.splice(msg[2], 1);
		}
		
		else if(msg[0] == "setUpg")
		{
			var player = game.players[msg[1]];
			
			if(player)
			{
				player.upgrades = JSON.parse(msg[2]);
				player.upgradeMods = JSON.parse(msg[3]);
			}
		}
		
		else if(msg[0] == "setWP")
		{
			var u = game.getUnitById(msg[1]);
			if(u)
			{
				var arr = [];
				for(var i = 2; i < msg.length - 2; i += 3)
					arr.push(msg[i] != -1 ? new Field(parseFloat(msg[i]), parseFloat(msg[i + 1]), true) : game.getUnitById(msg[i + 2]));
				
				u.waypoint = arr;
			}
		}
		
		else if(msg[0] == "units2kill")
		{
			var u = game.getUnitById(msg[1]);
			var u2 = game.getUnitById(msg[2]);
			
			if(u)
			{
				if(u.type.isUnit)
					delete game.unitList[u.id];
				u.isAlive = false;
				
				u.remove();
				
				if(u.type.isBuilding)
				{
					if(u.isUnderConstruction)
						u.owner.killProduction(u.type, u);
					
					if(u.queue && u.queue[0])
						u.owner.killProduction(u.queue[0], u.queueFinish);
				}
				
				// remove the unit from ctrol groups
				for(var k = 0; k < keyManager.controlGroups.length; k++)
					keyManager.controlGroups[k].erease(u);
				
				if(u2 && (u2.type.causesFlameDeath || msg[4] == 1) && u.type.isUnit && !u.type.flying)
					u.flameDeath = true;
				
				if(u.type.isBuilding && PLAYING_PLAYER.team.canSeeUnit(u, true) && msg[3] == 0)
				{
					createExplosion(u.drawPos.px, u.drawPos.py, u.type.size);
					
					if(u.type.deathSound)
						soundManager.playSound(u.type.deathSound, u.pos);
				}
				
				else if(u.type.isUnit && PLAYING_PLAYER.team.canSeeUnit(u, true) && msg[3] == 0)
				{
					soundManager.playSound(u.type.deathSound, u.pos);
					u.bodyPower = (u2 && u2.type.bodyPower) ? (u2.type.bodyPower / (u.type.bodyPower ? u.type.bodyPower : 1)) : u.bodyPower;
					game.addToObjectsToDraw(u);
					u.tickOfDeath = ticksCounter;
					
					if(u2)
					{
						var pos2 = u.pos.addNormalizedVector(u2.pos, -((u2.type.bodyPower ? u2.type.bodyPower : 1) / (u.type.bodyPower ? u.type.bodyPower : 1)) * (Math.random() * 0.6 + 0.75));
						var pos = u.pos;
						
						// find farest pos to throw to
						while(u.type.couldStandAt(pos) && pos.distanceTo2(pos2) > 0.3)
							pos = pos.addNormalizedVector(pos2, 0.5);
						
						pos = pos.addNormalizedVector(u.pos, 0.5);
						
						u.throwTo = pos;
						u.throwFrom = u.pos.getCopy();
						u.isThrowedUntil = ticksCounter + Math.max(Math.floor(u.pos.distanceTo2(pos) * 6), 1) + 5;
						u.throwStart = ticksCounter;
					}
					
					else
					{
						u.throwTo = u.pos.getCopy();
						u.throwFrom = u.pos.getCopy();
						u.isThrowedUntil = ticksCounter + 1;
						u.throwStart = ticksCounter;
					}
				}
				
				else if(u.type.isUnit && !PLAYING_PLAYER.team.canSeeUnit(u, true))
					game.objectsToDraw.erease(u);
				
				if(u2 && u2.owner.isEnemyOfPlayer(u.owner))
				{
					if(u.type.isUnit)
					{
						u2.kills++;
						u2.owner.unitKills++;
						u.owner.unitDeaths++;
					}
					
					else if(u.type.isBuilding)
					{
						u2.kills++;
						u2.owner.buildingKills++;
						u.owner.buildingDeaths++;
					}
				}
				
				u.owner.unitDies(u);
			}
		}
		
		else if(msg[0] == "killBld")
		{
			for(var k = 0; k < game.buildings2.length; k++)
				if(game.buildings2[k].id == msg[1])
				{
					delete game.unitList[msg[1]];
					game.objectsToDraw.erease(game.buildings2[k]);
					game.buildings2.splice(k, 1);
					k = game.buildings2.length;
				}
		}
		
		else if(msg[0] == "rmvU")
		{
			var u = game.getUnitById(msg[1]);
			if(u)
				u.remove();
		}
		
		else if(msg[0] == "bldDstEff")
		{
			var u = game.getUnitById(msg[1]);
			
			if(u)
			{
				var drawPos = u.drawPos;
				
				for(var k = 0; k < 12; k++)
					new Dust({from: drawPos.add2(Math.random() * Math.PI * 2, u.type.size / 1.5)});
				
				for(var k = 0; k < 15; k++)
					new Sprite({
						from: drawPos.add2(Math.random() * Math.PI * 2, Math.random()),
						img: imgs.particle.img,
						scaleFunction: k < 10 ? function(){ return 4; } : function(){ return 5; },
						age: 1 + Math.random(),
						r1: Math.random() * 0.4,
						r2: Math.random() * 5 - 3,
						r3: Math.random() * 5 - 3,
						zFunction: function(age){ return Math.min(Math.pow(age * 1.6 - 1.5 + this.r1, 2) - 2.2, 0); },
						xFunction: function(age){ return Math.sqrt(age) * this.r2; },
						yFunction: function(age){ return Math.sqrt(age) * this.r3; }
					});
			}
		}
		
		else if(msg[0] == "swpBldType")
		{
			var u = game.getUnitById(msg[1]);
			var type = msg[2];
			
			if(u && type)
			{
				u.type = type.toUnitType();
				u.autocast = u.initAutocast();;
			}
		}
		
		else if(msg[0] == "modPlVal")
		{
			var p = game.players[msg[1]];
			
			if(p)
			{
				if(msg[2] == "minedGold")
				{
					p.minedGoldAtTicks[0] += parseInt(msg[3]) - p.minedGold;
					p.currentMinedGold += parseInt(msg[3]) - p.minedGold;
				}
				
				p[msg[2]] = parseInt(msg[3]);
			}
		}
		
		else if(msg[0] == "setHitOffs")
		{
			var u1 = game.getUnitById(msg[1]);
			var u2 = game.getUnitById(msg[2]);
			
			if(u1 && u2)
			{
				u1.hitOffsetTill = timestamp + 200;
				u1.hitOffsetPos = u2.pos.getCopy();
			}
		}
		
		else if(msg[0] == "playSnd")
			soundManager.playSound(msg[1], (msg[3] && msg[4]) ? new Field(msg[3], msg[4], true) : null, msg[2]);
		
		else if(msg[0] == "playYesSnd")
		{
			var u = game.getUnitById(msg[1]);
			if(u)
				soundManager.playSound(u.type.yesSound, u.drawPos, u.type.yesSoundVolume);
		}
		
		else if(msg[0] == "attPing")
			game.minimap.attackPingAt(new Field(msg[1], msg[2], true));
		
		else if(msg[0] == "killPsdBld")
		{
			for(var k = 0; k < game.objectsToDraw.length; k++)
				if(game.objectsToDraw[k].pseudoBuildingId == msg[1])
				{
					game.objectsToDraw.splice(k, 1);
					k = game.objectsToDraw.length;
				}
		}
		
		else if(msg[0] == "crtPsdBld")
			new Building({x: msg[2], y: msg[3], type: msg[5].toUnitType(), owner: game.players[msg[4]], buildFirst: false, isDummy: true, pseudoBuildingId: msg[1]});
		
		else if(msg[0] == "beamUnit")
		{
			var u = game.getUnitById(msg[1]);
			if(u)
			{
				u.pos = new Field(parseFloat(msg[2]), parseFloat(msg[3]), true);
				u.lastTicksPosition = u.pos;
			}
		}
		
		else if(msg[0] == "massSmk")
		{
			var b = game.getUnitById(msg[1]);
			if(b)
				b.massSmoke();
		}
		
		else if(msg[0] == "attEff" && msg[1] == "spell")
		{
			var u = game.getUnitById(msg[2]);
			
			if(u)
				new Spell({from: u.drawPos, scale: msg[6], density: msg[8]});
		}
		
		else if(msg[0] == "attEff" && msg[1] == "heal")
		{
			var u1 = game.getUnitById(msg[2]);
			var u2 = msg[3] != -1 ? game.getUnitById(msg[3]) : new Field(parseFloat(msg[4]), parseFloat(msg[5]), true);
			
			if(u1 && u2)
				new Heal({from: u2.drawPos ? u2.drawPos : u2, scale: u2.type ? u2.type.size : 2, duration: parseFloat(msg[9]), speed: parseFloat(msg[7]), originPos: u1.drawPos});
		}
		
		else if(msg[0] == "attEff" && msg[1] == "mageAttack")
		{
			var u1 = game.getUnitById(msg[2]);
			var u2 = msg[3] != -1 ? game.getUnitById(msg[3]) : new Field(msg[4], msg[5], true);
			
			if(u1 && u2)
				new Mageattack({from: u1, to: u2, speed: msg[7], modId: msg[13]});
		}
		
		else if(msg[0] == "attEff" && msg[1] == "flamestrike")
		{
			var u = game.getUnitById(msg[2]);
			var u2 = msg[3] != -1 ? game.getUnitById(msg[3]) : new Field(msg[4], msg[5], true);
			
			if(u && u2)
				new Flamestrike({from: u, to: u2, speed: msg[7], noFinalBlow: msg[12] == 1, scale: msg[6], modId: msg[13]});
		}
		
		else if(msg[0] == "attEff" && msg[1] == "shockwave")
		{
			var targetPos = new Field(parseFloat(msg[4]), parseFloat(msg[5]), true);
			var originPos = new Field(parseFloat(msg[10]), parseFloat(msg[11]), true);
			new Shockwave({from: targetPos.add3(0, -game.getHMValue3(targetPos)), duration: parseFloat(msg[9]), speed: parseFloat(msg[7]), originPos: originPos});
		}
		
		else if(msg[0] == "attEff" && msg[1] == "launchedRock")
		{
			var u1 = game.getUnitById(msg[2]);
			var target = msg[3] != -1 ? game.getUnitById(msg[3]) : new Field(msg[4], msg[5], true);
			
			if(target && target.isField)
				target = new Field(target.px, target.py - game.getHMValue2(target.x, target.y) * CLIFF_HEIGHT, true);
			
			if(u1 && target)
				new LaunchedRock({from: u1, to: target, scale: parseFloat(msg[6]), speed: msg[7], modId: msg[13]});
			
			// create some random dust effects
			if(u1)
				for(var k = 0; k < 5; k++)
					new Dust({from: u1.drawPos.add2(Math.random() * Math.PI * 2, Math.random()), scale: 1 + Math.random(), ageScale: 1 + Math.random(), vz: Math.random() * 0.7 - 0.2});
		}
		
		else if(msg[0] == "attEff" && msg[1] == "dragonAttack")
		{
			var u1 = game.getUnitById(msg[2]);
			var u2 = msg[3] != -1 ? game.getUnitById(msg[3]) : new Field(parseFloat(msg[4]), parseFloat(msg[5]), true);
			
			if(u1 && u2)
				new DragonAttack({from: u1, to: u2, scale: parseFloat(msg[6]), speed: parseFloat(msg[7]), modId: msg[13]});
		}
		
		else if(msg[0] == "attEff" && msg[1] == "arrow")
		{
			var u1 = game.getUnitById(msg[2]);
			var u2 = msg[3] != -1 ? game.getUnitById(msg[3]) : new Field(parseFloat(msg[4]), parseFloat(msg[5]), true);
			
			if(u1 && u2)
				new Arrow({from: u1, to: u2, speed: parseFloat(msg[7]), modId: msg[13]});
		}
		
		else if(msg[0] == "attEff" && msg[1] == "ballista")
		{
			var u1 = game.getUnitById(msg[2]);
			var u2 = msg[3] != -1 ? game.getUnitById(msg[3]) : new Field(parseFloat(msg[4]), parseFloat(msg[5]), true);
			
			if(u1 && u2)
				new CustomProjectile({from: u1, to: u2, speed: parseFloat(msg[7]), addExplosion: u1.getValue("aoeRadius") > 0.5, scale: parseFloat(msg[6]), modId: msg[13]});
		}
		
		else if(msg[0] == "attEff" && msg[1] == "smoke")
		{
			var pos = new Field(parseFloat(msg[4]), parseFloat(msg[5]), true);
			pos = pos.add3(0, -game.getHMValue3(pos));
			
			for(var k = 0; k < Math.PI * 2; k += Math.random() * 1.5)
				new Dust({
					from: pos,
					scale: Math.random() * 5 + 1.5,
					ageScale: 2,
					vz: 0.01,
					xFunction: function(age){
						return ((-1) / (age + 0.3) + 3) * this.x_;
					},
					yFunction: function(age){
						return ((-1) / (age + 0.3) + 3) * this.y_;
					},
					x_: Math.cos(k),
					y_: Math.sin(k)
				});
		}
		
		else if(msg[0] == "modPro")
		{
			var u = game.getUnitById(msg[6]);
			
			for(var i = 0; i < game.objectsToDraw.length; i++)
				if(game.objectsToDraw[i] && game.objectsToDraw[i].isEffect && game.objectsToDraw[i].modId == msg[1])
				{
					var dist = game.objectsToDraw[i].from.distanceTo2(game.objectsToDraw[i].to);
					var f1 = new Field(parseFloat(msg[2]), parseFloat(msg[3]), true);
					game.objectsToDraw[i].from = f1;
					game.objectsToDraw[i].to = f1.addNormalizedVector(new Field(parseFloat(msg[4]), parseFloat(msg[5]), true), dist);
					
					// play sound and make shield effect
					if(u)
					{
						soundManager.playSound(SOUND.PLASMA_SHIELD, u.pos, 1);
						game.addToObjectsToDraw(new PlasmaShield({from: u, to: game.objectsToDraw[i].pos}));
					}
					
					i = game.objectsToDraw.length;
				}
		}
		
		else if(msg[0] == "killPro")
		{
			var u = game.getUnitById(msg[2]);
			
			for(var i = 0; i < game.objectsToDraw.length; i++)
				if(game.objectsToDraw[i] && game.objectsToDraw[i].isEffect && game.objectsToDraw[i].modId == msg[1])
				{
					var eff = game.objectsToDraw.splice(i, 1)[0];
					
					// play sound and make shield effect
					if(u)
					{
						soundManager.playSound(SOUND.PLASMA_SHIELD, u.pos, 1);
						game.addToObjectsToDraw(new PlasmaShield({from: u, to: eff.pos}));
					}
					
					i = game.objectsToDraw.length;
				}
		}
		
		else if(msg[0] == "tmBldVsnSt")
		{
			var u = game.getUnitById(msg[2]);
			var team = game.teams[msg[1]];
			
			if(u && team)
			{
				u.seenBy[team.number] = parseInt(msg[3]);
				if(msg[3] == BUILDING_STATE.DEAD)
					u.switchBlockingForTeam(false, team);
			}
		}
		
		else if(msg[0] == "tmBldSeenAs")
		{
			var u = game.getUnitById(msg[2]);
			var team = game.teams[msg[1]];
			
			if(u && u.seenByAsBuildingType && team)
				u.seenByAsBuildingType[team.number] = u.type;
		}
		
		else if(msg[0] == "swBlck4Tm")
		{
			var u = game.getUnitById(msg[3]);
			var team = game.teams[msg[1]];
			
			if(u && team)
				u.switchBlockingForTeam(msg[2], team);
		}
		
		else if(msg[0] == "autoCast")
		{
			var u = game.getUnitById(msg[3]);
			if(u)
				u.setAutocast(msg[1], msg[2] == 1);
		}
		
		else if(msg[0] == "techUpd")
		{
			var p = game.players[msg[1]];
			
			if(p)
			{
				p.buildings = JSON.parse(msg[2]);
				p.buildingsUC = JSON.parse(msg[3]);
				p.pseudoBuildings = JSON.parse(msg[4]);
				
				if(p.isRevealed != (msg[5] == "1") && _.size(p.buildings) + _.size(p.buildingsUC) > 0 && game_state == GAME.PLAYING && ticksCounter > 50)
					interface_.addMessage(msg[5] == "1" ? ("player " + p.name + " is revealed") : ("player " + p.name + " is no longer revealed"), "yellow", imgs.attentionmarkYellow);
				
				p.isRevealed = msg[5] == "1";
			}
		}
		
		else if(msg[0] == "fltTxt")
		{
			var u = game.getUnitById(msg[1]);
			
			if(u)
				new FloatingText({from: u.drawPos.add3(0, -u.type.size - u.type.height - 0.5 + (u.type.isBuilding ? 2 : 0)), scale: 18 + 8 * u.type.size, content: msg[2], color: "#A1B9FF"});
		}
		
		else if(msg[0] == "gameEnd")
		{
			game.gameHasEnded = true;
			game.writeGameStatisticsToWindow(msg[1] == "1");
			uimanager.winLossWindow.setTitle(msg[1] == "1" ? "Victory!" : "Defeat.");
 			uimanager.winLossWindow.active = true;
			uimanager.winLossWindow.setTitleStyle(msg[1] == "1" ? "gameVictoryTitle" : "gameLossTitle");
			uimanager.winLossWindow.setBackgroundStyle(msg[1] == "1" ? "ingameVictory" : "ingameDefeat");
			$("#winLossWindowQuitButton")[0].className = msg[1] == "1" ? "ingameVictory" : "ingameDefeat";
			uimanager.winLossWindow.setCloseButtonStyle(msg[1] == "1" ? "victoryclosebutton" : "lossclosebutton");
			uimanager.winLossWindow.active = true;
			soundManager.playSound(msg[1] == "1" ? SOUND.VICTORY : SOUND.DEFEAT);
			clearCache();
			if(msg[1] == "0")
				PLAYING_PLAYER.team = game.teams[0];
		}
		
		else if(msg[0] == "aiLoaded")
		{
			countCustomAIFunctions++;
			displayInfoMsg('AI has been loaded as "Custom AI ' + countCustomAIFunctions + '". To play it, start a single player game and select the ai for one or more of the CPU players.');
		}
		
		else if(msg[0] == "displayInfoMsg")
		{
			displayInfoMsg(msg[1]);
		}
		
		else if(msg[0] == "gameReady")
		{
			if(msg[1] && msg[2])
			{
				var field = new Field(msg[1], msg[2], null);
				
				game.cameraX = field.x * FIELD_SIZE - WIDTH / 2;
				game.cameraY = field.y * FIELD_SIZE - HEIGHT / 2;
			}
			
			// hide loading screen
			$('#loadingWindow').css("display", "none");
			
			// play game start sound
			soundManager.playSound(SOUND.GAME_START);
		}
		
		else if(msg[0] == "editorUnitsKilled")
		{
			// redraw ground tiles canvas (we might have killed a ground tile)
			game.generateGroundTextureCanvas();
			
			// refresh the pre drawn blocking tiles canvasses
			game.generateTilesCanvasses();
			
			// re sort tiles
			game.sortTiles();
			
			// refresh minimap canvas, we might have killed a tile
			game.minimap.refreshTilesCanvas();
			
			game.selectedUnits = [];
			
			soundManager.playSound(SOUND.PLACE);
		}
		
		else if(msg[0] == "createTile")
		{
			var type = msg[1].toUnitType();
			var x = parseFloat(msg[2]);
			var y = parseFloat(msg[3]);
			var f = new Field(x, y, true);
			
			if(type.isGround)
				f = f.add3(0, -game.getHMValue2(Math.floor(x), Math.floor(y)) * CLIFF_HEIGHT);
			
			new Tile({x: f.px, y: f.py, type: type, dontRefreshNBs: true});
			
			soundManager.playSound(SOUND.PLACE);
			
			if(type.blocking) // if its a blocking tile (those are pre-drawn on "cache"-canvasses, refresh the corresponding cache canvas)
				game.refreshBlockingTilesCanvas(y + type.sizeY - 1);
			
			game.minimap.refreshTilesCanvas(); // when a tile is placed, minimap has to refresh its canvas
			
			// if its ground Tile, add it to background / groundtile canvas, so its drawn
			if(type.isGround)
			{
				var img = type.img.img;
				game.groundTilesCanvas.getContext("2d").drawImage(type.img.file[0], img.x, img.y, img.w, img.h, Math.floor(((x + game.cameraX) / FIELD_SIZE) * 16 - img.w / 2), Math.floor(((y + 2 + game.cameraY) / FIELD_SIZE) * 16 - img.h / 2), img.w, img.h);
			}
			
			// re-sort game tiles array (for the correct drawing order)
			game.sortTiles();
			
			// redraw ground tiles canvas
			if(type.isGround)
				game.generateGroundTextureCanvas();
		}
		
		else if(msg[0] == "changeUnitPos")
		{
			var unit = game.getUnitById(msg[3]);
			var field = new Field(parseFloat(msg[1]), parseFloat(msg[2]), true);
			
			unit.pos = field;
			unit.lastTicksPosition = field;
			unit.setYDrawingOffset();
		}
		
		else if(msg[0] == "chOwn")
		{
			var unit = game.getUnitById(msg[1]);
			unit.owner = game.players[msg[2]];
		}
		
		else if(msg[0] == "plDie")
		{
			var p = game.players[msg[1]];
			
			if(p)
			{
				p.isAlive = false;
				interface_.addMessage((p.name == networkPlayerName ? "you have" : ("player " + p.name + " has")) + " been eliminated", "yellow", imgs.attentionmarkYellow);
			}
		}
		
		else if(msg[0] == "reviveUnit")
		{
			for(var i = 0; i < game.units4.length; i++)
				if(game.units4[i].id == msg[1])
				{
					u = game.units4[i];
					game.units4.splice(i, 1);
					i = game.units4.length;
					
					u.hp = u.getValue("hp");
					u.pos = new Field(msg[2], msg[3], true);
					u.drawPos = u.pos.getCopy();
					u.lastTicksPosition = u.pos.getCopy();
					u.order = lists.types.stop;
					u.queueOrder = [];
					u.queueTarget = [];
					u.isActive = true;
					u.isAlive = true;
					u.owner.unitSpawns(u);
					
					u.setYDrawingOffset();
					game.objectsToDraw.erease(u);
					game.objectsToDraw.erease(u);
					game.addObject(u);
				}
		}
		
		else if(msg[0] == "cliffSBeenPlaced")
		{
			msg[1] = parseInt(msg[1]);
			msg[2] = parseInt(msg[2]);
			
			game.makeCliffs(msg[1] - 2, msg[2] - 2, msg[1] + 2, msg[2] + 2);
			
			game.minimap.refreshTilesCanvas(); // when a tile is placed, minimap has to refresh its canvas
			
			
			game.refreshBlockingTilesCanvas(msg[2] - 1);
			game.refreshBlockingTilesCanvas(msg[2]);
			game.refreshBlockingTilesCanvas(msg[2] + 1);
			game.refreshBlockingTilesCanvas(msg[2] + 2);
			
			game.sortTiles();
		}
		
		else if(msg[0] == "setHMValue")
		{
			game.setHMValue(msg[1], msg[2], msg[3]);
		}
		
		else if(msg[0] == "gameData")
			incomingOrders = JSON.parse(msg[1]);
		
		else if(msg[0] == "killRamp")
		{
			game.killRamp(msg[1], msg[2]);
			game.makeCliffs();
		}
		
		else if(msg[0] == "cliffSBeenPlaced2")
		{
			msg[1] = parseInt(msg[1]);
			msg[2] = parseInt(msg[2]);
			
			game.makeCliffs(msg[1] - 2, msg[2] - 2, msg[1] + 2, msg[2] + 2);
			
			game.minimap.refreshTilesCanvas(); // when a tile is placed, minimap has to refresh its canvas
			
			game.generateTilesCanvasses();
			
			game.sortTiles();
			
			if(msg[3] == 0.5 || msg[3] == -0.5)
				game.generateGroundTextureCanvas();
			
			soundManager.playSound(SOUND.PLACE);
		}
		
		else if(msg[0] == "printPath")
		{
			path2Print = JSON.parse(msg[1]);
		}
	}
	
}, false);

// draw loading bar border
c.strokeStyle = "white";
c.fillStyle = "white";
c.lineWidth = 3;
c.strokeRect(WIDTH / 2 - 300, HEIGHT - 150, 600, 50);

// load values from cookie
var playerNameFromCookie = getCookieValue(document.cookie, "name");
var networkPlayerName = validatePlayerName(playerNameFromCookie) ? playerNameFromCookie : "Player1";
var sound_volume = getCookieValue(document.cookie, "sound_volume");
if(sound_volume === "")
	sound_volume = 0.8;
var music_volume = getCookieValue(document.cookie, "music_volume");
if(music_volume === "")
	music_volume = 0.8;
var mouse_scroll_when_window_mode = getCookieValue(document.cookie, "mouse_scroll_off") != "true";
var open_queries_ = getCookieValue(document.cookie, "open_queries");
var open_queries = open_queries_ ? open_queries_ : OPEN_QUERIES.ALWAYS;
var scrollSpeed = parseInt(getCookieValue(document.cookie, "scrollSpeed"));
if(!scrollSpeed && scrollSpeed !== 0)
	scrollSpeed = 2000;
var mmScrollInvert = getCookieValue(document.cookie, "mmScrollInvert") == "true";
var noShowHPBarsWhenFullHP = getCookieValue(document.cookie, "noShowHPBarsWhenFullHP") == "true";
var noMainMenuMusic = getCookieValue(document.cookie, "noMainMenuMusic") == "true";
var dontShowFaq = getCookieValue(document.cookie, "dontShowFaq") == "true";
var dontShowTutButton = getCookieValue(document.cookie, "dontShowTutButton") == "true";
var globalSoundModifierDefault = getCookieValue(document.cookie, "globalSoundModifierDefault");
var noRain = getCookieValue(document.cookie, "noRain") == "true";
if(globalSoundModifierDefault === "")
	globalSoundModifierDefault = 0.0;

// create objects
var lobbyPlayerManager = new LobbyPlayerManager();
var interface_ = new Interface();
var soundManager = null;
var editor = null;
var network = new Network();
var game = null;
var musicManager = null;
var uimanager = new UIManager();
// createLoginView();
var env = new Enviroment();
var mapEditorData = null;

// custom jquery ui tooltip styling
$(function(){
	$(document).tooltip({});
});

// prompt before closing when ingame
window.onbeforeunload = function(){
	if(game_state == GAME.PLAYING || game_state == GAME.EDITOR)
		return "Do you really want to quit ?";
}

var queryButtonBlinkInterval = null;

ressourceLoaded();

// main loop, gets called by the imageLoaded() function, when all images are loaded and the game is ready
function mainLoop()
{
	rAF(mainLoop);
	
	// time stuff and fps output
	newTime = Date.now();
	timeDiff = (newTime - timestamp) / 1000;
	timestamp = newTime;
	
	// fps calculation
	timestampArchives.push(timestamp);
	if(Math.random() < 0.1)
		fps = Math.floor(10 * 1000 / (timestamp - timestampArchives[0]));
	timestampArchives.splice(0, 1);
	
	if(game_state == GAME.PLAYING)
	{
		var oldPercentageOfCurrentTickPassed = percentageOfCurrentTickPassed;
		percentageOfCurrentTickPassed = Math.min((timestamp - timeOfLastUpdate) / TICK_TIME, 1);
		
		// save, how many ticks passed since last rendered frame; we need that for some graphic stuff (particle emitters spawn amount of particles based on this for example)
		gameTimeDiff = Math.max(Math.min(((ticksCounter + percentageOfCurrentTickPassed) - (lastFramesTick + oldPercentageOfCurrentTickPassed)) / 20, 1), 0);
		tickDiff = ticksCounter - lastFramesTick;
		lastFramesTick = ticksCounter;
		
		if(PLAYING_PLAYER.controller == CONTROLLER.SPECTATOR && $('#spectatorDropdown')[0].selectedIndex > 0 && tickDiff > 0 && ticksCounter % 10 == 1)
			game.refreshSpectatorTab();
		
		// draw everything
		game.draw();
		keyManager.draw();
		interface_.draw();
	}
	
	else if(game_state == GAME.EDITOR)
	{
		gameTimeDiff = 0;
		editor.draw();
		keyManager.draw();
	}
	
	else // lobby or menu
	{
		c.fillStyle = "black";
		c.fillRect(0, 0, WIDTH, HEIGHT);
	}
	
	musicManager.draw();
	uimanager.draw();
}




// Survota
(function(w, d, t, v, cb) {
	w[v] = w[v] || {}; w[v].qr = []; w[v].qf = [];
	var got = 0, g = function() {
		if(got){ return; } got = 1;
		var s = d.createElement(t); s.async = 'async';
		s.src = 'https://api.survata.net/v2/js/survata.js?cb='+cb;
		var scr = d.getElementsByTagName(t)[0], par = scr.parentNode; par.insertBefore(s, scr);
		w[v].ft = setTimeout(function() {
			for(var i = 0; i < w[v].qf.length; i++) { w[v].qf[i][0].call(w[v]); }
			w[v].f = 1; w[v].qf = [];
			w[v].fail = function(fn) { fn.call(w[v]); return w[v]; };
		}, 5000);
	};
	w[v].ready = function() { g(); w[v].qr.push(arguments); return w[v]; };
	w[v].fail = function() { g(); w[v].qf.push(arguments); return w[v]; };
	w[v].publisher = 'fa57c9ec-6b4a-4733-a1c6-9c9de1440c1c';
}(window, document, 'script', 'Survata', ((new Date().getTime())/1e3).toFixed()));

var srv = null;
Survata.ready(function() {
	cnSrv();
});





// Analytics
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-46301279-1', 'littlewargame.com');
ga('send', 'pageview');
function colourText(str, col)
{
    return `<font color="${col}">${str}</font>`;
}

var LOGIN_STATE = "NONE";
var recoveryWindow;
var registerWindow;
var loginWindow;

function instantLogin(forceGuest = false)
{
    var password = getPWFromCookie();
    var username = getUserNameFromCookie();
    // console.log(`attempting instant login force${forceGuest}, user${username}`);
    if (!forceGuest && username && password && !username.includes('guest_'))
    {
        console.log(`logging in as user`);
		// writePW2Cookie($('#loginWindowPwCheckbox').is(':checked') ? $('#loginWindowPassword')[0].value : "");
		network.send("login-user<<$" +username + "<<$" + password + "<<$" + "0");
    }
    else
    {
        console.log(`logging in as guest`);
        network.send("login-guest<<$dummy-string");
    }
}

function writePW2Cookie(pw)
{
    // console.log(`writing password cookie ${pw}`)
	pw = pw.split("");
	
	for(var i = 0; i < pw.length; i++)
		pw[i] = String.fromCharCode(pw[i].charCodeAt(0) + 1) + String.fromCharCode(Math.floor(Math.random() * 24) + 97);
	
	pw = "x4" + pw.reverse().join("");
	
	document.cookie = "pw=" + pw + "; expires=" + getGMTDateString4Days(90);
};

function getPWFromCookie()
{
	var pw = getCookieValue(document.cookie, "pw").slice(2);
	pw = pw.split("").reverse();
	
	var newPw = "";
	for(var i = 1; i < pw.length; i += 2)
		newPw += String.fromCharCode(pw[i].charCodeAt(0) - 1);
	
	return newPw;
};

function writeUsernameCookie(username)
{
	document.cookie = "name=" + username;
};

function getUserNameFromCookie()
{
	var username = getCookieValue(document.cookie, "name");
	return username;
};

/** Log in as a user, optionally forcing old sessions to close */
function formLogin(killOldSesions)
{
    console.log(`form login`);
	var username = $('#loginWindowUsername')[0].value;
    var password = $('#loginWindowPassword')[0].value;

	if(username != "" && password != "")
	{
        console.log(`Writing form cookies`)
        console.log(`Logging out`);
		network.send("logout<<$pls");
		network.send("login-user<<$" + username + "<<$" + password + "<<$" + (killOldSesions == "yes" ? "1" : "0"));
		$('#loginWindowState').html("Connecting...");
	}
    else
    {
		$('#loginWindowState').html("Please fill all the fields");
    }
	
	soundManager.playSound(SOUND.CLICK);
}

function saveLogin()
{
    try
    {
        var username = $('#loginWindowUsername')[0].value;
        var password = $('#loginWindowPassword')[0].value;
        
        // console.log(`Saving ${username} ${password}`);
        if (username != "" && password != "")
        {
            writePW2Cookie(password);
            writeUsernameCookie(username);
            // console.log(`SavingCookie ${username} ${password}`);
        }
    }
    catch (err)
    {
        console.log(`Failed to save login`);
    }
}

function createLoginView()
{
    $('#playerGoldWrap')[0].style.visibility = 'hidden';
    if (loginWindow)
    {
        return;
    }
    console.log(`Login window created`);
    /*
    * Login Window
    */
    loginWindow = new UIWindow("loginWindow", function() { return game_state == GAME.LOGIN }, false, "Login");
    elements.push(loginWindow);

    // username
    var loginWindowUsername = document.createElement("input");
    loginWindowUsername.id = "loginWindowUsername";
    loginWindowUsername.value = networkPlayerName;
    loginWindowUsername.type = "text";

    var pwFromCookie = getPWFromCookie();

    // Password
    var loginWindowPassword = document.createElement("input");
    loginWindowPassword.id = "loginWindowPassword";
    loginWindowPassword.type = "password";
    loginWindowPassword.value = pwFromCookie;

    // server response label
    var loginWindowState = document.createElement("p");
    loginWindowState.id = "loginWindowState";

    // name label
    var loginWindowNameLabel = document.createElement("label");
    loginWindowNameLabel.htmlFor = "loginWindowUsername";
    loginWindowNameLabel.id = "loginWindowNameLabel";
    loginWindowNameLabel.innerHTML = "Name";

    // pw label
    var loginWindowPwLabel = document.createElement("label");
    loginWindowPwLabel.htmlFor = "loginWindowPassword";
    loginWindowPwLabel.id = "loginWindowPwLabel";
    loginWindowPwLabel.innerHTML = "Password";

    // save pw checkbox
    var loginWindowPwCheckbox = document.createElement("input");
    loginWindowPwCheckbox.type = "checkbox";
    loginWindowPwCheckbox.id = "loginWindowPwCheckbox";
    loginWindowPwCheckbox.checked = (pwFromCookie && pwFromCookie.length > 0) ? "checked" : "";

    // // save pw label
    var loginWindowSavePwLabel = document.createElement("p");
    loginWindowSavePwLabel.id = "loginWindowSavePwLabel";
    loginWindowSavePwLabel.innerHTML = "save password";

    $('#loginWindow').append(loginWindowState);
    $('#loginWindow').append(loginWindowUsername); 
    $('#loginWindow').append(loginWindowPassword);
    $('#loginWindow').append(loginWindowNameLabel);
    $('#loginWindow').append(loginWindowPwLabel);
    $('#loginWindow').append(loginWindowPwCheckbox);
    $('#loginWindow').append(loginWindowSavePwLabel);

    $('#loginWindow').append(uimanager.createButton("loginWindowLoginButton", "Login", formLogin));
    $('#loginWindow').append(uimanager.createButton("loginWindowBackButton", "Back To Lobby", () =>
    {
        game_state = GAME.LOBBY;
        $('#playerGoldWrap')[0].style.visibility = 'visible';
        
        showPlayerInfo(LOGIN_STATE == "PLAYER");
    }));

    // bind the function to onenter
    loginWindowKeyDown = function(e){
        if(keyManager.getKeyCode(e) == KEY.ENTER)
            $('#loginWindowLoginButton')[0].onclick();
    }
    loginWindowUsername.onkeydown = loginWindowKeyDown;
    loginWindowPassword.onkeydown = loginWindowKeyDown;

    $('#loginWindow').append(uimanager.createButton("loginWindowGuestButton", "Play as a guest", function() {
        
        console.log(`Log in as guest (LoginWindow)`);
		network.send("logout<<$pls");
        network.send("login-guest<<$dummy-string");
        $('#loginWindowState').html("Connecting...");
        
        soundManager.playSound(SOUND.CLICK);
    }));

    $('#loginWindowGuestButton')[0].title = "Login as a guest. You will be able to use most features, so this is perfectly fine for trying out the game.";

    $('#loginWindow').append(uimanager.createButton("loginWindowCreateAccount", "Create account", function() {
        soundManager.playSound(SOUND.CLICK);
        game_state = GAME.REGISTER;
        console.log(`Creating account`)
    }));

    $('#loginWindow').append(uimanager.createButton("recoverPWButton", "Forgot Password?", function() {
        soundManager.playSound(SOUND.CLICK);
        game_state = GAME.RECOVERY;
    }));

    /*
        * Forgot PW
        */
    recoveryWindow = new UIWindow("recoveryWindow", function() { return game_state == GAME.RECOVERY }, false, "Forgot Password");
    var recoveryWindowState = document.createElement("p");
    recoveryWindowState.id = "recoveryWindowState";
    elements.push(recoveryWindow);

    // email
    var recoveryWindowEmail = document.createElement("input");
    recoveryWindowEmail.id = "recoveryWindowEmail";

    // email label
    var recoveryWindowEmailLabel = document.createElement("p");
    recoveryWindowEmailLabel.id = "recoveryWindowEmailLabel";
    recoveryWindowEmailLabel.innerHTML = "eMail";

    // pw
    var recoveryWindowPW = document.createElement("input");
    recoveryWindowPW.id = "recoveryWindowPW";

    // pw label
    var recoveryWindowPWLabel = document.createElement("p");
    recoveryWindowPWLabel.id = "recoveryWindowPWLabel";
    recoveryWindowPWLabel.innerHTML = "new Password";

    $('#recoveryWindow').append(recoveryWindowState);
    $('#recoveryWindow').append(recoveryWindowEmail);
    $('#recoveryWindow').append(recoveryWindowPW);
    $('#recoveryWindow').append(recoveryWindowPWLabel);
    $('#recoveryWindow').append(recoveryWindowEmailLabel);

    $('#recoveryWindow').append(uimanager.createButton("recoveryWindowCreate", "Recover", function() {
        if($('#recoveryWindowEmail')[0].value != "" && $('#recoveryWindowPW')[0].value != "")
        {
            network.send("email-recover<<$" + $('#recoveryWindowEmail')[0].value + "<<$" + $('#recoveryWindowPW')[0].value);
            $('#recoveryWindowState').html("Waiting for server...");
        }
        else
            $('#recoveryWindowState').html("You must fill the field");
        
        soundManager.playSound(SOUND.CLICK);
    }));

    $('#recoveryWindow').append(uimanager.createButton("recoveryWindowBack", "Back", function() {
        
        $('#recoveryWindowEmail')[0].value = "";
        game_state = GAME.LOGIN;
        soundManager.playSound(SOUND.CLICK);
        
    }));
    /*
        * Register Acc
        */
    registerWindow = new UIWindow("registerWindow", function() { return game_state == GAME.REGISTER }, false, "Register");
    elements.push(registerWindow);
    $('#registerWindow')[0].innerHTML = "<p id='createAccLabel'>Create new account</p><p id='registerWindowState'></p><input type='text' id='registerWindowUsername'></input><input type='text' id='registerWindowEmail'></input>";
    $('#registerWindow')[0].innerHTML += "<input type='password' id='registerWindowPassword'></input><p id='registerWindowNameLabel'>Name</p><p id='registerWindowEmailLabel'>eMail</p>";
    $('#registerWindow')[0].innerHTML += "<p id='registerWindowPwLabel'>Password</p><input type='text' id='registerWindowFirstName'></input><input type='text' id='registerWindowLastName'></input>";
    $('#registerWindow')[0].innerHTML += "<p id='registerWindowFirstNameLabel'>First Name</p><p id='registerWindowLastNameLabel'>Last Name</p>";
    $('#registerWindow')[0].innerHTML += "<div id='registerAGBs'><input type='checkbox' id='registerAGBCheckbox' /> I accept the <a class='underline' onclick='showAGB();'>Terms &amp; Conditions</a></div>";


    $('#registerWindow').append(uimanager.createButton("registerWindowBack", "Back", function() {
        
        $('#registerWindowUsername')[0].value = "";
        $('#registerWindowPassword')[0].value = "";
        $('#registerWindowEmail')[0].value = "";
        
        game_state = GAME.LOGIN;
        
        soundManager.playSound(SOUND.CLICK);
        
    }));
    $('#registerWindow').append(uimanager.createButton("registerWindowCreate", "Create", function() {
        if(!$('#registerAGBCheckbox').prop('checked'))
            $('#registerWindowState').html("You must accept the terms and conditions");
        else if($('#registerWindowEmail')[0].value != "" && $('#registerWindowUsername')[0].value != "" && $('#registerWindowPassword')[0].value != "" && $('#registerWindowFirstName')[0].value != "" && $('#registerWindowLastName')[0].value != "")
        {
            network.send("create-account<<$" + $('#registerWindowUsername')[0].value + "<<$" + $('#registerWindowEmail')[0].value + "<<$" + $('#registerWindowPassword')[0].value + "<<$" + $('#registerWindowFirstName')[0].value + "<<$" + $('#registerWindowLastName')[0].value);
            $('#registerWindowState').html("Waiting for server...");
        }
        else
            $('#registerWindowState').html("You must fill all the fields");
        
        soundManager.playSound(SOUND.CLICK);
    }));
    // agb accept div
    var agbAcceptDiv = new UIWindow("agbAcceptDiv", function() { return true }, false, "");
    var agbAcceptDivSubDiv = agbAcceptDiv.addScrollableSubDiv("agbAcceptDivSubDiv");

    $('#agbAcceptDiv')[0].innerHTML += "<div id='agbAcceptSentence'>You have to read and accept the terms and conditions in order to continue</div>";
}


function refreshMainExpDiv()
{
	var lvl = getLvlFromXp(exp);
	var xp1 = getXPRequiredForLvl(lvl);
	var xp2 = getXPRequiredForLvl(lvl + 1);
    
    // TODO: Move CSS into CSS file
    // Give Divs proper IDs & seperate them for layouting
	var str = "<div style='font-size: 26px;'>Level <font class='greenfont'>" + lvl + "</font></div>";
	str += "<div class='xpBar' style='width: 200px; height: 32px; margin: 0 auto;'><div style='width: " + (((exp - xp1) / (xp2 - xp1)) * 200) + "px; height: 32px;'></div>";
	str += "<p style='font-size: 26px;'>" + exp + " / " + xp2 + "</p></div>";
	
	$('#mainExpDiv').html(str);
};

function getXPRequiredForLvl(lvl)
{
	return lvl <= 1 ? 0 : Math.floor(Math.pow(lvl - 1, 1.8) * 150 + 150);
};

function getLvlFromXp(xp)
{
	var lvl = 1;
	
	while(getXPRequiredForLvl(lvl + 1) <= xp)
		lvl++;
	
	return lvl;
};

function showPlayerInfo(show)
{
	try
	{
		const attrib = show ? '' : 'hidden';
		$('#mainLeagueLink')[0].style.visibility = attrib;
		$('#mainExpDiv')[0].style.visibility = attrib;
	}
	catch(e) {}
}
var LETTER_RANK =
{
    S: 0,
    A: 1,
    B: 2,
    C: 3
}

// writes the game statistics to the statistics window
Game.prototype.writeGameStatisticsToWindow = function(winLose)
{
	// build statistics table
	var table = "<table style='margin: 40px auto 30px;'>";
	table += "<tr><td></td><td>Units Killed</td><td>Units Lost</td><td>Buildings Destroyed</td><td>Buildings Lost</td><td>Actions Per Minute</td><td>Mined Gold</td></tr>";
	
	for(var i = 1; i < this.players.length; i++)
		if(this.players[i] && this.players[i].controller != CONTROLLER.SPECTATOR)
		{
			// calculate apm
			var player = this.players[i];
			var apm = Math.floor(player.apm / (ticksCounter / 1200));
			table += "<tr style='color: " + player.getColor() + ";" + (PLAYING_PLAYER == player ? " background-color: rgba(255, 255, 255, 0.2);" : "") + "'>";
			table += "<td style='font-size: 18px;'>" + ((network_game && ladder_game) ? getPlayerLink(player.name) : player.name) + "</td><td class='size24px'>" + player.unitKills + "</td>";
			table += "<td class='size24px'>" + player.unitDeaths + "</td><td class='size24px'>" + player.buildingKills + "</td>";
			table += "<td class='size24px'>" + player.buildingDeaths + "</td><td class='size24px'>" + apm + "</td><td class='size24px'>" + player.minedGold + "</td></tr>";
		}
	
	table += "</table>";
	
    // var img = "<img class='victoryImg pixelated' src='imgs/" + (winLose ? "victory" : "defeat") + ".png' />";
    
	// add statistics to window
    $('#statisticsTextArea').html(table + xpNfo);
    if (LOGIN_STATE == "GUEST")
    {
        var guestAccountPrompt = new UIElement("div", "guestAccountPrompt");
        $('#statisticsTextArea')[0].append(guestAccountPrompt.domElement);
        guestAccountPrompt.domElement.innerHTML = `Log in to gain exp and level up rewards!`;
    }
    if (PLAYING_PLAYER.controller != CONTROLLER.SPECTATOR)
    {
        var rankContainer = new UIElement("div", "rankContainer");
        $('#statisticsTextArea')[0].append(rankContainer.domElement);
    
        var apm_rank = calculateFromThresholds(PLAYING_PLAYER.apm / (ticksCounter / 1200), 30, 60, 120);
        var gold_rank = calculateFromThresholds(PLAYING_PLAYER.minedGold / (ticksCounter / 1200), 300, 600, 1000);
        var buildings_rank = calculateFromThresholds(-PLAYING_PLAYER.buildingDeaths, -20, -10, -5); // Inverted as less is better
        // Time supply blocked
        // Average unspent gold
        console.log(`Unspent: ${PLAYING_PLAYER.unspentGold}`);
    
        createLetterRankDiv(rankContainer.domElement, apm_rank, "APM");
        createLetterRankDiv(rankContainer.domElement, gold_rank, "GOLD PER MIN");
        createLetterRankDiv(rankContainer.domElement, buildings_rank, "BUILDINGS LOST");
    }
	
	// change title to win / lose
	uimanager.statisticsWindow.setTitle(winLose ? "<span class='victoryTitle'>Victory</span>" : "<span class='defeatTitle'>Defeat</span>");
};

function createLetterRankDiv(parentObject, catagory, name, hovertext)
{
    var div = new UIElement("div");
    div.domElement.className = `${catagory}-rank`;
    parentObject.appendChild(div.domElement);

    var img = new UIElement("img");
    img.domElement.src = `/play/imgs/ui/LetterIcons.png`;
    img.domElement.className = `${catagory}-rank-img pixelated`;
    div.domElement.append(img.domElement);

    var nameLabel = new UIElement("div");
    nameLabel.domElement.innerHTML = name;
    nameLabel.domElement.className = `rank-label`;
    div.domElement.append(nameLabel.domElement);
}

function calculateFromThresholds(value, thresholdC, thresholdB, thresholdA)
{
    var rank;
    if (value <= thresholdC) { rank = "C"; }
    else if (value <= thresholdB) { rank = "B"; }
    else if (value <= thresholdA) { rank = "A"; }
    else { rank = "S"; }
    return rank;
}